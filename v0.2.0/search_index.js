var documenterSearchIndex = {"docs":
[{"location":"cli/#Command-line-interface-(CLI)-tool","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"A command line tool raytracer_cli.jl is available to manage through this package the generation and rendering of photorealistic images.","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"This CLI tool recalls functions already present in the Raytracer.jl module, so is possible to run these commands also from the REPL.","category":"page"},{"location":"cli/#Installation","page":"Command line interface (CLI) tool","title":"Installation","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"To use it, clone this repository:","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"git clone https://github.com/Paolo97Gll/Raytracer.jl.git\ncd Raytracer.jl","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"Then, open julia REPL and type the following commands to update your environment:","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"import Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"cli/#Usage","page":"Command line interface (CLI) tool","title":"Usage","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"The menu tree is:","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"raytracer_cli.jl\n├── tonemapping\n└── demo\n    ├── image\n    └── animation","category":"page"},{"location":"cli/#raytracer_cli.jl","page":"Command line interface (CLI) tool","title":"raytracer_cli.jl","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"usage: raytracer_cli.jl [--version] [-h] {tonemapping|demo}\n\nRaytracing for the generation of photorealistic images in Julia.\n\ncommands:\n  tonemapping  apply tone mapping to a pfm image and save it to file\n  demo         show a demo of Raytracer.jl\n\noptional arguments:\n  --version    show version information and exit\n  -h, --help   show this help message and exit","category":"page"},{"location":"cli/#raytracer_cli.jl-tonemapping","page":"Command line interface (CLI) tool","title":"raytracer_cli.jl tonemapping","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"We support as output image type all the formats supported by the packages ImageIO, ImageMagick and QuartzImageIO, including: jpg, png, tiff, ppm, bmp, gif, ...","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"usage: raytracer_cli.jl tonemapping [-a ALPHA] [-g GAMMA] [--version]\n                        [-h] input_file output_file\n\nApply tone mapping to a pfm image and save it to file.\n\noptional arguments:\n  --version          show version information and exit\n  -h, --help         show this help message and exit\n\ntonemapping settings:\n  -a, --alpha ALPHA  scaling factor for the normalization process\n                     (type: Float32, default: 0.5)\n  -g, --gamma GAMMA  gamma value for the tone mapping process (type:\n                     Float32, default: 1.0)\n\nfiles:\n  input_file         path to input file, it must be a PFM file\n  output_file        output file name","category":"page"},{"location":"cli/#raytracer_cli.jl-demo","page":"Command line interface (CLI) tool","title":"raytracer_cli.jl demo","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"usage: raytracer_cli.jl demo [--version] [-h] {image|animation}\n\nShow a demo of Raytracer.jl.\n\ncommands:\n  image       render a demo image of Raytracer.jl\n  animation   create a demo animation of Raytracer.jl (require ffmpeg)\n\noptional arguments:\n  --version   show version information and exit\n  -h, --help  show this help message and exit","category":"page"},{"location":"cli/#raytracer_cli.jl-demo-image","page":"Command line interface (CLI) tool","title":"raytracer_cli.jl demo image","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"usage: raytracer_cli.jl demo image [--force] [-t CAMERA_TYPE]\n                        [-p CAMERA_POSITION] [-o CAMERA_ORIENTATION]\n                        [-d SCREEN_DISTANCE] [-r IMAGE_RESOLUTION]\n                        [-R RENDERER] [-A ANTIALIASING] [--pt_n PT_N]\n                        [--pt_max_depth PT_MAX_DEPTH]\n                        [--pt_roulette_depth PT_ROULETTE_DEPTH]\n                        [-a ALPHA] [-g GAMMA] [-O OUTPUT_FILE]\n                        [--version] [-h]\n\nRender a demo image of Raytracer.jl.\n\noptional arguments:\n  --force               force overwrite\n  --version             show version information and exit\n  -h, --help            show this help message and exit\n\ncamera:\n  -t, --camera_type CAMERA_TYPE\n                        choose camera type (\"perspective\" or\n                        \"orthogonal\") (default: \"perspective\")\n  -p, --camera_position CAMERA_POSITION\n                        camera position in the scene as \"X,Y,Z\"\n                        (default: \"-3,0,0\")\n  -o, --camera_orientation CAMERA_ORIENTATION\n                        camera orientation as \"angX,angY,angZ\"\n                        (default: \"0,0,0\")\n  -d, --screen_distance SCREEN_DISTANCE\n                        only for \"perspective\" camera: distance\n                        between camera and screen (type: Float32,\n                        default: 2.0)\n\nrendering:\n  -r, --image_resolution IMAGE_RESOLUTION\n                        resolution of the rendered image (default:\n                        \"540:540\")\n  -R, --renderer RENDERER\n                        type of renderer to use (\"onoff\", \"flat\",\n                        \"path\" or \"pointlight\") (default: \"path\")\n  -A, --antialiasing ANTIALIASING\n                        number of samples per pixel (must be a perfect\n                        square) (type: Int64, default: 0)\n\npath-tracer options (only for \"path\" renderer):\n  --pt_n PT_N           number of rays fired for mc integration (type:\n                        Int64, default: 10)\n  --pt_max_depth PT_MAX_DEPTH\n                        maximum number of reflections for each ray\n                        (type: Int64, default: 2)\n  --pt_roulette_depth PT_ROULETTE_DEPTH\n                        depth of the russian-roulette algorithm (type:\n                        Int64, default: 3)\n\ntonemapping:\n  -a, --alpha ALPHA     scaling factor for the normalization process\n                        (type: Float32, default: 0.75)\n  -g, --gamma GAMMA     gamma value for the tone mapping process\n                        (type: Float32, default: 1.0)\n\nfiles:\n  -O, --output_file OUTPUT_FILE\n                        output LDR file name (the HDR file will have\n                        the same name, but with \"pfm\" extension)\n                        (default: \"demo.jpg\")","category":"page"},{"location":"cli/#raytracer_cli.jl-demo-animation","page":"Command line interface (CLI) tool","title":"raytracer_cli.jl demo animation","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"usage: raytracer_cli.jl demo animation [--force] [-t CAMERA_TYPE]\n                        [-p CAMERA_POSITION] [-d SCREEN_DISTANCE]\n                        [-r IMAGE_RESOLUTION] [-R RENDERER]\n                        [-A ANTIALIASING] [--pt_n PT_N]\n                        [--pt_max_depth PT_MAX_DEPTH]\n                        [--pt_roulette_depth PT_ROULETTE_DEPTH]\n                        [-a ALPHA] [-g GAMMA] [-D DELTA_THETA]\n                        [-f FPS] [-F OUTPUT_DIR] [-O OUTPUT_FILE]\n                        [--version] [-h]\n\nCreate a demo animation of Raytracer.jl, by generating n images with\ndifferent camera orientation and merging them into an mp4 video.\nRequire ffmpeg installed on local machine.\n\noptional arguments:\n  --force               force overwrite\n  --version             show version information and exit\n  -h, --help            show this help message and exit\n\nframe camera:\n  -t, --camera_type CAMERA_TYPE\n                        choose camera type (\"perspective\" or\n                        \"orthogonal\") (default: \"perspective\")\n  -p, --camera_position CAMERA_POSITION\n                        camera position in the scene as \"X,Y,Z\"\n                        (default: \"-3,0,0\")\n  -d, --screen_distance SCREEN_DISTANCE\n                        only for \"perspective\" camera: distance\n                        between camera and screen (type: Float32,\n                        default: 2.0)\n\nframe rendering:\n  -r, --image_resolution IMAGE_RESOLUTION\n                        resolution of the rendered image (default:\n                        \"540:540\")\n  -R, --renderer RENDERER\n                        type of renderer to use (\"onoff\", \"flat\",\n                        \"path\" or \"pointlight\") (default: \"path\")\n  -A, --antialiasing ANTIALIASING\n                        number of samples per pixel (must be a perfect\n                        square) (type: Int64, default: 0)\n\npath-tracer options (only for \"path\" renderer):\n  --pt_n PT_N           number of rays fired for mc integration (type:\n                        Int64, default: 10)\n  --pt_max_depth PT_MAX_DEPTH\n                        maximum number of reflections for each ray\n                        (type: Int64, default: 2)\n  --pt_roulette_depth PT_ROULETTE_DEPTH\n                        depth of the russian-roulette algorithm (type:\n                        Int64, default: 3)\n\nframe tonemapping:\n  -a, --alpha ALPHA     scaling factor for the normalization process\n                        (type: Float32, default: 0.75)\n  -g, --gamma GAMMA     gamma value for the tone mapping process\n                        (type: Float32, default: 1.0)\n\nanimation parameter:\n  -D, --delta_theta DELTA_THETA\n                        Δθ in camera orientation (around z axis)\n                        between each frame; the number of frames\n                        generated is [360/Δθ] (type: Float32, default:\n                        10.0)\n  -f, --fps FPS         FPS (frame-per-second) of the output video\n                        (type: Int64, default: 15)\n\nfiles:\n  -F, --output_dir OUTPUT_DIR\n                        output directory (default: \"demo_animation\")\n  -O, --output_file OUTPUT_FILE\n                        name of output frames and animation without\n                        extension (default: \"demo\")","category":"page"},{"location":"cli/#Examples","page":"Command line interface (CLI) tool","title":"Examples","text":"","category":"section"},{"location":"cli/#Tone-mapping","page":"Command line interface (CLI) tool","title":"Tone mapping","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"You can use the tonemapping command to apply the tone mapping process to a pfm image. For example, you can use the following command to convert the image test/memorial.pfm into a jpg image:","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"julia raytracer_cli.jl tonemapping test/memorial.pfm memorial.jpg","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"You can also change the default values of alpha and/or gamma to obtain a better tone mapping, according to your source image:","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"julia raytracer_cli.jl tonemapping --alpha 0.35 --gamma 1.3 test/memorial.pfm memorial.jpg","category":"page"},{"location":"cli/#Demo","page":"Command line interface (CLI) tool","title":"Demo","text":"","category":"section"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"You can use the demo image command to render a demo image:","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"julia raytracer_cli.jl demo image","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"It creates two files: demo.pfm (the HDR image) and demo.jpg (the LDR image). You can change the output file name, the LDR extension and other rendering parameters using the command options.","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"To create a demo animation, use the command demo animation:","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"julia raytracer_cli.jl demo animation","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"To enable multithreading, e.g. use 8 threads, use:","category":"page"},{"location":"cli/","page":"Command line interface (CLI) tool","title":"Command line interface (CLI) tool","text":"julia --threads 8 raytracer_cli.jl demo animation","category":"page"},{"location":"package/#Package","page":"Package","title":"Package","text":"","category":"section"},{"location":"package/#Installation","page":"Package","title":"Installation","text":"","category":"section"},{"location":"package/","page":"Package","title":"Package","text":"The package is still under development and is not available in the official registry. To add this package to your work environment, open julia and type the following commands:","category":"page"},{"location":"package/","page":"Package","title":"Package","text":"import Pkg\nPkg.add(url=\"https://github.com/Samuele-Colombo/FileIO.jl\")\nPkg.add(url=\"https://github.com/Samuele-Colombo/ImagePFM.jl\")\nPkg.add(url=\"https://github.com/Paolo97Gll/Raytracer.jl\")","category":"page"},{"location":"package/","page":"Package","title":"Package","text":"We use a custom version of the FileIO package that provides load/save functionalities for pfm files: this integration is done by the package ImagePFM. If FileIO is already present (e.g. the original package), it will be overwritten by this custom version.","category":"page"},{"location":"package/#Usage","page":"Package","title":"Usage","text":"","category":"section"},{"location":"package/","page":"Package","title":"Package","text":"Coming soon!","category":"page"},{"location":"package/#Examples","page":"Package","title":"Examples","text":"","category":"section"},{"location":"package/","page":"Package","title":"Package","text":"Coming soon!","category":"page"},{"location":"#Raytracer.jl-Documentation","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Raytracing package for the generation of photorealistic images in Julia.","category":"page"},{"location":"#Colors-and-images","page":"Raytracer.jl Documentation","title":"Colors and images","text":"","category":"section"},{"location":"#Colors","page":"Raytracer.jl Documentation","title":"Colors","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"colors.jl\"]","category":"page"},{"location":"#Raytracer.BLACK","page":"Raytracer.jl Documentation","title":"Raytracer.BLACK","text":"BLACK\n\nA RGB{Float32} representing a black color.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.BLUE","page":"Raytracer.jl Documentation","title":"Raytracer.BLUE","text":"BLUE\n\nA RGB{Float32} representing a blue color.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.CYAN","page":"Raytracer.jl Documentation","title":"Raytracer.CYAN","text":"CYAN\n\nA RGB{Float32} representing a cyan color.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.GREEN","page":"Raytracer.jl Documentation","title":"Raytracer.GREEN","text":"GREEN\n\nA RGB{Float32} representing a green color.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.MAGENTA","page":"Raytracer.jl Documentation","title":"Raytracer.MAGENTA","text":"MAGENTA\n\nA RGB{Float32} representing a magenta color.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.RED","page":"Raytracer.jl Documentation","title":"Raytracer.RED","text":"RED\n\nA RGB{Float32} representing a red color.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.WHITE","page":"Raytracer.jl Documentation","title":"Raytracer.WHITE","text":"WHITE\n\nA RGB{Float32} representing a white color.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.YELLOW","page":"Raytracer.jl Documentation","title":"Raytracer.YELLOW","text":"YELLOW\n\nA RGB{Float32} representing a yellow color.\n\n\n\n\n\n","category":"constant"},{"location":"#Base.:*-Tuple{RGB, RGB}","page":"Raytracer.jl Documentation","title":"Base.:*","text":"*(c1::RGB, c2::RGB)\n\nReturn the elementwise product of two colors.\n\nExamples\n\njulia> RGB(1f0, 2f0, 3f0) * RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 4.0, G: 10.0, B: 18.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{Number, RGB{T}}} where T","page":"Raytracer.jl Documentation","title":"Base.:*","text":"*(scalar::Number, c::RGB)\n*(c::RGB, scalar::Number)\n\nReturn a RGB{T} color with each component multiplied by scalar.\n\nExamples\n\njulia> c = 2.0 * RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 8.0, G: 10.0, B: 12.0\n\njulia> RGB(4f0, 5f0, 6f0) * 2.0 == c\ntrue\n\njulia> c = 2.0 * RGB(4.0, 5.0, 6.0)\nRGB color with eltype Float64\nR: 8.0, G: 10.0, B: 12.0\n\njulia> RGB(4.0, 5.0, 6.0) * 2.0 == c\ntrue\n\nNote that the eltype of RGB is mantained.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{RGB, RGB}","page":"Raytracer.jl Documentation","title":"Base.:+","text":"+(c1::RGB, c2::RGB)\n\nReturn the elementwise sum of two colors.\n\nExamples\n\njulia> RGB(1f0, 2f0, 3f0) + RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 5.0, G: 7.0, B: 9.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Tuple{RGB, RGB}","page":"Raytracer.jl Documentation","title":"Base.:-","text":"-(c1::RGB, c2::RGB)\n\nReturn the elementwise difference of two colors.\n\nExamples\n\njulia> RGB(1f0, 2f0, 3f0) - RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: -3.0, G: -3.0, B: -3.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.:≈-Tuple{RGB, RGB}","page":"Raytracer.jl Documentation","title":"Base.:≈","text":"≈(c1::RGB, c2::RGB)\n\nCheck if two colors are close.\n\nExamples\n\njulia> c = RGB(1f0, 2f0, 3f0) * RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 4.0, G: 10.0, B: 18.0\n\njulia> c ≈ RGB(4f0, 10f0, 18f0)\ntrue\n\njulia> c ≈ RGB(0f0, 0f0, 0f0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.Math.clamp-Union{Tuple{RGB{T}}, Tuple{T}} where T","page":"Raytracer.jl Documentation","title":"Base.Math.clamp","text":"clamp(c::RGB)\n\nReturn a clamped RGB{T} color, with each component x obtained with the formula:\n\nfracx1 + x\n\nExamples\n\njulia> clamp(RGB(1f0, 2f0, 3f0))\nRGB color with eltype Float32\nR: 0.5, G: 0.6666667, B: 0.75\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.luminosity-Tuple{RGB}","page":"Raytracer.jl Documentation","title":"Raytracer.luminosity","text":"luminosity(c::RGB)\n\nReturn the mean value between the maximum component and the minumum component of a color:\n\nfracmathrmmax(c) + mathrmmin(c)2\n\nExamples\n\njulia> luminosity(RGB(1f0, 2f0, 3f0))\n2.0f0\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.γ_correction-Union{Tuple{T}, Tuple{RGB{T}, Float32}} where T","page":"Raytracer.jl Documentation","title":"Raytracer.γ_correction","text":"γ_correction(c::RGB, γ::Float32)\n\nReturn a RGB{T} color, with each component x corrected with the formula:\n\nx^1  gamma\n\nExamples\n\njulia> c = RGB(1f0, 2f0, 3f0);\n\njulia> γ_correction(c, 1f0)\nRGB color with eltype Float32\nR: 1.0, G: 2.0, B: 3.0\n\njulia> γ_correction(c, 0.8f0)\nRGB color with eltype Float32\nR: 1.0, G: 2.3784142, B: 3.948222\n\njulia> γ_correction(c, 2.4f0)\nRGB color with eltype Float32\nR: 1.0, G: 1.3348398, B: 1.580522\n\n\n\n\n\n","category":"method"},{"location":"#HDR-image","page":"Raytracer.jl Documentation","title":"HDR image","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"hdrimage.jl\"]","category":"page"},{"location":"#Raytracer.HdrImage","page":"Raytracer.jl Documentation","title":"Raytracer.HdrImage","text":"struct HdrImage\n\nWrapper of a Matrix of elements of type RGB{Float32}, used to represent an image in hdr format.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.HdrImage-Tuple{AbstractVector{var\"#s4\"} where var\"#s4\", Integer, Integer}","page":"Raytracer.jl Documentation","title":"Raytracer.HdrImage","text":"HdrImage(arr::AbstractArray{<:Any, 1}, im_width::Integer, im_height::Integer)\nHdrImage(arr::AbstractArray{<:Any, 1}, shape)\n\nConstruct an HdrImage wrapping a matrix obtained from reshape.\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> HdrImage(arr, 3, 2)\n3x2 HdrImage:\n (1.0 2.0 3.0)  (10.0 11.0 12.0)\n (4.0 5.0 6.0)  (13.0 14.0 15.0)\n (7.0 8.0 9.0)  (16.0 17.0 18.0)\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.HdrImage-Tuple{Integer, Integer}","page":"Raytracer.jl Documentation","title":"Raytracer.HdrImage","text":"HdrImage(img_width::Integer, img_height::Integer)\n\nConstruct an HdrImage wrapping a zero-initialized matrix of size (img_width, img_height).\n\nExamples\n\njulia> HdrImage(3, 2)\n3x2 HdrImage:\n (0.0 0.0 0.0)  (0.0 0.0 0.0)\n (0.0 0.0 0.0)  (0.0 0.0 0.0)\n (0.0 0.0 0.0)  (0.0 0.0 0.0)\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.HdrImage-Tuple{Matrix{RGB{Float32}}}","page":"Raytracer.jl Documentation","title":"Raytracer.HdrImage","text":"HdrImage(pixel_matrix::Matrix{RGB{Float32}})\n\nConstructor for a HdrImage instance.\n\n\n\n\n\n","category":"method"},{"location":"#Base.Math.clamp-Tuple{HdrImage}","page":"Raytracer.jl Documentation","title":"Base.Math.clamp","text":"clamp(image::HdrImage)\n\nAdjust the color levels of the brightest pixels of a HdrImage, by applying the clamp(::RGB) function to each pixel.\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> clamp(HdrImage(arr, 3, 2))\n3x2 HdrImage:\n (0.5 0.6666667 0.75)        (0.90909094 0.9166667 0.9230769)\n (0.8 0.8333333 0.85714287)  (0.9285714 0.93333334 0.9375)\n (0.875 0.8888889 0.9)       (0.9411765 0.9444444 0.94736844)\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.normalize-Tuple{HdrImage, Float32}","page":"Raytracer.jl Documentation","title":"LinearAlgebra.normalize","text":"normalize(image::HdrImage, α::Float32\n          ; luminosity::Float32 = average_luminosity(image))\n\nNormalize a HdrImage for a given luminosity.\n\nIf the luminosity parameter is not specified, the image will be normalized according to the result of luminosity(::HdrImage; ::Float32).\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> normalize(HdrImage(arr, 3, 2), 1f0)\n3x2 HdrImage:\n (0.12976472 0.25952944 0.38929415)  (1.2976472 1.4274119 1.5571766)\n (0.5190589 0.6488236 0.7785883)     (1.6869414 1.8167061 1.9464709)\n (0.90835303 1.0381178 1.1678824)    (2.0762355 2.2060003 2.335765)\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.luminosity-Tuple{HdrImage}","page":"Raytracer.jl Documentation","title":"Raytracer.luminosity","text":"luminosity(image::HdrImage; δ::Float32 = eps(Float32))\n\nReturn the average luminosity an HdrImage as the logaritmic mean of the luminosity(::RGB) l_i of each pixel:\n\nleft l right = 10^fracsum_i log_10(delta + l_i)N\n\nThe parameter δ avoid singularities for l_i = 0 (black pixels).\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> luminosity(HdrImage(arr, 3, 2))\n7.706255f0\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.γ_correction-Tuple{HdrImage, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.γ_correction","text":"γ_correction(image::HdrImage, γ::Float32)\n\nCompute the γ correction of a HdrImage, by applying the γ_correction(::RGB, ::Float32) function to each pixel.\n\nBefore calling this function, you should apply a tone-mapping algorithm to the image and be sure that the R, G, and B values of the colors in the image are all in the range 0 1. Use normalize(::HdrImage, ::Float32; ::Float32) and clamp(image::HdrImage) to do this.\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> image = normalize(HdrImage(arr, 3, 2), 1f0) |> clamp;\n\njulia> γ_correction(image, 1f0)\n3x2 HdrImage:\n (0.11485995 0.20605269 0.28021002)  (0.5647722 0.58803856 0.6089437)\n (0.34169766 0.393507 0.43775633)    (0.6278296 0.64497536 0.660611)\n (0.47598794 0.5093512 0.53872037)   (0.67492735 0.6880849 0.7002187)\n\njulia> γ_correction(image, 0.8f0)\n3x2 HdrImage:\n (0.06686684 0.13882665 0.20387058)  (0.48960024 0.51494074 0.53792465)\n (0.26124772 0.31166682 0.35607424)  (0.558859 0.57800144 0.5955692)\n (0.39536202 0.43030033 0.4615346)   (0.6117462 0.6266897 0.64053386)\n\njulia> γ_correction(image, 2.4f0)\n3x2 HdrImage:\n (0.40588558 0.5177947 0.58855206)  (0.7881591 0.8015287 0.8132807)\n (0.63926977 0.6780008 0.7087834)   (0.82369685 0.83299613 0.8413514)\n (0.73394746 0.7549599 0.77280176)  (0.8489011 0.8557578 0.86201346)\n\n\n\n\n\n","category":"method"},{"location":"#Geometry","page":"Raytracer.jl Documentation","title":"Geometry","text":"","category":"section"},{"location":"#Geometry-2","page":"Raytracer.jl Documentation","title":"Geometry","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"geometry.jl\"]","category":"page"},{"location":"#Raytracer.NORMAL_X","page":"Raytracer.jl Documentation","title":"Raytracer.NORMAL_X","text":"NORMAL_X\n\nA unitary and normalized Normal{true} along the x-axis.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.NORMAL_X_false","page":"Raytracer.jl Documentation","title":"Raytracer.NORMAL_X_false","text":"NORMAL_X_false\n\nA unitary and non-normalized Normal{false} along the x-axis.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.NORMAL_Y","page":"Raytracer.jl Documentation","title":"Raytracer.NORMAL_Y","text":"NORMAL_Y\n\nA unitary and normalized Normal{true} along the y-axis.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.NORMAL_Y_false","page":"Raytracer.jl Documentation","title":"Raytracer.NORMAL_Y_false","text":"NORMAL_Y_false\n\nA unitary and non-normalized Normal{false} along the y-axis.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.NORMAL_Z","page":"Raytracer.jl Documentation","title":"Raytracer.NORMAL_Z","text":"NORMAL_Z\n\nA unitary and normalized Normal{true} along the z-axis.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.NORMAL_Z_false","page":"Raytracer.jl Documentation","title":"Raytracer.NORMAL_Z_false","text":"NORMAL_Z_false\n\nA unitary and non-normalized Normal{false} along the z-axis.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.ORIGIN","page":"Raytracer.jl Documentation","title":"Raytracer.ORIGIN","text":"ORIGIN\n\nA Point representing the origin of the frame of reference.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.VEC_X","page":"Raytracer.jl Documentation","title":"Raytracer.VEC_X","text":"VEC_X\n\nA unitary Vec along the x-axis.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.VEC_Y","page":"Raytracer.jl Documentation","title":"Raytracer.VEC_Y","text":"VEC_Y\n\nA unitary Vec along the y-axis.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.VEC_Z","page":"Raytracer.jl Documentation","title":"Raytracer.VEC_Z","text":"VEC_Z\n\nA unitary Vec along the z-axis.\n\n\n\n\n\n","category":"constant"},{"location":"#Raytracer.Normal","page":"Raytracer.jl Documentation","title":"Raytracer.Normal","text":"struct Normal{V} <: StaticArrays.FieldVector{3, Float32}\n\nA pseudo-vector in 3D space with 3 fields x, y, and z of type Float32. The parameter V tells if the normal is normalized or not.\n\nFor inherited properties and constructors see StaticArrays.FieldVector.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Normal-Tuple{Any, Any, Any}","page":"Raytracer.jl Documentation","title":"Raytracer.Normal","text":"Normal(x, y, z)\n\nConstruct a non-normalized Normal{false} with given coordinates. All values are converted in Float32.\n\nExamples\n\njulia> Normal(1.2, 3.3, 5)\nNormal with eltype Float32, not normalized\nx = 1.2, y = 3.3, z = 5.0\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Normal-Union{Tuple{Float32, Float32, Float32}, Tuple{V}} where V","page":"Raytracer.jl Documentation","title":"Raytracer.Normal","text":"Normal{V}(x::Float32, y::Float32, z::Float32)\n\nConstructor for a Normal instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Point","page":"Raytracer.jl Documentation","title":"Raytracer.Point","text":"struct Point\n\nA point in a 3D space. Implemented as a wrapper struct around a SVector{3, Float32}.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Point-Tuple{AbstractVector{T} where T}","page":"Raytracer.jl Documentation","title":"Raytracer.Point","text":"Point(p::AbstractVector)\n\nConstructor for a Point instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Point-Tuple{Any, Any, Any}","page":"Raytracer.jl Documentation","title":"Raytracer.Point","text":"Point(x, y, z)\n\nConstruct a Point with given coordinates. All values are converted in Float32.\n\nExamples\n\njulia> Point(1.2, 3.3, 5)\nPoint with eltype Float32\nx = 1.2, y = 3.3, z = 5.0\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Vec","page":"Raytracer.jl Documentation","title":"Raytracer.Vec","text":"struct Vec <: StaticArrays.FieldVector{3, Float32}\n\nA vector in 3D space with 3 fields x, y, and z of type Float32.\n\nFor inherited properties and constructors see StaticArrays.FieldVector.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Vec-Tuple{Float32, Float32, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.Vec","text":"Vec(x::Float32, y::Float32, z::Float32)\n\nConstructor for a Vec instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Vec2D","page":"Raytracer.jl Documentation","title":"Raytracer.Vec2D","text":"Vec2D\n\nAlias to SVector{2, Float32}, used for uv mapping on shapes.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:*-Tuple{Point, Vararg{Any, N} where N}","page":"Raytracer.jl Documentation","title":"Base.:*","text":"*(p::Point, s...)\n\nMultiplication operator. x * y * z * ...calls this function with all arguments, i.e.*(x, y, z, ...)`.\n\nReturn a Point.\n\nExamples\n\njulia> Point(1, 2, 3) * 2 * 3\nPoint with eltype Float32\nx = 6.0, y = 12.0, z = 18.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{Point, Vec}","page":"Raytracer.jl Documentation","title":"Base.:+","text":"+(p::Point, v::Vec)\n\nReturn the elementwise sum between a Point and a Vec as an instance of Point.\n\nExamples\n\njulia> Point(1, 2, 3) + Vec(4, 5, 6)\nPoint with eltype Float32\nx = 5.0, y = 7.0, z = 9.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Tuple{Point, Point}","page":"Raytracer.jl Documentation","title":"Base.:-","text":"-(p1::Point, p2::Point)\n\nReturn the elementwise difference of two Point as an instance of Vec.\n\nExamples\n\njulia> Point(1, 2, 3) - Point(4, 5, 6)\nVec with eltype Float32\nx = -3.0, y = -3.0, z = -3.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Tuple{Point, Vec}","page":"Raytracer.jl Documentation","title":"Base.:-","text":"-(p::Point, v::Vec)\n\nReturn the elementwise difference between a Point and a Vec as an instance of Point.\n\nExamples\n\njulia> Point(1, 2, 3) - Vec(4, 5, 6)\nPoint with eltype Float32\nx = -3.0, y = -3.0, z = -3.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.:≈-Tuple{Point, Point}","page":"Raytracer.jl Documentation","title":"Base.:≈","text":"≈(p1::Point, p2::Point)\n\nCheck if two points are close.\n\nExamples\n\njulia> p = Point(1, 2, 3);\n\njulia> p ≈ Point(1, 2, 3)\ntrue\n\njulia> p ≈ Point(0, 0, 0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.convert-Tuple{Type{Vec}, Point}","page":"Raytracer.jl Documentation","title":"Base.convert","text":"convert(::Type{Vec}, p::Point)\nconvert(::Type{Normal}, p::Point)\n\nConvert a Point into the specified type (Vec or Normal{false}).\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.norm-Tuple{Normal{true}}","page":"Raytracer.jl Documentation","title":"LinearAlgebra.norm","text":"norm(n::Normal{true})\n\nCompute the squared norm of a Normal{true}. Since n is already normalized, 1f0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.normalize-Tuple{Normal{false}}","page":"Raytracer.jl Documentation","title":"LinearAlgebra.normalize","text":"normalize(n::Normal{V}) where {V}\n\nNormalize n and return a Normal{true}. If V is true, no normalization is computed and n is returned.\n\nExamples\n\njulia> n = normalize(Normal(1,2,4))\nNormal with eltype Float32, normalized\nx = 0.21821788, y = 0.43643576, z = 0.8728715\n\njulia> normalize(n)\nNormal with eltype Float32, normalized\nx = 0.21821788, y = 0.43643576, z = 0.8728715\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.create_onb_from_z-Tuple{Normal}","page":"Raytracer.jl Documentation","title":"Raytracer.create_onb_from_z","text":"create_onb_from_z(input_normal::Normal)\n\nCreate an orthonormal base from a input Normal representing the z-axis using the Duff et al. 2017 algorithm.\n\nExamples\n\njulia> n = Normal(0,0,5);\n\njulia> nn = normalize(Normal(0,0,5));\n\njulia> create_onb_from_z(n)\n(Vec(1.0, -0.0, -0.0), Vec(-0.0, 1.0, -0.0), Vec(0.0, 0.0, 1.0))\n\njulia> create_onb_from_z(nn)\n(Vec(1.0, -0.0, -0.0), Vec(-0.0, 1.0, -0.0), Vec(0.0, 0.0, 1.0))\n\nNote that create_onb_from_z(n) and create_onb_from_z(nn) give the same result.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.normalized_dot-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"Raytracer.jl Documentation","title":"Raytracer.normalized_dot","text":"normalized_dot(v1::AbstractVector, v2::AbstractVector)\n\nNormalize v1 and v2 and then compute the dot product.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.norm²-Tuple{Normal{false}}","page":"Raytracer.jl Documentation","title":"Raytracer.norm²","text":"norm²(n::Normal{V}) where {V}\n\nCompute the squared norm of a Normal. If V is true, 1f0 is returned.\n\nExamples\n\njulia> n = Normal(1, 2, 3);\n\njulia> norm²(n)\n14.0f0\n\njulia> norm²(normalize(n))\n1.0f0\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.norm²-Tuple{Vec}","page":"Raytracer.jl Documentation","title":"Raytracer.norm²","text":"norm²(v::Vec)\n\nCompute the squared norm of a Vec.\n\nExamples\n\njulia> norm²(Vec(1, 2, 3))\n14.0f0\n\n\n\n\n\n","category":"method"},{"location":"#Transformations","page":"Raytracer.jl Documentation","title":"Transformations","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"transformations.jl\"]","category":"page"},{"location":"#Raytracer.Transformation","page":"Raytracer.jl Documentation","title":"Raytracer.Transformation","text":"struct Transformation\n\nA wrapper around two 4x4 matrices representing a transformation for Vec, Normal, and Point instances.\n\nA 4x4 matrix is needed to use the properties of homogeneous coordinates in 3D space. Storing the inverse of the transformation significantly increases performance at the cost of memory space.\n\nMembers\n\nm::SMatrix{4, 4, Float32}: the homogeneous matrix representation of the transformation.\ninvm::SMatrix{4, 4, Float32}: the homogeneous matrix representation of the inverse transformation.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Transformation-Tuple{AbstractMatrix{T} where T}","page":"Raytracer.jl Documentation","title":"Raytracer.Transformation","text":"Transformation(m::AbstractMatrix)\nTransformation(m::AbstractMatrix, invm::AbstractMatrix)\n\nConstruct a Transformation instance from m and invm. The elements of the matrix will be casted to Float32.\n\nIf any argument is an AbstractMatrix, it will be implicitly casted to a StaticArrays.SMatrix to increase performance.\n\nExamples\n\njulia> Transformation(StaticArrays.SMatrix{4,4}([1 0 0 0; 0 2 0 0; 0 0 4 0; 0 0 0 1]))\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  4.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0   0.0f0\n 0.0f0  0.5f0  0.0f0   0.0f0\n 0.0f0  0.0f0  0.25f0  0.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\njulia> Transformation([1 0 0 0; 0 2 0 0; 0 0 4 0; 0 0 0 1])\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  4.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0   0.0f0\n 0.0f0  0.5f0  0.0f0   0.0f0\n 0.0f0  0.0f0  0.25f0  0.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\njulia> Transformation(LinearAlgebra.Diagonal([1,2,4,1]))\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  4.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0   0.0f0\n 0.0f0  0.5f0  0.0f0   0.0f0\n 0.0f0  0.0f0  0.25f0  0.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Transformation-Tuple{StaticArrays.SMatrix{4, 4, Float32, L} where L, StaticArrays.SMatrix{4, 4, Float32, L} where L}","page":"Raytracer.jl Documentation","title":"Raytracer.Transformation","text":"Transformation(m::SMatrix{4, 4, Float32} = SMatrix{4, 4, Float32}(I(4)),\n               invm::SMatrix{4, 4, Float32} = inv(m))\n\nConstructor for a Transformation instance.\n\nIf no parameter is specified, then an identity transformation is returned. If only the direct matrix is specified, then the inverse matrix is automatically computed.\n\nExamples\n\njulia> Transformation()\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  1.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  1.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  1.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  1.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\n\n\n\n\n\n","category":"method"},{"location":"#Base.inv-Tuple{Transformation}","page":"Raytracer.jl Documentation","title":"Base.inv","text":"inv(t::Transformation)\n\nReturn the inverse Transformation.\n\nReturns a Transformation which has the m and invm fields swapped.\n\nExamples\n\n```jldoctest; setup = :(using LinearAlgebra: Diagonal) julia> t = Transformation(Diagonal([1, 2, 3, 1])) 4x4 Transformation: Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0  0.0f0  0.0f0  2.0f0  0.0f0  0.0f0  0.0f0  0.0f0  3.0f0  0.0f0  0.0f0  0.0f0  0.0f0  1.0f0 Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0         0.0f0  0.0f0  0.5f0  0.0f0         0.0f0  0.0f0  0.0f0  0.33333334f0  0.0f0  0.0f0  0.0f0  0.0f0         1.0f0\n\njulia> inv(t) 4x4 Transformation: Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0         0.0f0  0.0f0  0.5f0  0.0f0         0.0f0  0.0f0  0.0f0  0.33333334f0  0.0f0  0.0f0  0.0f0  0.0f0         1.0f0 Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0  0.0f0  0.0f0  2.0f0  0.0f0  0.0f0  0.0f0  0.0f0  3.0f0  0.0f0  0.0f0  0.0f0  0.0f0  1.0f0  ```\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.isconsistent-Tuple{Transformation}","page":"Raytracer.jl Documentation","title":"Raytracer.isconsistent","text":"isconsistent(t::Transformation)\n\nReturn true if t.m * t.invm is similar to the identity matrix and so the Transformation is consistent.\n\nMainly used for testing and to verify matrices haven't been mutated.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.rotationX","page":"Raytracer.jl Documentation","title":"Raytracer.rotationX","text":"rotationX(θ::Real)\n\nReturn a Transformation that rotates a 3D vector field of the given angle around the X-axis.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> rotationX(π/4)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0          0.0f0         0.0f0\n 0.0f0  0.70710677f0  -0.70710677f0  0.0f0\n 0.0f0  0.70710677f0   0.70710677f0  0.0f0\n 0.0f0  0.0f0          0.0f0         1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0   0.0f0         0.0f0         0.0f0\n 0.0f0   0.70710677f0  0.70710677f0  0.0f0\n 0.0f0  -0.70710677f0  0.70710677f0  0.0f0\n 0.0f0   0.0f0         0.0f0         1.0f0\n\n\n\n\n\n","category":"function"},{"location":"#Raytracer.rotationY","page":"Raytracer.jl Documentation","title":"Raytracer.rotationY","text":"rotationY(θ::Real)\n\nReturn a Transformation that rotates a 3D vector field of the given angle around the Y-axis.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> rotationY(π/4)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n  0.70710677f0  0.0f0  0.70710677f0  0.0f0\n  0.0f0         1.0f0  0.0f0         0.0f0\n -0.70710677f0  0.0f0  0.70710677f0  0.0f0\n  0.0f0         0.0f0  0.0f0         1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 0.70710677f0  0.0f0  -0.70710677f0  0.0f0\n 0.0f0         1.0f0   0.0f0         0.0f0\n 0.70710677f0  0.0f0   0.70710677f0  0.0f0\n 0.0f0         0.0f0   0.0f0         1.0f0\n\n\n\n\n\n","category":"function"},{"location":"#Raytracer.rotationZ","page":"Raytracer.jl Documentation","title":"Raytracer.rotationZ","text":"rotationZ(θ::Real)\n\nReturn a Transformation that rotates a 3D vector field of the given angle around the Z-axis.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> rotationZ(π/4)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 0.70710677f0  -0.70710677f0  0.0f0  0.0f0\n 0.70710677f0   0.70710677f0  0.0f0  0.0f0\n 0.0f0          0.0f0         1.0f0  0.0f0\n 0.0f0          0.0f0         0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n  0.70710677f0  0.70710677f0  0.0f0  0.0f0\n -0.70710677f0  0.70710677f0  0.0f0  0.0f0\n  0.0f0         0.0f0         1.0f0  0.0f0\n  0.0f0         0.0f0         0.0f0  1.0f0\n\n\n\n\n\n","category":"function"},{"location":"#Raytracer.scaling-Tuple{Real, Real, Real}","page":"Raytracer.jl Documentation","title":"Raytracer.scaling","text":"scaling(x::Real, y::Real, z::Real)\nscaling(s::Real)\nscaling(v::AbstractVector)\n\nReturn a Transformation that scales a 3D vector field of a given factor for each axis.\n\nIf a single Real is provided as argument then the scaling is considered uniform. If an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> scaling(1, 2, 3)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  3.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0         0.0f0\n 0.0f0  0.5f0  0.0f0         0.0f0\n 0.0f0  0.0f0  0.33333334f0  0.0f0\n 0.0f0  0.0f0  0.0f0         1.0f0\n\njulia> scaling(2)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 2.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  2.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 0.5f0  0.0f0  0.0f0  0.0f0\n 0.0f0  0.5f0  0.0f0  0.0f0\n 0.0f0  0.0f0  0.5f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\n\njulia> scaling([1, 2, 3])\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  3.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0         0.0f0\n 0.0f0  0.5f0  0.0f0         0.0f0\n 0.0f0  0.0f0  0.33333334f0  0.0f0\n 0.0f0  0.0f0  0.0f0         1.0f0\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.translation-Tuple{AbstractVector{T} where T}","page":"Raytracer.jl Documentation","title":"Raytracer.translation","text":"translation(v::AbstractVector)\ntranslation(x::Real, y::Real, z::Real)\n\nReturn a Transformation that translates a 3D vector field of the given coordinates.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> translation(1, 2, 3)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  1.0f0\n 0.0f0  1.0f0  0.0f0  2.0f0\n 0.0f0  0.0f0  1.0f0  3.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  -1.0f0\n 0.0f0  1.0f0  0.0f0  -2.0f0\n 0.0f0  0.0f0  1.0f0  -3.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\njulia> translation([1, 2, 3])\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  1.0f0\n 0.0f0  1.0f0  0.0f0  2.0f0\n 0.0f0  0.0f0  1.0f0  3.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  -1.0f0\n 0.0f0  1.0f0  0.0f0  -2.0f0\n 0.0f0  0.0f0  1.0f0  -3.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\n\n\n\n\n","category":"method"},{"location":"#Scene","page":"Raytracer.jl Documentation","title":"Scene","text":"","category":"section"},{"location":"#Ray","page":"Raytracer.jl Documentation","title":"Ray","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"ray.jl\"]","category":"page"},{"location":"#Raytracer.Ray","page":"Raytracer.jl Documentation","title":"Raytracer.Ray","text":"struct Ray\n\nA ray of light propagating in space.\n\nMembers\n\norigin::Point: the (Point) where the ray originated.\ndir::Vec: a (Vec) representing the direction along which this ray propagates.\ntmin::Float32: the minimum distance travelled by the ray is this number times dir.\ntmax::Float32: the maximum distance travelled by the ray is this number times dir.\ndepth::Int: number of times this ray was reflected/refracted.\n\nSee also: Ray(::Float32)\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Ray-Tuple{Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.Ray","text":"(r::Ray)(t::Float32)\n\nReturn a Point lying on the given Ray at t.\n\nAn instance of Ray can be called as a function returning a Point given the position parameter t:\n\nmathrmray_origin + mathrmray_direction cdot t\n\nArgument t must be included between r.tmin and r.tmax or be equal to 0. If t is zero, then the returned point is the origin of r.\n\nExamples\n\njulia> ray = Ray(ORIGIN, VEC_X)\nRay\n ↳ origin = Point(0.0, 0.0, 0.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\njulia> ray(5f0)\nPoint with eltype Float32\nx = 5.0, y = 0.0, z = 0.0\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Ray-Tuple{Point, Vec, Float32, Float32, Int64}","page":"Raytracer.jl Documentation","title":"Raytracer.Ray","text":"Ray(origin::Point, dir::Vec, tmin::Float32, tmax::Float32, depth::Int)\n\nConstructor for a Ray instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Ray-Tuple{Point, Vec}","page":"Raytracer.jl Documentation","title":"Raytracer.Ray","text":"Ray(origin::Point, dir::Vec\n    ; tmin::Float32 = 1f-5,\n      tmax::Float32 = typemax(Float32),\n      depth::Int = 0)\n\nConstructor for a Ray instance.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{Transformation, Ray}","page":"Raytracer.jl Documentation","title":"Base.:*","text":"*(t::Transformation, r::Ray)\n\nTransform a Ray with the given Transformation.\n\nExamples\n\njulia> ray = Ray(ORIGIN, VEC_X)\nRay\n ↳ origin = Point(0.0, 0.0, 0.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\njulia> Transformation() * ray\nRay\n ↳ origin = Point(0.0, 0.0, 0.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\njulia> translation(2,4,-6) * ray\nRay\n ↳ origin = Point(2.0, 4.0, -6.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\n\n\n\n\n","category":"method"},{"location":"#Base.:≈-Tuple{Ray, Ray}","page":"Raytracer.jl Documentation","title":"Base.:≈","text":"≈(r1::Ray, r2::Ray)\n\nCheck if two Ray represent the same ray of light or not.\n\n\n\n\n\n","category":"method"},{"location":"#Cameras","page":"Raytracer.jl Documentation","title":"Cameras","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"cameras.jl\"]","category":"page"},{"location":"#Raytracer.Camera","page":"Raytracer.jl Documentation","title":"Raytracer.Camera","text":"Camera\n\nAn abstract type representing an observer.\n\nSee also: OrthogonalCamera, PerspectiveCamera\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.OrthogonalCamera","page":"Raytracer.jl Documentation","title":"Raytracer.OrthogonalCamera","text":"struct OrthogonalCamera <: Camera\n\nA Camera implementing an orthogonal 3D → 2D projection.\n\nMembers\n\naspect_ratio::Float32: defines how larger than the height is the image (16/9, 4/3, ...).\ntransformation::Transformation: define the Transformation applied to the rays generated by the camera.\n\nSee also: fire_ray(::OrthogonalCamera, ::Float32, ::Float32)\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.OrthogonalCamera-Tuple{Float32, Transformation}","page":"Raytracer.jl Documentation","title":"Raytracer.OrthogonalCamera","text":"OrthogonalCamera(aspect_ratio::Float32, transformation::Transformation)\n\nConstructor for an OrthogonalCamera instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.OrthogonalCamera-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.OrthogonalCamera","text":"OrthogonalCamera(; aspect_ratio::Float32 = 1f0,\n                   transformation::Transformation = Transformation())\n\nKeyword-based constructor for an OrthogonalCamera instance.\n\nIf no parameter is specified, it return a camera with square aspect ratio and an identity transformation.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.PerspectiveCamera","page":"Raytracer.jl Documentation","title":"Raytracer.PerspectiveCamera","text":"struct PerspectiveCamera <: Camera\n\nA Camera implementing a perspective 3D → 2D projection.\n\nMembers\n\naspect_ratio::Float32: defines how larger than the height is the image (16/9, 4/3, ...).\ntransformation::Transformation: define the Transformation applied to the rays generated by the camera.\nscreen_distance::Float32: tells how much far from the eye of the observer is the screen and it influences the FOV (field-of-view).\n\nSee also: fire_ray(::PerspectiveCamera, ::Float32, ::Float32), aperture_deg\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.PerspectiveCamera-Tuple{Float32, Transformation, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.PerspectiveCamera","text":"PerspectiveCamera(aspect_ratio::Float32, transformation::Transformation, screen_distance::Float32)\n\nConstructor for an PerspectiveCamera instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.PerspectiveCamera-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.PerspectiveCamera","text":"PerspectiveCamera(; aspect_ratio::Float32 = 1f0,\n                    transformation::Transformation = Transformation(),\n                    screen_distance::Float32 = 1f0)\n\nKeyword-based constructor for a PerspectiveCamera instance.\n\nIf no parameter is specified, it return a camera with square aspect ratio, an identity transformation, and a screen distance of 1, giving a FOV of 90°.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.aperture_deg-Tuple{PerspectiveCamera}","page":"Raytracer.jl Documentation","title":"Raytracer.aperture_deg","text":"aperture_deg(camera::PerspectiveCamera)\n\nCompute the FOV of the camera in degrees for a PerspectiveCamera.\n\nExamples\n\nFOV for a camera with screen distance of 1 and aspect ratio of 1:\n\njulia> aperture_deg(PerspectiveCamera())\n90.0f0\n\nFOV for a camera with screen distance of 1 and aspect ratio of 16/9:\n\njulia> aperture_deg(PerspectiveCamera(aspect_ratio = 16//9))\n58.715508f0\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.fire_ray-Tuple{OrthogonalCamera, Float32, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.fire_ray","text":"fire_ray(camera::OrthogonalCamera, u::Float32, v::Float32)\n\nFire a Ray through an OrthogonalCamera at a position (u v) on the screen, using an orthogonal projection.\n\nParameters u and v are bound between 0 and 1:\n\n(0, 1)                            (1, 1)\n    +------------------------------+\n    |                              |\n    |                              |\n    |                              |\n    +------------------------------+\n(0, 0)                            (1, 0)\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.fire_ray-Tuple{PerspectiveCamera, Float32, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.fire_ray","text":"fire_ray(camera::PerspectiveCamera, u::Float32, v::Float32)\n\nFire a Ray through a PerspectiveCamera at a position (u v) on the screen, using a perspective projection.\n\nParameters u and v are bound between 0 and 1:\n\n(0, 1)                            (1, 1)\n    +------------------------------+\n    |                              |\n    |                              |\n    |                              |\n    +------------------------------+\n(0, 0)                            (1, 0)\n\n\n\n\n\n","category":"method"},{"location":"#Lights","page":"Raytracer.jl Documentation","title":"Lights","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"lights.jl\"]","category":"page"},{"location":"#Raytracer.Lights","page":"Raytracer.jl Documentation","title":"Raytracer.Lights","text":"Lights\n\nAlias of Vector{PointLight}, to store a list of PointLight sources.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.PointLight","page":"Raytracer.jl Documentation","title":"Raytracer.PointLight","text":"struct PointLight\n\nA point light (used by PointLightRenderer).\n\nThis type holds information about a point light.\n\nMembers\n\nposition::Point: a Point object holding the position of the point light in 3D space.\ncolor::RGB{Float32}: the color of the point light.\nlinear_radius::Float32: radius of the source, used to compute solid angle subtended by the light.\n\nIf linear_radius is non-zero, it is used to compute the solid angle subtended by the light at a given distance d through the formula:\n\nleft(fracmathrmlinear_radiusdright)^2\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.PointLight-Tuple{Point, RGB{Float32}, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.PointLight","text":"PointLight(position::Point, color::RGB{Float32}, linear_radius::Float32)\n\nConstructor for a PointLight instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.PointLight-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.PointLight","text":"PointLight(; position::Point = ORIGIN,\n             color::RGB{Float32} = WHITE,\n             linear_radius::Float32 = 0f0)\n\nConstructor for a PointLight instance.\n\nIf no parameter is specified, it return a white point light in the origin with no radius.\n\n\n\n\n\n","category":"method"},{"location":"#Material","page":"Raytracer.jl Documentation","title":"Material","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"materials.jl\"]","category":"page"},{"location":"#Raytracer.BRDF","page":"Raytracer.jl Documentation","title":"Raytracer.BRDF","text":"BRDF\n\nAn abstract type representing a Bidirectional Reflectance Distribution Function.\n\nSee also: DiffuseBRDF, SpecularBRDF,\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.CheckeredPigment","page":"Raytracer.jl Documentation","title":"Raytracer.CheckeredPigment","text":"struct CheckeredPigment{N} <: Pigment\n\nA checkered Pigment. The number of rows/columns in the checkered pattern is tunable with N, but you cannot have a different number of repetitions along the u/v directions.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.CheckeredPigment-2","page":"Raytracer.jl Documentation","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment(color_on::RGB{Float32} = WHITE, color_off::RGB{Float32} = BLACK)\n\nConstructor for a CheckeredPigment{2} instance.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.CheckeredPigment-Union{Tuple{RGB{Float32}, RGB{Float32}}, Tuple{N}} where N","page":"Raytracer.jl Documentation","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment{N}(color_on::RGB{Float32}, color_off::RGB{Float32}) where {N}\n\nConstructor for a CheckeredPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.CheckeredPigment-Union{Tuple{}, Tuple{N}} where N","page":"Raytracer.jl Documentation","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment{N}(; coloron::RGB{Float32} = WHITE,                       coloroff::RGB{Float32} = BLACK) where {N}\n\nConstructor for a CheckeredPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.DiffuseBRDF","page":"Raytracer.jl Documentation","title":"Raytracer.DiffuseBRDF","text":"struct DiffuseBRDF <: BRDF\n\nA class representing an ideal diffuse BRDF (also called \"Lambertian\").\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.DiffuseBRDF-Tuple{Pigment, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.DiffuseBRDF","text":"DiffuseBRDF(pigment::Pigment, reflectance::Float32)\n\nConstructor for a DiffuseBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.DiffuseBRDF-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.DiffuseBRDF","text":"DiffuseBRDF(; pigment::Pigment = UniformPigment(),\n              reflectance::Float32 = 1f0)\n\nConstructor for a DiffuseBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.ImagePigment","page":"Raytracer.jl Documentation","title":"Raytracer.ImagePigment","text":"struct ImagePigment <: Pigment\n\nA textured Pigment. The texture is given through a PFM image.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.ImagePigment-Tuple{Float32, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.ImagePigment","text":"(ip::ImagePigment)(u::Float32, v::Float32)\n\nReturn the color of the surface in the given point (uv).\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.ImagePigment-Tuple{HdrImage}","page":"Raytracer.jl Documentation","title":"Raytracer.ImagePigment","text":"ImagePigment(image::HdrImage)\n\nConstructor for a ImagePigment instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Material","page":"Raytracer.jl Documentation","title":"Raytracer.Material","text":"struct Material\n\nA material with a brdf::BRDF (BRDF) and and emitted_radiance::Pigment (Pigment).\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Material-Tuple{BRDF, Pigment}","page":"Raytracer.jl Documentation","title":"Raytracer.Material","text":"Material(brdf::BRDF, emitted_radiance::Pigment)\n\nConstructor for a Material instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Material-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.Material","text":"Material(; brdf::BRDF = DiffuseBRDF(), emitted_radiance::Pigment = UniformPigment(BLACK))\n\nConstructor for a Material instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Pigment","page":"Raytracer.jl Documentation","title":"Raytracer.Pigment","text":"Pigment\n\nThis abstract type represents a pigment, i.e., a function that associates a color with each point on a parametric surface (uv).\n\nEach subtype of this type must be a callable like (p::Pigment)(uv::Vec2D) and must return the color of the surface as a RGB{Float32} in a given Vec2D point.\n\nSee also: UniformPigment, CheckeredPigment, ImagePigment\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Pigment-Tuple{StaticArrays.SVector{2, Float32}}","page":"Raytracer.jl Documentation","title":"Raytracer.Pigment","text":"(p::Pigment)(uv::Vec2D)\n\nReturn the color of the surface in the given point Vec2D.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.SpecularBRDF","page":"Raytracer.jl Documentation","title":"Raytracer.SpecularBRDF","text":"struct SpecularBRDF <: BRDF\n\nA class representing an ideal mirror BRDF.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.SpecularBRDF-Tuple{Pigment, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.SpecularBRDF","text":"SpecularBRDF(pigment::Pigment, threshold_angle_rad::Float32)\n\nConstructor for a SpecularBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.SpecularBRDF-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.SpecularBRDF","text":"SpecularBRDF(; pigment::Pigment = UniformPigment(),\n               threshold_angle_rad::Float32 = π / 1800f0)\n\nConstructor for a SpecularBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.UniformPigment","page":"Raytracer.jl Documentation","title":"Raytracer.UniformPigment","text":"struct UniformPigment <: Pigment\n\nA uniform Pigment over the whole surface.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.UniformPigment-Tuple{Float32, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.UniformPigment","text":"(up::UniformPigment)(u::Float32, v::Float32)\n\nReturn the color of the surface in the given point (uv).\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.UniformPigment-Tuple{RGB{Float32}}","page":"Raytracer.jl Documentation","title":"Raytracer.UniformPigment","text":"UniformPigment(color::RGB{Float32})\n\nConstructor for a UniformPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.UniformPigment-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.UniformPigment","text":"UniformPigment(; color::RGB{Float32} = WHITE)\n\nConstructor for a UniformPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"#Base.Filesystem.cp-Union{Tuple{Float32, Float32}, Tuple{N}} where N","page":"Raytracer.jl Documentation","title":"Base.Filesystem.cp","text":"(cp::CheckeredPigment{N})(u::Float32, v::Float32) where {N}\n\nReturn the color of the surface in the given point (uv).\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.at-Tuple{DiffuseBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}","page":"Raytracer.jl Documentation","title":"Raytracer.at","text":"at(brdf::DiffuseBRDF, normal::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D)\n\nGet the radiance, given a point uv (Vec2D) on the surface with a DiffuseBRDF., an incoming direction in_dir and outcoming direction (Vec), a normal of the surface point (Normal).\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.at-Tuple{SpecularBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}","page":"Raytracer.jl Documentation","title":"Raytracer.at","text":"at(brdf::SpecularBRDF, normal::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D)\n\nGet the radiance, given a point uv (Vec2D) on the surface with a SpecularBRDF., an incoming direction in_dir and outcoming direction (Vec), a normal of the surface point (Normal).\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.scatter_ray-Tuple{DiffuseBRDF, PCG, Vec, Point, Normal, Int64}","page":"Raytracer.jl Documentation","title":"Raytracer.scatter_ray","text":"scatter_ray(::DiffuseBRDF, pcg::PCG, incoming_dir::Vec, interaction_point::Point, normal::Normal, depth::Int)\n\nScatter a ray on the surface.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.scatter_ray-Tuple{SpecularBRDF, PCG, Vec, Point, Normal, Int64}","page":"Raytracer.jl Documentation","title":"Raytracer.scatter_ray","text":"scatter_ray(::SpecularBRDF, pcg::PCG, incoming_dir::Vec, interaction_point::Point, normal::Normal, depth::Int)\n\nScatter a ray on the surface.\n\n\n\n\n\n","category":"method"},{"location":"#Shapes","page":"Raytracer.jl Documentation","title":"Shapes","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"shapes.jl\"]","category":"page"},{"location":"#Raytracer.AABB","page":"Raytracer.jl Documentation","title":"Raytracer.AABB","text":"struct AABB\n\nA type representing an Axis-Aligned Bounding Box\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Plane","page":"Raytracer.jl Documentation","title":"Raytracer.Plane","text":"struct Plane <: Shape\n\nA type representing an infinite plane.\n\nMembers\n\ntransformation::Transformation: the Transformation associated with the plane.\nmaterial::Material: the Material of the spere.\n\nSee also: ray_intersection(::Ray, ::Plane)\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Plane-Tuple{Transformation, Material}","page":"Raytracer.jl Documentation","title":"Raytracer.Plane","text":"Plane(transformation::Transformation, material::Material)\n\nConstructor for a Plane instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Plane-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.Plane","text":"Plane(transformation::Transformation = Transformation(),\n       material::Material = Material())\n\nConstructor for a Plane instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Shape","page":"Raytracer.jl Documentation","title":"Raytracer.Shape","text":"Shape\n\nAn abstract type representing a shape.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Sphere","page":"Raytracer.jl Documentation","title":"Raytracer.Sphere","text":"struct Sphere <: Shape\n\nA type representing a sphere.\n\nThis is a unitary sphere centered in the origin. A generic sphere can be specified by applying a Transformation.\n\nMembers\n\ntransformation::Transformation: the Transformation associated with the sphere.\nmaterial::Material: the Material of the spere.\n\nSee also: ray_intersection(::Ray, ::Sphere)\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.Sphere-Tuple{Transformation, Material}","page":"Raytracer.jl Documentation","title":"Raytracer.Sphere","text":"Sphere(transformation::Transformation, material::Material)\n\nConstructor for a Sphere instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Sphere-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.Sphere","text":"Sphere(transformation::Transformation = Transformation(),\n       material::Material = Material())\n\nConstructor for a Sphere instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.quick_ray_intersection-Tuple{Ray, Plane}","page":"Raytracer.jl Documentation","title":"Raytracer.quick_ray_intersection","text":"quick_ray_intersection(ray::Ray, s::Plane)\n\nTells if a Ray intersect a Plane or not.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.quick_ray_intersection-Tuple{Ray, Sphere}","page":"Raytracer.jl Documentation","title":"Raytracer.quick_ray_intersection","text":"quick_ray_intersection(ray::Ray, s::Sphere)\n\nTells if a Ray intersect a Sphere or not.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.ray_intersection-Tuple{Ray, Plane}","page":"Raytracer.jl Documentation","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, s::Plane)\n\nReturn an HitRecord of the nearest ray intersection with the given Plane.\n\nIf none exists, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.ray_intersection-Tuple{Ray, Raytracer.AABB}","page":"Raytracer.jl Documentation","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, aabb::AABB)\n\nReturn the parameter t at which Ray first hits the AABB. If no hit exists, return Inf32.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.ray_intersection-Tuple{Ray, Sphere}","page":"Raytracer.jl Documentation","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, s::Sphere)\n\nReturn an HitRecord of the nearest ray intersection with the given Sphere.\n\nIf none exists, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"#World","page":"Raytracer.jl Documentation","title":"World","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"world.jl\"]","category":"page"},{"location":"#Raytracer.World","page":"Raytracer.jl Documentation","title":"Raytracer.World","text":"World\n\nAlias of Vector{Shape}, to store a list of Shape.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.is_point_visible-Tuple{Vector{Shape}, Point, Point}","page":"Raytracer.jl Documentation","title":"Raytracer.is_point_visible","text":"is_point_visible(world::World, point::Point, observer_pos::Point)\n\nTells if a particular Point in a World filled with Shape is visible from the observer position.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.ray_intersection-Tuple{Ray, Vector{Shape}}","page":"Raytracer.jl Documentation","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, world::World)\n\nIntersect a Ray with each Shape in World and return the nearest hit point.\n\n\n\n\n\n","category":"method"},{"location":"#HitRecord","page":"Raytracer.jl Documentation","title":"HitRecord","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"hitrecord.jl\"]","category":"page"},{"location":"#Raytracer.HitRecord","page":"Raytracer.jl Documentation","title":"Raytracer.HitRecord","text":"struct HitRecord\n\nA struct representing the result of an intersection between a Ray and a Shape.\n\nMembers\n\nworld_point::Point: a Point representing the world coordinates of the hit point.\nnormal::Normal: a Normal representing the orientation of the normal to the surface where the hit happened.\nsurface_point::Vec2D: a Vec2D representing the position of the hit point on the surface of the object.\nt::Float32: distance from the origin of the ray where the hit happened.\nray::Ray: a Ray representing the the ray that hit the surface.\nmaterial::Material: a Material representing the material of the point where the hit happened.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:≈-Tuple{HitRecord, HitRecord}","page":"Raytracer.jl Documentation","title":"Base.:≈","text":"≈(hr1::HitRecord, hr2::HitRecord)\n\nCheck if two HitRecord represent the same hit event or not.\n\n\n\n\n\n","category":"method"},{"location":"#Rendering","page":"Raytracer.jl Documentation","title":"Rendering","text":"","category":"section"},{"location":"#PCG","page":"Raytracer.jl Documentation","title":"PCG","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"pcg.jl\"]","category":"page"},{"location":"#Raytracer.PCG","page":"Raytracer.jl Documentation","title":"Raytracer.PCG","text":"mutable struct PCG <: AbstractRNG\n\nRandom number generator that implement the Permuted Congruential Generator, a simple fast space-efficient statistically good algorithms for random number generation. See O'Neill (2014).\n\nMembers\n\nstate::UInt64: the state of the generator.\ninc::UInt64: sequence identifier.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.PCG-Tuple{UInt64, UInt64}","page":"Raytracer.jl Documentation","title":"Raytracer.PCG","text":"PCG(state::UInt64 = UInt64(42), inc::UInt64 = UInt64(54))\n\nConstructor for a PCG instance.\n\nIf no parameter is specified, the generated instance will have a state of 42 and a sequence identifier of 54.\n\n\n\n\n\n","category":"method"},{"location":"#Renderer","page":"Raytracer.jl Documentation","title":"Renderer","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"renderers.jl\"]","category":"page"},{"location":"#Raytracer.FlatRenderer","page":"Raytracer.jl Documentation","title":"Raytracer.FlatRenderer","text":"struct FlatRenderer <: Renderer\n\nA basic renderer that returns the color of the Shape first hit by a given Ray.\n\nThis renderer returns the color stored in the material field of the Shape first hit by the given Ray at the hit point. To this renderer there is no difference between radiated light and reflected color. There are no shades, diffusions or reflections. If there are no hits this renderer returns the value of its field background_color.\n\nMembers\n\nworld::World: the World to render.\nbackground_color::RGB{Float32}: color if the ray do not collide.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.FlatRenderer-Tuple{Ray}","page":"Raytracer.jl Documentation","title":"Raytracer.FlatRenderer","text":"(oor::FlatRenderer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.FlatRenderer-Tuple{Vector{Shape}, RGB{Float32}}","page":"Raytracer.jl Documentation","title":"Raytracer.FlatRenderer","text":"FlatRenderer(world::World, background_color::RGB{Float32})\n\nConstructor for a FlatRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.FlatRenderer-Tuple{Vector{Shape}}","page":"Raytracer.jl Documentation","title":"Raytracer.FlatRenderer","text":"FlatRenderer(world::World; background_color::RGB{Float32} = BLACK)\n\nConstructor for a FlatRenderer instance.\n\nIf no color is specified, it will default on BLACK.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.OnOffRenderer","page":"Raytracer.jl Documentation","title":"Raytracer.OnOffRenderer","text":"struct OnOffRenderer <: Renderer\n\nA basic bichrome renderer that checks whether a Ray has collided or not.\n\nThis renderer returns its field off_color when the given Ray is nothing, else it returns its field on_color.\n\nMembers\n\nworld::World: the World to render.\non_color::RGB{Float32}: color if the ray collide.\noff_color::RGB{Float32}: color if the ray do not collide.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.OnOffRenderer-Tuple{Ray}","page":"Raytracer.jl Documentation","title":"Raytracer.OnOffRenderer","text":"(oor::OnOffRenderer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.OnOffRenderer-Tuple{Vector{Shape}, RGB{Float32}, RGB{Float32}}","page":"Raytracer.jl Documentation","title":"Raytracer.OnOffRenderer","text":"OnOffRenderer(world::World, on_color::RGB{Float32}, off_color::RGB{Float32})\n\nConstructor for a OnOffRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.OnOffRenderer-Tuple{Vector{Shape}}","page":"Raytracer.jl Documentation","title":"Raytracer.OnOffRenderer","text":"OnOffRenderer(world::World\n              ; on_color::RGB{Float32} = WHITE,\n                off_color::RGB{Float32} = BLACK)\n\nConstructor for a OnOffRenderer instance.\n\nIf no color is specified, it will default on WHITE and BLACK.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.PathTracer","page":"Raytracer.jl Documentation","title":"Raytracer.PathTracer","text":"struct PathTracer <: Renderer\n\nA path-tracing algorithm that considers the optical path of a Ray from the observer to a light source.\n\nMembers\n\nworld::World: the World to render.\nbackground_color::RGB{Float32}: color if the ray do not collide.\nrng::PCG: a PCG random number generator to appropriately scatter rays.\nn::Int: how many scattered rays should be generated for the mc integration.\nmax_depth::Int: the maximum number of scatters a ray should be subjected to before stopping.\nroulette_depth::Int: the depth at which the russian roulette algorithm should start (if > 'max_depth` then it will never start).\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.PathTracer-Tuple{Ray}","page":"Raytracer.jl Documentation","title":"Raytracer.PathTracer","text":"(oor::PathTracer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.PathTracer-Tuple{Vector{Shape}, RGB{Float32}, PCG, Int64, Int64, Int64}","page":"Raytracer.jl Documentation","title":"Raytracer.PathTracer","text":"PathTracer(world::World, background_color::RGB{Float32}, rng::PCG, n::Int, max_depth::Int, roulette_depth::Int)\n\nConstructor for a PathTracer instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.PathTracer-Tuple{Vector{Shape}}","page":"Raytracer.jl Documentation","title":"Raytracer.PathTracer","text":"PathTracer(world::World\n           ; background_color::RGB{Float32} = BLACK,\n             rng::PCG = PCG(),\n             n::Int = 10,\n             max_depth::Int = 2,\n             roulette_depth::Int = 3)\n\nConstructor for a PathTracer instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.PointLightRenderer","page":"Raytracer.jl Documentation","title":"Raytracer.PointLightRenderer","text":"struct PointLightRenderer <: Renderer\n\nThis renderer is similar to what POV-Ray provides by default.\n\nMembers\n\nworld::World: the World to render.\nlights::Lights: a Lights instance that contain a list of lights.\nbackground_color::RGB{Float32}: color if the ray do not collide.\nambient_color::RGB{Float32}: the ambient color of the scene.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.PointLightRenderer-Tuple{Ray}","page":"Raytracer.jl Documentation","title":"Raytracer.PointLightRenderer","text":"(oor::PointLightRenderer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}, RGB{Float32}, RGB{Float32}}","page":"Raytracer.jl Documentation","title":"Raytracer.PointLightRenderer","text":"PointLightRenderer(world::World, lights::Lights, background_color::RGB{Float32}, ambient_color::RGB{Float32})\n\nConstructor for a PointLightRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}}","page":"Raytracer.jl Documentation","title":"Raytracer.PointLightRenderer","text":"PointLightRenderer(world::World, lights::Lights\n                   ; background_color::RGB{Float32} = BLACK,\n                     ambient_color::RGB{Float32} = WHITE * 1f-3)\n\nConstructor for a PointLightRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.Renderer","page":"Raytracer.jl Documentation","title":"Raytracer.Renderer","text":"Renderer\n\nAbstract type for functors that map Ray to RGB{Float32}.\n\nEach subtype of this type must be a callable like (r::Renderer)(ray::Ray) and must return a RGB{Float32}. Each subtype of this type sould have a member of type World to check for intersections of the given Ray.\n\n\n\n\n\n","category":"type"},{"location":"#Image-tracer","page":"Raytracer.jl Documentation","title":"Image tracer","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"imagetracer.jl\"]","category":"page"},{"location":"#Raytracer.ImageTracer","page":"Raytracer.jl Documentation","title":"Raytracer.ImageTracer","text":"struct ImageTracer\n\nTrace an image by shooting light rays through each of its pixels.\n\nTo fill an image store it into ImageTracer along with the desired camera and apply fire_all_rays! to it. Alternatively apply iteratively fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32) on the desired ranges.\n\nMembers\n\nimage::HdrImage: a HdrImage in which save the rendered image.\ncamera::Camera: a Camera holding the observer informations.\nsamples_per_side::Int: the number of samples per side of a pixel for antialiasing algorithm.\nrng::PCG: a PCG random number generator for antialiasing algorithm.\n\nIf samples_per_side is larger than zero, antialiasing will be applied to each pixel in the image, using the random number generator rng.\n\n\n\n\n\n","category":"type"},{"location":"#Raytracer.ImageTracer-Tuple{HdrImage, Camera, Int64, PCG}","page":"Raytracer.jl Documentation","title":"Raytracer.ImageTracer","text":"ImageTracer(image::HdrImage, camera::Camera, samples_per_side::Int, rng::PCG)\n\nConstructor for an ImageTracer instance.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.ImageTracer-Tuple{HdrImage, Camera}","page":"Raytracer.jl Documentation","title":"Raytracer.ImageTracer","text":"ImageTracer(image::HdrImage, camera::Camera\n            ; samples_per_side::Int = 0,\n              rng::PCG = PCG())\n\nConstruct a ImageTracer.\n\nIf samples_per_side is not specified, antialiasing will be disabled and rng is ignored.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.fire_all_rays!-Tuple{ImageTracer, Renderer}","page":"Raytracer.jl Documentation","title":"Raytracer.fire_all_rays!","text":"fire_all_rays!(tracer::ImageTracer, renderer::Renderer\n               ; use_threads::Bool = true,\n                 enable_progress_bar::Bool = true)\n\nRender an image with informations stored in an ImageTracer using the specified Renderer.\n\nThis function apply iteratively fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32) for each pixel in the image contained in tracer using its camera, and then render the point using renderer.\n\nIf use_threads is true, the function will use the Threads.@threads macro to parallelize the computation.\n\nIf enable_progress_bar is true, the function will display a progress bar during the computation; this is thread safe.\n\nSee also: fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32)\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.fire_ray-Tuple{ImageTracer, Int64, Int64}","page":"Raytracer.jl Documentation","title":"Raytracer.fire_ray","text":"fire_ray(tracer::ImageTracer, col::Int, row::Int\n         ; u_pixel::Float32 = 0.5f0,\n           v_pixel::Float32 = 0.5f0)\n\nShoot a Ray through the pixel (col, row) of the image contained in an [ImageTracer], using its camera informations.\n\nThe function use the fire_ray function of the associated camera (fire_ray(::OrthogonalCamera, ::Float32, ::Float32),     fire_ray(::PerspectiveCamera, ::Float32, ::Float32))\n\nThe parameters col and row are measured in the same way as they are in HdrImage: the bottom left corner is placed at (0 0). The values of u_pixel and v_pixel are floating-point numbers in the range 0 1: they specify where the ray should cross the pixel; passing 0.5 to both means that the ray will pass through the pixel's center.\n\nSee also: fire_all_rays!\n\n\n\n\n\n","category":"method"},{"location":"#User-utilities","page":"Raytracer.jl Documentation","title":"User utilities","text":"","category":"section"},{"location":"","page":"Raytracer.jl Documentation","title":"Raytracer.jl Documentation","text":"Modules = [Raytracer]\nPages   = [\"user_utils.jl\"]","category":"page"},{"location":"#Raytracer.demo-Tuple{}","page":"Raytracer.jl Documentation","title":"Raytracer.demo","text":"demo(;output_file::String = \"demo.jpg\",\n      camera_type::Type{<:Camera} = PerspectiveCamera,\n      camera_position::Tuple{Float32, Float32, Float32} = (-3f0, 0f0, 0f0),\n      camera_orientation::Tuple{Float32, Float32, Float32} = (0f0, 0f0, 0f0),\n      screen_distance::Float32 = 2f0,\n      image_resolution::Tuple{Int, Int} = (540,540),\n      samples_per_side::Int = 0,\n      renderer_type::Type{<:Renderer} = PathTracer,\n      pt_n::Int = 10,\n      pt_max_depth::Int = 2,\n      pt_roulette_depth::Int = 3,\n      α::Float32 = 0.75f0,\n      γ::Float32 = 1f0,\n      use_threads::Bool = true,\n      disable_output::Bool = false)\n\nCreate a demo image.\n\nArguments\n\noutput_file: output LDR file name (the HDR file will have the same name, but with \"pfm\" extension).\ncamera_type: choose camera type (\"perspective\" or \"orthogonal\").\ncamera_position: camera position in the scene as \"X,Y,Z\".\ncamera_orientation: camera orientation as \"angX,angY,angZ\".\nscreen_distance: only for \"perspective\" camera: distance between camera and screen.\nimage_resolution: resolution of the rendered image.\nrenderer_type: type of renderer to use (\"onoff\", \"flat\" or \"path\").\nsamples_per_side: number of samples per pixel (must be a perfect square).\npt_n: number of rays fired for mc integration (path-tracer only).\npt_max_depth: maximum number of reflections for each ray (path-tracer only).\npt_roulette_depth: depth of the russian-roulette algorithm (path-tracer only).\nα: scaling factor for the normalization process.\nγ: gamma value for the tone mapping process.\nuse_threads: use macro Threads.@threads.\ndisable_output: if true, no message is printed.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.demo_load_scene-Tuple{Type{var\"#s39\"} where var\"#s39\"<:Renderer, Int64, Int64, Int64}","page":"Raytracer.jl Documentation","title":"Raytracer.demo_load_scene","text":"demo_load_scene(renderer_type::Type{<:Renderer},\n                pt_n::Int,\n                pt_max_depth::Int,\n                pt_roulette_depth::Int)\n\nPrivate function to create a renderer for the demo function.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.demo_load_tracer-Tuple{Tuple{Int64, Int64}, Type{var\"#s4\"} where var\"#s4\"<:Camera, Tuple{Float32, Float32, Float32}, Tuple{Float32, Float32, Float32}, Float32, Int64}","page":"Raytracer.jl Documentation","title":"Raytracer.demo_load_tracer","text":"demo_load_tracer(image_resolution::Tuple{Int, Int},\n                 camera_type::Type{<:Camera},\n                 camera_position::Tuple{Float32, Float32, Float32},\n                 camera_orientation::Tuple{Float32, Float32, Float32},\n                 screen_distance::Float32,\n                 samples_per_side::Int\n                 ; disable_output::Bool = false)\n\nPrivate function to create a tracer for the demo function.\n\n\n\n\n\n","category":"method"},{"location":"#Raytracer.tonemapping-Tuple{String, String, Float32, Float32}","page":"Raytracer.jl Documentation","title":"Raytracer.tonemapping","text":"tonemapping(input_file::String,\n            output_file::String,\n            α::Float32,\n            γ::Float32\n            ; disable_output::Bool = false)\n\nLoad a pfm hdr image, apply the tone mapping, and save the generated ldr image.\n\ninput_file is the path to a valid PFM image. output_file is the path in which save the generated image + the name of the output file. The output format is deduced by the extension of the output file: if the name is example.jpg, the image will be exported in JPEG format. α is the normalization coefficient. γ is the actor of the γ correction.\n\nIf disable_output is true, no message is printed.\n\n\n\n\n\n","category":"method"}]
}
