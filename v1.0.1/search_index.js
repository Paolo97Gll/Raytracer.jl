var documenterSearchIndex = {"docs":
[{"location":"quickstart/cli/#Basic-CLI-tool-usage","page":"Basic CLI usage","title":"Basic CLI tool usage","text":"","category":"section"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"The CLI tool is named raytracer_cli.jl and is placed in the root of the repository.","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"The usage is based on a series of commands, in a similar way to the git and docker CLI tools:","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"julia raytracer_cli.jl {command} [{subcommand}] [options]","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"To apply the tone mapping process to a pfm image you can use:","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"julia raytracer_cli.jl tonemapping input-file.pfm output-file.<ldr-extension> [options]","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"where ldr-extension indicates the desired output format. Most LDR formats are supported (see tonemapping).","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"The command render admits a set of subcommands that specify the type of rendering (image or animation). You need to specify a SceneLang input script.","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"julia raytracer_cli.jl render image input-script.sl [options]","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"julia raytracer_cli.jl render animation input-script.sl [animation parameters] [options]","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"More informations and examples here.","category":"page"},{"location":"extendability/#extendability","page":"Extendability","title":"Extendability","text":"","category":"section"},{"location":"extendability/#Contents","page":"Extendability","title":"Contents","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"Pages = [\"extendability.md\"]","category":"page"},{"location":"extendability/#Description","page":"Extendability","title":"Description","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"Raytracer is designed to be easily extensible in terms of renderers, pigments, BRDFs, and shapes. To extend the package, one must follow the following guidelines.","category":"page"},{"location":"extendability/#Renderers","page":"Extendability","title":"Renderers","text":"","category":"section"},{"location":"extendability/#Needed-fields","page":"Extendability","title":"Needed fields","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"No fields are strictly needed, but it is suggested to have a World field, named world for code consistency, in which to store the shapes to be rendered. It is also common to store a background color that deals with rays which do not hit any shape.","category":"page"},{"location":"extendability/#Needed-methods","page":"Extendability","title":"Needed methods","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"Each subtype of Renderer must be a callable like (r::Renderer)(ray::Ray) and must return a RGB{Float32}.","category":"page"},{"location":"extendability/#Further-notes","page":"Extendability","title":"Further notes","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"See doc and source code for Renderer.","category":"page"},{"location":"extendability/#Pigments","page":"Extendability","title":"Pigments","text":"","category":"section"},{"location":"extendability/#Needed-fields-2","page":"Extendability","title":"Needed fields","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"No fields are needed.","category":"page"},{"location":"extendability/#Needed-methods-2","page":"Extendability","title":"Needed methods","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"Each subtype of Pigment must be a callable like (p::Pigment)(uv::Vec2D) and must return a RGB{Float32}.","category":"page"},{"location":"extendability/#Further-notes-2","page":"Extendability","title":"Further notes","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"See doc and souce code for Pigment.","category":"page"},{"location":"extendability/#BRDFs","page":"Extendability","title":"BRDFs","text":"","category":"section"},{"location":"extendability/#Needed-fields-3","page":"Extendability","title":"Needed fields","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"pigment::Pigment: a Pigment storing the pigment on which the BRDF operates. It is suggested that this field should have a default value (most BRDFs use the default UniformPigment).","category":"page"},{"location":"extendability/#Needed-methods-3","page":"Extendability","title":"Needed methods","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"Each subtype of BRDF must implement an at(::NewBRDF, ::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D) function, where NewBRDF should be swubstituted with your new type name. This function evaluates the BRDF of a point with given normal, input and output directions and uv coordinates (which are used to evaluate).","category":"page"},{"location":"extendability/#Further-notes-3","page":"Extendability","title":"Further notes","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"See doc and souce code for BRDF.","category":"page"},{"location":"extendability/#Shapes","page":"Extendability","title":"Shapes","text":"","category":"section"},{"location":"extendability/#Needed-fields-4","page":"Extendability","title":"Needed fields","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"material::Material: a Material storing the informations on the material of the shape.\ntransformation::Transformation: a Transformation is the transformation that should be applied to every point of the unitary shape associated with the type (e.g., a sphere of radius one for the Sphere shape) to be transformed in the desired shape.","category":"page"},{"location":"extendability/#Needed-methods-4","page":"Extendability","title":"Needed methods","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"ray_intersection(::Ray, ::NewShape): return an HitRecord of the nearest ray intersection with the given Shape.\nall_ray_intersections(::Ray, ::NewShape): return a Vector of HitRecords of all the ray intersections with the given Shape for every finite value of t, even outside of the ray domain.\nquick_ray_intersection(::Ray, ::NewShape): return whether the ray intersects the given Shape.\nget_all_ts(::NewShape, ::Ray): return a Vector of the hit parameter t against the given Shape, even outside of the ray domain.","category":"page"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"Furthermore, if you want to make your NewShape a subtype of SimpleShape you should also implement the following methods:","category":"page"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"get_t(::Type{NewShape}, ::Ray): return the parameter t at which Ray first hits the unitary SimpleShape. If no hit exists, return Inf32.\nget_all_ts(::Type{NewShape}, ::Ray): return a Vector of the hit parameter t against the unitary shape of the given SimpleShape type, even outside of the ray domain.\nget_normal(::Type{NewShape}, ::Point, ::Ray): return the Normal{true} of a shape given a point on its surface and the ray that hits it.\nget_uv(::Type{NewShape}, ::Point): return the uv coordinates of a shape associated with the given point on its surface.","category":"page"},{"location":"extendability/#Further-notes-4","page":"Extendability","title":"Further notes","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"We suggest to implement any new composite shape as a subtype to CompositeShape instead of directly subtyping Shape.","category":"page"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"See documentation and source code of Shape, SimpleShape, and CompositeShape.","category":"page"},{"location":"extendability/#Examples-of-extendability","page":"Extendability","title":"Examples of extendability","text":"","category":"section"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"Take a look to the examples folder in the repository to see an example (see examples\\extendability\\renderers), also reported below here.","category":"page"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"using Raytracer\nusing Raytracer.Interpreter\n\n\"\"\"\n    FoggyRenderer <: Renderer\n\nA `Renderer` that returns the color of the `Shape` first hit by a given `Ray` mixed with the fog_color depending on distance travelled.\n\nThis renderer returns the color stored in the `material` field of the `Shape` first hit by the given `Ray` at the hit point.\nTo this renderer there is no difference between radiated light and reflected color. There are no shades, diffusions or reflections.\nThe color is then mixed with the `fog color` using the formula\n``(1-\\\\exp{-t/λ}) fog_color + \\\\exp{-t/λ} hit_color``\nwhere `t` is the distance to the hit point and `λ` is the luminosity falloff.\nIf there are no hits this renderer returns the value of its field `fog_color`.\n\n# Fields\n\n- `world::World`: the `World` to render.\n- `fog_color::RGB{Float32}`: color of the fog.\n- `falloff::Float32`: color falloff\n\"\"\"\nstruct FoggyRenderer <: Renderer\n    world::World\n    fog_color::RGB{Float32}\n    falloff::Float32\nend\n\n@doc \"\"\"\n    FoggyRenderer(world::World, fog_color::RGB{Float32}, falloff::Float32)\n\nConstructor for a `FoggyRenderer` instance.\n\"\"\" FoggyRenderer(::World, ::RGB{Float32}, ::Float32)\n\n\"\"\"\n    FoggyRenderer(world::World; fog_color::RGB{Float32} = BLACK, falloff::Float32 = 1f0)\n\nConstructor for a `FoggyRenderer` instance.\n\nIf no color is specified, it will default on [`BLACK`](@ref).\n\"\"\"\nFoggyRenderer(world::World; fog_color::RGB{Float32} = BLACK, falloff::Float32 = 1f0) = FlatRenderer(world, fog_color, falloff)\n\n\"\"\"\n    (oor::FoggyRenderer)(ray::Ray)\n\nRender a `Ray` and return a `RBG{Float32}`.\n\"\"\"\nfunction (fr::FoggyRenderer)(ray::Ray)\n    hit = ray_intersection(ray, fr.world)\n    isnothing(hit) && return fr.fog_color\n    hit_color = hit.material.emitted_radiance(hit.surface_point) + hit.material.brdf.pigment(hit.surface_point)\n    t = hit.t/fr.falloff\n    fr.fog_color * (1 - exp(-t)) + hit_color * exp(-t)\nend\n\nscene = open_stream(parse_scene, \"test_scene.sl\")\n\nimage_tracer = ImageTracer(scene.image, scene.camera; scene.tracer.kwargs...)\nrenderer = FoggyRenderer(scene.world, WHITE, 10f0)\nrender(image_tracer, renderer, output_file=\"foggy_renderer_out.pfm\")\ntonemapping(\"foggy_renderer_out.pfm\", \"foggy_renderer_out.jpg\", luminosity = 0.5f0)","category":"page"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"Which outputs the following image:","category":"page"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"(Image: )","category":"page"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"As you can see, to extend the package one only needs to implement the required subtypes and methods. This is called \"type piracy\" and is a powerful feature of Julia.","category":"page"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"We provided the basic instructions for rendering use, but made so that it is easy for anyone knowing the basics of Julia to build upon these fundations according to their needs.","category":"page"},{"location":"extendability/","page":"Extendability","title":"Extendability","text":"Detailed instructions on how to implement new simple and composite shapes are also written in the src/shapes.jl file.","category":"page"},{"location":"scenelang/#scenelang","page":"SceneLang","title":"SceneLang","text":"","category":"section"},{"location":"scenelang/#Contents","page":"SceneLang","title":"Contents","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Pages = [\"scenelang.md\"]\nDepth = 5","category":"page"},{"location":"scenelang/#Description","page":"SceneLang","title":"Description","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"SceneLang is a Domain-Specific Language (DSL) used to describe a 3D scene that can be rendered by Raytracer.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Being a DSL, SceneLang lacks some of the basic features of general purpose languages: there are no functions or custom types or even flexible arithmetic operations. SceneLang is made only to construct scenes to be rendered.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"To render the content of a scenelang script just invoke the cli tool command:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"julia raytracer_cli.jl render myscript.sl","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"where .sl is the suffix for a SceneLang script.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Each SceneLang script is parsed through the interpreter present in module Raytracer.Interpreter, which interprets the script by first interpreting the stream of charachters associated with the script as a list of token and then evaluating how these tokens relate to each other as a syntax.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Let's start by looking at what tokens are in a SceneLang script.","category":"page"},{"location":"scenelang/#scenelang_script_tokenization","page":"SceneLang","title":"Script tokenization","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"In a SceneLang script there are mainly five classes of tokens:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Commands\nTypes\nKeywords\nIdentifiers\nLiterals","category":"page"},{"location":"scenelang/#scenelang_token_commands","page":"SceneLang","title":"Commands","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Commands are all-uppercase words. Their role is to indicate that an action will be performed on arguments that follow.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"warning: Warning\nCommands are a finite group of predetermined words, therefore the lexer throws an exception when it finds an all-uppercase word that is not a listed command.","category":"page"},{"location":"scenelang/#Examples","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"SET  # valid command token\nDROP # invalid command token, not in list\nSet  # not a command token, lowercase letters are present in the word","category":"page"},{"location":"scenelang/#scenelang_token_types","page":"SceneLang","title":"Types","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Types are words starting with an uppercase letter and at least one lowercase letter in the rest of the word. Their role is to specify the type of a value when it is constructed.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"warning: Warning\nTypes, as commands, are a finite group of predetermined words, therefore the lexer throws an exception when it finds an uppercase-starting word that is not a listed type.","category":"page"},{"location":"scenelang/#Examples-2","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Pigment  # valid type token\nPIgment  # invalid type token, not in list\npigment  # not a type token, first letter not uppercase","category":"page"},{"location":"scenelang/#scenelang_token_keywords","page":"SceneLang","title":"Keywords","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Keywords are words preceded by a dot (.) marker. They are used either as a specifier to a type or command or as an attribute name when constructing a value.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"warning: Warning\nKeywords are not a global scope defined list of names, but they have meaning only in certain semantic contexts, but the lexer is unaware of this so any word following a dot will be marked as a keyword even if it is syntactically invalid.","category":"page"},{"location":"scenelang/#Examples-3","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":".Uniform         # valid keyword token\n.transformation  # valid keyword token, there is no rule on capitalization\ntransformation   # not a keyword token, word not preceded by a dot","category":"page"},{"location":"scenelang/#scenelang_token_identifiers","page":"SceneLang","title":"Identifiers","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Identifiers are words, starting with a lowercase letter, that are intended to be paired with an instance of a type and can be used in place of that value.","category":"page"},{"location":"scenelang/#Examples-4","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"identifier        # valid identifier token\n_IDENTIFIER       # valid identifier token, no capitalization rule after the first letter\na_long_identifier # valid identifier token in snake case\nNot_an_identifier # not an identifier, first letter must be lowercase or an underscore","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"tip: Tip\nFor ease of visual parsability we suggest to avoid the second style above and to prefer snake case for long identifiers and keep everything lowercase.","category":"page"},{"location":"scenelang/#scenelang_token_literals","page":"SceneLang","title":"Literals","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Literals are every other token in the script: numbers, strings, and mathematical expressions.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"6                      # this is a LiteralNumber token\n\"this is a string\"     # this is a LiteralString token\n$ 1 + 2id ^ 4 - 1e-2 $ # this is a MathExpression token","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"MathExpression tokens are a peculiar feature of SceneLang and will be explored deeper in its own chapter.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure","page":"SceneLang","title":"Syntax structure","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"The syntax of SceneLang is composed of only three entities:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Variables\nConstructors\nInstructions","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_variables","page":"SceneLang","title":"Variables","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Variables in SceneLang are composed only of an identifier token, so the two terms could be used interchangeably, since the difference stands only in the fact that \"variables\" is their name when analyzing the syntax while \"identifiers\" is when talking about lexicon.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"The value stored into a variable cannot be altered or copied into other variables. Values only serve to label a particular instance of an object construted at variable set-up and stored in a dictionary. They behave exactly as if that object were contructed in-place. The only places where a varible is explicitly requested to be is when they are set up and when they are destroyed. In all other instances they could be as substituted with appropriate constructors, at the cost of readability and time to parse the script.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors","page":"SceneLang","title":"Constructors","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Constructors are a syntactical construct that constructs an object into memory.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"There are three types of constructors symbolical constructors, named constructors, and command constructors.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Symbolical constructors determine the output type by the symbols present around the arguments, while named constructors have the arguments surrounded by parenthesis an preceded by the type name (and sometimes a type specificator keyword).","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"<1, 0, 0>      # a symbolic constructor for a color\nColor(1, 0, 0) # the same color but in a named constructor form","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Named constructors have an additional characteristic: they can have default values and can take keyword arguments:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Color(1)       # the same color as in the previous example but the second\n               # and third arguments are defaulted to 0\nColor(.R 1)    # as above but with a keyword argument","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"tip: Tip\nKeyword arguments may seem verbose at first but come in very handy both when trying to understand what the code is doing and when one wants to list arguments in a different order than standard.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"warning: Warning\nMixed positional and keyword argument types are allowed as long as the positional arguments precede the keyword ones and as long as the keyword arguments do not redefine positional arguments:Color(1, .B 0.5, .G 0.75) # valid mixed argument constructor\nColor(.R 1, 0.75, 0.5)    # throws InvalidKeyword exception: positional after keyword\nColor(1, .R 0.5)          # throws InvalidKeyword exception: keyword tries to redefine\n                          # the first positional argument","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Command constructors exist either to make the code more readable and/or to simplify notation. They are composed of a command and one or more arguments. If more than one argument may be required these must be surrounded by curved parenthesis. A clear example are the commands to create rotation matrices without requiring the user to manually type the transformation matrix.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"For example the following two constructors return the same transformation:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Transformation([1.0,  0.0,        0.0,       0.0,\n                0.0,  0.707107,  -0.707107,  0.0,\n                0.0,  0.707107,   0.707107,  0.0,\n                0.0,  0.0,        0.0,       1.0])\nROTATE(.X 45)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Numbers and strings can be considered primitive types and thus require a dedicated tokenization. Therefore a named or command constructor for them would be needlessy redundant and verbose as their constructor would take only one argument of the same type of the one produced and there is no risk of ambiguity.","category":"page"},{"location":"scenelang/#Examples-5","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"9          # since a number is a primitive type it can be\n           # constructed by simply typing the number itself\n\"a string\" # a string must surround the desired text with double quotes","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Now we'll list all constructors for all the different types supported by SceneLang.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_numbers","page":"SceneLang","title":"Numbers","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"As stated above, numbers are primitive types and have a symbolic constructor which is a simple numeric token.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"This constructor supports integer notation 1, dotted notations 1.0 and 1., and the scientific notations 1e2, 1e+2, 1e-2 and equivalent notation using E.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"warning: Warning\nThe notation .1 is not supported, the parser would interpret it as a keyword, use +.1, -.1, or 0.1 instead.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_numbers_time","page":"SceneLang","title":"TIME command","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"A special constructor command can also be used: TIME. This constructor returns the value of the time setting, which is set at the cli level (see render image and render animation). This is needed in animations to change values between a frame and the other.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_strings","page":"SceneLang","title":"Strings","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Being a primitive type, strings only have a symbolic constructor.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Strings are surrounded by double quotes (\") and support the usual set of escaped characters (e.g. \\n, \\t, ...). SceneLang strings do not support formatting or interpolations.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_colors","page":"SceneLang","title":"Colors","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Colors have a named constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Color(.R red::number = 0, .G green::number = 0, .B blue::number = 0)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"and a symbolic constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"<red::number, green::number, blue::number>","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Note that these colors are pixels of an HDR image, therefore have no upper bound.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_points","page":"SceneLang","title":"Points","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Points have a named constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Point(.X x::number = 0, .Y y::number = 0, .Z z::number = 0)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"and a symbolic constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"{x::number, y::number, z::number}","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_lists","page":"SceneLang","title":"Lists","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Lists have a named constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"List(element::number, ::number...)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"and a symbolic constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"[element::number, ::number...]","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_transformations","page":"SceneLang","title":"Transformations","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Transformations have a named constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Transformation(matrix::list.lenght16)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Transformations can be concatenated using the symbol * which behaves like a matrix multiplication operation.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Transformations also have the following four command constructors.","category":"page"},{"location":"scenelang/#SCALE-command","page":"SceneLang","title":"SCALE command","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"The SCALE command constructs a scaling transformation and has two different signatures:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"SCALE(.X x::number = 1, .Y y::number = 1, .Z z::number = 1) # scales by different factors on the given axes\nSCALE factor::number # scales uniformly on all axes","category":"page"},{"location":"scenelang/#TRANSLATE-command","page":"SceneLang","title":"TRANSLATE command","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"The TRANSLATE command constructs a translation transformation. It has the signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"TRANSLATE(.X x::number = 0, .Y y::number = 0, .Z z::number = 0)","category":"page"},{"location":"scenelang/#ROTATE-command","page":"SceneLang","title":"ROTATE command","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"The ROTATE command constructs a rotation transformation combining rotations in different axis. In the scene's euclidean 3D space scaling and translation transformations are commutable along different axes, so the order of application of the transformation does not matter: this is not the case for rotations.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Therefore the ROTATE command has a peculiar syntax for its arguments: after the command a series of keywords indicating the rotation axis are followed by the rotation angles in degrees in a way similar to the following example.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"ROTATE(.X 45 * .Z 30 * .X 20 * .Y 15)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"You can clearly see that in this syntax keywords can be repeated and are, therefore, non-optional. Furthermore, the order in which they are written matters as the result of the construction will be the concatenation of all the individual rotations. This is the reason why the arguments are not separated by commas but by concatenation symbols *.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_images","page":"SceneLang","title":"Images","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Images have two name constructors with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Image(file_path::string) # loads an image from a file at the given path if the format is valid\nImage(width::number.integer, height::number.integer) # constructs a black image of size `width`x`height`","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"and a command constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"LOAD file_path::string # loads an image from a file at the given path if the format is valid","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Valid argument of USING.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_pigments","page":"SceneLang","title":"Pigments","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Pigments have named constructors associated with each of their subtype specifiers. Their signatures are:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Pigment.Uniform(.color color::color = <1, 1, 1>)\nPigment.Checkered(.N::number.integer = 2 , .color_on color_on::color = <1, 1, 1>, .color_off::color = <0, 0, 0>)\nPigment.Image(.image image::image = Image(1, 1))","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_brdfs","page":"SceneLang","title":"BRDFs","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"BRDFs have named constructors associated with each of their subtype specifiers. Their signatures are:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Brdf.Diffuse(.pigment pigment::pigment = Pigment.Uniform())\nBrdf.Specular(.pigment pigment::pigment = Pigment.uniform(), .threshold_angle_rad angle::number = 0.0017453294)","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_materials","page":"SceneLang","title":"Materials","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Materials have a named constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Material(.brdf brdf::brdf = Brdf.Diffuse(), .emitted_radiance radiance::pigment = Pigment.Uniform())","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_shapes","page":"SceneLang","title":"Shapes","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Shapes have named constructors associated with each of their subtype specifiers. Their signatures are:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Shapes.Sphere  (.material material::material = Material(),\n                .transformation transformation::transformation = SCALE())\nShapes.Plane   (.material material::material = Material(),\n                .transformation transformation::transformation = SCALE())\nShapes.Cube    (.material material::material = Material(),\n                .transformation transformation::transformation = SCALE())\nShapes.Cylinder(.material material::material = Material(),\n                .transformation transformation::transformation = SCALE())","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Furthermore, shapes have also command constructors for Constructive Solid Geometries (CSG). Their signatures are:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"UNITE(shape::shape, ::shape...)\nINTERSECT(shape::shape, ::shape...)\nDIFF(shape::shape, ::shape...)\nFUSE(shape::shape, ::shape...)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Valid argument of SPAWN.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_lights","page":"SceneLang","title":"Lights","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Lights have a named constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Light(.position position::point = {0,0,0},\n      .color color::color = <1,1,1>,\n      .linear_radius radius::number = 0)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Valid argument of SPAWN.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_pcgs","page":"SceneLang","title":"PCGs","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"PCGs have a named constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Pcg(.state state::number.integer = 42,\n    .inc   inc::number.integer = 54)","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_camera","page":"SceneLang","title":"Camera","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Cameras have named constructors associated with each of their subtype specifiers. Their signatures are:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Camera.Perspective(.aspect_ratio ratio::number = 1.,\n                   .transformation transformation::transformation = SCALE 1.,\n                   .screen_distance distance::number = 1.)\nCamera.Orthogonal(.aspect_ratio ratio::number = 1.,\n                  .transformation transformation::transformation = SCALE 1.)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Valid argument of USING.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_renderers","page":"SceneLang","title":"Renderers","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Renderers have named constructors associated with each of their subtype specifiers. Their signatures are:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Renderer.OnOff(.on_color on::color = <1,1,1>,\n               .off_color off::color = <0,0,0>)\nRenderer.Flat(.background_color background::color = <0,0,0>)\nRenderer.PointLight(.background_color background::color = <0,0,0>,\n                    .ambient_color ambient::color = <1e-3,1e-3,1e-3>)\nRenderer.PathTracer(.background_color color::color = <0,0,0>,\n                    .rng              rng::pcg = Pcg()\n                    .n                n::number.integer = 10,\n                    .max_depth        max::number.integer = 2,\n                    .roulette_depth   roulette::number.integer = 3)","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Valid argument of USING.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_tracers","page":"SceneLang","title":"Tracers","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Tracers have a named constructor with signature","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Tracer(.samples_per_side samples::number = 1, .rng rng::pcg = Pcg())","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Valid argument of USING.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_constructors_math_expressions","page":"SceneLang","title":"MathExpressions","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Numbers, points, and colors can also be constructed via a MathExpression token. Math expressions are sections of code surrounded by dollar signs $. They can contain only mathematical operations, numbers and identifiers storing numbers.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"These expressions are first checked for validity at lexing time, where it is ensured that they only contain numbers, identifiers, and valid operations and that these operations have the right amount of arguments to them. The valid operations are:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"op symbol # of args action\n+ 1+ add\n- 1 or 2 change sign or subtract\n* 1+ multiply\n/ 2 float divide\ndiv 2 integer divide\n% 2 modulo\n^ 2 raise to the power of\nfloor 1 approximate to integer by defect\nceil 1 approximate to integer by excess\nround 1 approximate to nearest integer\nexp 1 natural base exponential\nexp2 1 binary base exponential\nexp10 1 decimal base exponential\nlog 1 natural base logarithm\nlog2 1 binary base logarithm\nlog10 1 decimal base logarithm\nlog1p 1 natural base logarithm of arg + 1\nsin 1 sine function (argument in radians)\ncos 1 cos function (argument in radians)\ntan 1 tan function (argument in radians)\nasin 1 arcsine function\nacos 1 arccos function\natan 1 or 2 arctan function\nPoint 3 Julia Point constructor\nRGB 3 Julia RGB constructor","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"After successful tokenization the expression is evaluated. Starting with the innermost expression all the identifiers are substituted with their value (if they are defined, otherwise an exception will be thrown) and then the result of the expression is calculated. If the result is a finite number the second innermost expression is evaluated and so on until the outermost expression is evaluated. If the result is either infinite or NaN an exception will be thrown.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"The tokenization and evaluation processes make use of the Meta.parse and eval functions provided by the Julia language. Therefore every valid Julia syntax for mathematical expressions is considered valid as long as it respects the restrictions discussed previously in this section.","category":"page"},{"location":"scenelang/#Examples-6","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"SET a 9                   # set the `a` variable to be equal to 9\nSET res1 $1 + 2a$         # this will set `res1` to be equal to 19\n# SET res2 $1 + 2b$       # this would throw an `UndefinedIdentifier` exception\n# SET res3 $div(1, 2, 3)$ # this would throw an `InvalidExpression` exception","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_instructions","page":"SceneLang","title":"Instructions","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"SceneLang scripts are a series of instructions parsed by the interpreter.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Each instruction starts with an instruction command and ends when all the possible arguments are consumed.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Arguments can only be variables or constructors.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"info: Info\nIn the following command signatures we will use:enclosing angular brackets<> to isolate single variable elements of the signature;\na pipe | between two elements indicates that one or the other can be present at that position;\nenclosing squared brackets [] to indicate optional arguments;\nappended dots ... to indicate that the previous element may be repeated an indefinite amount of times.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_instructions_SET","page":"SceneLang","title":"SET","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Assign to a variable a constructed variable.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"SET <<identifier> <constructor>>...","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"note: Note\nAll variables are constants in Scenelang and they exist and can't be overwritten until they are UNSET.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"note: Note\nYou cannot set an identifier to be equal to the value stored in another identifier as it is not needed in a program where the lifetime of the value is the lifetime of the variable.","category":"page"},{"location":"scenelang/#Examples-7","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"SET my_number 6 # sets `my_number` to be equal to 6\n\n# <identifier> <value> pairs can be chained after a SET statement\nSET\n    sphere Shape.Sphere()\n    cube   Shape.Cube()\n# as soon as the next token in the series is\n# not an identifier the SET statement is interrupted","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"tip: Tip\nSince SceneLang is not sensitive to spaces and newlines chained commands can have any layout you prefer, we still suggest, for easier visual parsing, the style we use in our examples of separating every element by a newline and a tabulation.","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_instructions_UNSET","page":"SceneLang","title":"UNSET","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Destroy a variable and the assigned value.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"UNSET <identifier>...","category":"page"},{"location":"scenelang/#Examples-8","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"UNSET my_number # my_number is now not assigned to any value and\n                # cannot be called any more unless it is SET again\n\n# <identifier>s can be chained after an UNSET statement\nUNSET\n    sphere\n    cube\n# as soon as the next token in the series is\n# not an identifier the UNSET statement is interrupted","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_instructions_SPAWN","page":"SceneLang","title":"SPAWN","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Spawns a shape or a light into the rendered world.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"SPAWN <<shape_identifier>|<shape_constructor>>...","category":"page"},{"location":"scenelang/#Examples-9","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"SET my_number 10\nSET my_sphere Shape.Sphere()\n\n# <identifier>s or <constructor>s can be chained after a SPAWN statement\nSPAWN\n    my_sphere    # my sphere is spawned into the world\n#   my_number    # this would throw a `WrongValueType` exception\n    Shape.Cube() # spawned shapes can also be constructed in-place\n    Light()      # lights can also be spawned\n# as soon as the next token in the series is\n# not an identifier the SPAWN statement is interrupted","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_instructions_USING","page":"SceneLang","title":"USING","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Sets a rendering settings to a given value.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"USING <<camera_identifier>  |<camera_constructor>  |\n       <image_identifier>   |<image_constructor>   |\n       <renderer_identifier>|<renderer_constructor>|\n       <tracer_identifier>  |<tracer_constructor>\n      >...","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"The rendering settings that can be set are:","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"the camera to be used and its properties;\nthe image to be impressed;\nthe renderer to be used and its properties;\nthe tracer to be used and its properties.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"warning: Warning\nUSING instruction must be used once and only once per setting within a script. if a setting is not defined an UndefinedSetting exception will be thrown, else, if a definition occurs more than once, a SettingRedefinition exception will be thrown.","category":"page"},{"location":"scenelang/#Examples-10","page":"SceneLang","title":"Examples","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"USING Camera.Orthogonal() # sets the camera setting to\n                          # be the default orthogonal camera\n\nSET p_camera Camera.Perspective()\nSET image Image(1920, 1080)\n\n# <identifier>s or <constructor>s can be chained after a USING statement\nUSING\n    Renderer.PointLight() # Usable objects can\n    Tracer()              # be constructed in-place\n    image                 # or they could be used by identifier\n#   p_camera\t\t\t  # this would throw a `SettingRedefinition` exception\n# as soon as the next token in the series is\n# not an identifier the USING statement is interrupted","category":"page"},{"location":"scenelang/#scenelang_syntax_structure_instructions_DUMP","page":"SceneLang","title":"DUMP","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Prints to stdout the specified content. Used mainy as a debug tool.","category":"page"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"# prints the value associated with the specified field of the scene\nDUMP.variables\nDUMP.world\nDUMP.lights\nDUMP.image\nDUMP.camera\nDUMP.renderer\nDUMP.tracer\n\nDUMP.ALL # prints all of the above","category":"page"},{"location":"devs/scenelang-api/#SceneLang-interpreter-API","page":"SceneLang interpreter API","title":"SceneLang interpreter API","text":"","category":"section"},{"location":"devs/scenelang-api/","page":"SceneLang interpreter API","title":"SceneLang interpreter API","text":"Documentation of SceneLang interpreter.","category":"page"},{"location":"devs/scenelang-api/#Contents","page":"SceneLang interpreter API","title":"Contents","text":"","category":"section"},{"location":"devs/scenelang-api/","page":"SceneLang interpreter API","title":"SceneLang interpreter API","text":"Pages = [\"scenelang-api.md\"]\nDepth = 2","category":"page"},{"location":"devs/scenelang-api/#Public-API","page":"SceneLang interpreter API","title":"Public API","text":"","category":"section"},{"location":"devs/scenelang-api/","page":"SceneLang interpreter API","title":"SceneLang interpreter API","text":"Modules = [Raytracer.Interpreter]\nPrivate = false","category":"page"},{"location":"devs/scenelang-api/#Raytracer.Interpreter","page":"SceneLang interpreter API","title":"Raytracer.Interpreter","text":"Raytracer.Interpreter\n\nSceneLang interpreter module.\n\n\n\n\n\n","category":"module"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.TokenValue","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.TokenValue","text":"TokenValue\n\nUnion of all types that can be used as token values while interpreting a SceneLang script.\n\nTypes\n\nKeyword\nIdentifier\nLiteralString\nLiteralNumber\nLiteralSymbol\nStopToken\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.Identifier","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.Identifier","text":"Identifier\n\nType wrapping a Symbol representing an identifier in a SceneLang script.\n\nFields\n\nvalue::Symbol: the value of the token\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InputStream","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InputStream","text":"InputStream\n\nType wrapping the IO from the source code of a SceneLang script.\n\nFields\n\nstream::IO: IO stream from the source code\nlocation::SourceLocation: a SourceLocation that keeps track of the reading position in the source file\nsaved_char::Union{Char, Nothing}: stores a character from unread_char! or nothing\nsaved_location::SourceLocation: a SourceLocation storing the previous reading position\nsaved_token::Union{Token, Nothing}: stores an unreaded Token\ntabulations::Int: how many columns a <tab> character is worth\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InterpreterException","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InterpreterException","text":"InterpreterException <: Exception\n\nAbstract type for all SceneLang interpreter errors.\n\nSee also: BadCharacter, UnfinishedExpression, UndefinedIdentifier, WrongTokenType, WrongValueType, InvalidKeyword, InvalidType, InvalidCommand, InvalidExpression, InvalidSymbol, InvalidNumber, InvalidSize, InvalidFilePath, IdentifierRedefinition SettingRedefinition UndefinedSetting\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.Keyword","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.Keyword","text":"Keyword\n\nType wrapping a Symbol representing a command or type in a SceneLang script.\n\nFields\n\nvalue::Symbol: the value of the token\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.LiteralNumber","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.LiteralNumber","text":"LiteralNumber\n\nType wrapping a Float32 representing a floating-point number in a SceneLang script.\n\nFields\n\nvalue::Float32: the value of the token\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.LiteralString","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.LiteralString","text":"LiteralString\n\nType wrapping a String representing a literal string in a SceneLang script.\n\nFields\n\nvalue::String: the value of the token\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.LiteralSymbol","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.LiteralSymbol","text":"LiteralSymbol\n\nType wrapping a Symbol representing a symbol in a SceneLang script.\n\nFields\n\nvalue::Symbol: the value of the token\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.MathExpression","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.MathExpression","text":"MathExpression\n\nType wrapping a Expr representing a mathematical expression in a SceneLang script.\n\nFields\n\nvalue::Expr: the value of the token\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.Scene","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.Scene","text":"Scene\n\nA mutable struct containing all the significant elements of a renderable scene and all the declared variables of the SceneLang script.\n\nFields\n\nvariables::IdTable: stores all the variables declared in the script\nworld::World: stores all the spawned Shapes\nlights::Lights: stores all the spawned PointLights\nimage::ImageOrNot: stores either the HdrImage to impress or nothing\ncamera::CameraOrNot: stores either the Camera or nothing\nrenderer::RendererOrNot: stores either the RendererSettings for the Renderer or nothing\ntracer::TracerOrNot: strores either the TracerSettings for the ImageTracer or nothing\ntime::Float32: stores the animation time\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.Scene-Tuple{Vector{Pair{Type{<:Raytracer.Interpreter.TokenValue}, Vector{Pair{Symbol, Raytracer.Interpreter.Token}}}}}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.Scene","text":"Scene(variables::Vector{Pair{Type{<:TokenValue}, Vector{Pair{Symbol, Token}}}};\n      world::World = World(),\n      lights::Lights = Lights(),\n      image::ImageOrNot = nothing,\n      camera::CameraOrNot = nothing,\n      renderer::RendererOrNot = nothing,\n      tracer::TracerOrNot = nothing,\n      time = 0f0)\n\nConstructor for a Scene instance.\n\nSlightly more convenient than the default constructor to manually construct in a Julia code.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.Scene-Tuple{}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.Scene","text":"Scene(; variables::IdTable = IdTable(),\n        world::World = World(),\n        lights::Lights = Lights(),\n        image::ImageOrNot = nothing,\n        camera::CameraOrNot = nothing,\n        renderer::RendererOrNot = nothing,\n        tracer::TracerOrNot = nothing,\n        time::Float32 = 0f0)\n\nConstructor for a Scene instance.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.SourceLocation","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.SourceLocation","text":"SourceLocation\n\nRepresents a position in a file at a certain line and column.\n\nFields\n\nfile_name::String: the input file name\nline_num::Int: line position\ncol_num::Int: column position\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.SourceLocation-Tuple{String, Int64, Int64}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.SourceLocation","text":"SourceLocation(file_name::String, line_num::Int, col_num::Int)\n\nConstructor for a SourceLocation instance.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.SourceLocation-Tuple{}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.SourceLocation","text":"SourceLocation(; file_name::String = \"\", line_num::Int = 1, col_num::Int = 0)\n\nConstructor for a SourceLocation instance.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.StopToken","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.StopToken","text":"StopToken\n\nConvenience empty type to help identify the end of a SceneLang script.\n\nFields\n\nvalue::Nothing: the value of the token\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.Token","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.Token","text":"Token{T <: TokenValue}\n\nType representing a language token of a SceneLang script.\n\nFields\n\nloc::SourceLocation: a SourceLocation representing the position in the script at which the token starts,\nvalue::T: a TokenValue representing the value of the token (see TokenValue)\nlength::Int: length of the input token.\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.open_stream-Tuple{Function, String}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.open_stream","text":"open_stream(f::Function, file_name::String; tabulations::Int = 8)\n\nOpen read-only a file named file_name as an InputStream and apply f to it.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_scene","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_scene","text":"parse_scene(stream::InputStream, scene::Scene = Scene())\n\nReturn the Scene instance resulting parsing the SceneLang script associated with the given InputStream.\n\n\n\n\n\n","category":"function"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_variables_from_string-Tuple{AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_variables_from_string","text":"parse_variables_from_string(str::AbstractString; table::IdTable = IdTable()) -> IdTable\n\nParse a string containing comma separated identifier-constructor pairs and return the resulting IdTable.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Private-API","page":"SceneLang interpreter API","title":"Private API","text":"","category":"section"},{"location":"devs/scenelang-api/","page":"SceneLang interpreter API","title":"SceneLang interpreter API","text":"Modules = [Raytracer.Interpreter]\nPublic = false","category":"page"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.CameraOrNot","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.CameraOrNot","text":"CameraOrNot\n\nAlias for Union{Camera, Nothing}.\n\nSee also: Scene\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.IdTableKey","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.IdTableKey","text":"IdTableKey\n\nAlias for Union{Type{<:TokenValue}, LiteralType}. Used as the key type for IdTable.\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.ImageOrNot","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.ImageOrNot","text":"ImageOrNot\n\nAlias for Union{HdrImage, Nothing}.\n\nSee also: Scene\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.RendererOrNot","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.RendererOrNot","text":"RendererOrNot\n\nAlias for Union{RendererSettings, Nothing}.\n\nSee also: Scene\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.TracerOrNot","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.TracerOrNot","text":"TracerOrNot\n\nAlias for Union{TracerSettings, Nothing}.\n\nSee also: Scene\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.valid_operations","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.valid_operations","text":"valid_operations\n\nA dictionary storing the operation Symbol and a function ::Int -> ::Bool that return true when the number of arguments is under a threshold.\n\nFor example the pair :+ => ( ::Int) -> true indicates that the operation + is valid with any number of arguments, while the pair :floor => (n::Int) -> n == 1 indicates that the operation floor is valid only if it has one argument.\n\nSee also: Raytracer.isvalid\n\n\n\n\n\n","category":"constant"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.BadCharacter","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.BadCharacter","text":"BadCharacter <: InterpreterException\n\nThere is an invalid character in the SceneLang script.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.BadCharacter-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.BadCharacter","text":"BadCharacter(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of BadCharacter with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.Command","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.Command","text":"Command\n\nEnum type listing all commands of SceneLang.\n\nInstances\n\nRaytracer.Interpreter.USING\nRaytracer.Interpreter.SET\nRaytracer.Interpreter.UNSET\nRaytracer.Interpreter.SPAWN\nRaytracer.Interpreter.DUMP\nRaytracer.Interpreter.LOAD\nRaytracer.Interpreter.ROTATE\nRaytracer.Interpreter.TRANSLATE\nRaytracer.Interpreter.SCALE\nRaytracer.Interpreter.UNITE\nRaytracer.Interpreter.INTERSECT\nRaytracer.Interpreter.DIFF\nRaytracer.Interpreter.FUSE\nRaytracer.Interpreter.TIME\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.IdTable","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.IdTable","text":"IdTable\n\nAlias to Dict{IdTableKey, Dict{Symbol, ValueLoc}}.\n\nDictionary with all the variables set in a SceneLang script. Keys represent the equivalent TokenValue or LiteralType type to the Julia type stored in ValueLoc.\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.IdentifierRedefinition","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.IdentifierRedefinition","text":"IdentifierRedefinition <: InterpreterException\n\nAn identifier is being redefined without being unset first.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.IdentifierRedefinition-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.IdentifierRedefinition","text":"IdentifierRedefinition(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of IdentifierRedefinition with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidCommand","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidCommand","text":"InvalidCommand <: InterpreterException\n\nThe given command does not exist.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidCommand-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidCommand","text":"InvalidCommand(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of InvalidCommand with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidExpression","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidExpression","text":"InvalidExpression <: InterpreterException\n\nThe given expression contains invalid elements. Capabilities are restrained to contain malicious code injection.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidExpression-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidExpression","text":"InvalidExpression(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of InvalidExpression with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidFilePath","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidFilePath","text":"InvalidFilePath <: InterpreterException\n\nThe given file path is invalid.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidFilePath-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidFilePath","text":"InvalidFilePath(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of InvalidFilePath with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidKeyword","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidKeyword","text":"InvalidKeyword <: InterpreterException\n\nThe given keyword is not valid in the given context.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidKeyword-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidKeyword","text":"InvalidKeyword(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of InvalidKeyword with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidNumber","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidNumber","text":"InvalidNumber <: InterpreterException\n\nThe token has an invalid numerical format.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidNumber-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidNumber","text":"InvalidNumber(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of InvalidNumber with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidSize","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidSize","text":"InvalidSize <: InterpreterException\n\nThe given collection has an invalid size in the given context.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidSize-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidSize","text":"InvalidSize(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of InvalidSize with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidSymbol","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidSymbol","text":"InvalidSymbol <: InterpreterException\n\nThe given symbol is not valid in the given context.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidSymbol-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidSymbol","text":"InvalidSymbol(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of InvalidSymbol with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidType","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidType","text":"InvalidType <: InterpreterException\n\nThe given type does not exist.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.InvalidType-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.InvalidType","text":"InvalidType(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of InvalidType with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.LiteralType","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.LiteralType","text":"LiteralType\n\nEnum type listing all main types of SceneLang.\n\nInstances\n\nRaytracer.Interpreter.ColorType\nRaytracer.Interpreter.PointType\nRaytracer.Interpreter.ListType\nRaytracer.Interpreter.TransformationType\nRaytracer.Interpreter.MaterialType\nRaytracer.Interpreter.BrdfType\nRaytracer.Interpreter.PigmentType\nRaytracer.Interpreter.ShapeType\nRaytracer.Interpreter.LightType\nRaytracer.Interpreter.ImageType\nRaytracer.Interpreter.RendererType\nRaytracer.Interpreter.CameraType\nRaytracer.Interpreter.PcgType\nRaytracer.Interpreter.TracerType\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.RendererSettings","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.RendererSettings","text":"RendererSettings\n\nStruct containing a renderer type and a NamedTuple of the named arguments needed for its construction.\n\nSince a Renderer type cannot be directly stored into a Scene due to it needing at least the World argument, we can use this struct to store everything else, ready to be constructed.\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.SettingRedefinition","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.SettingRedefinition","text":"SettingRedefinition <: InterpreterException\n\nA rendering setting is being defined multiple times.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.SettingRedefinition-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.SettingRedefinition","text":"SettingRedefinition(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of SettingRedefinition with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.TracerSettings","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.TracerSettings","text":"TracerSettings\n\nStruct containing a NamedTuple of the named arguments needed to construct an ImageTracer.\n\nSince a ImageTracer type cannot be directly stored into a Scene due to it needing at least the Camera and HdrImage arguments, we can use this struct to store everything else, ready to be constructed.\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.UndefinedIdentifier","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.UndefinedIdentifier","text":"UndefinedIdentifier <: InterpreterException\n\nThe given identifier has not been defined in the script.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.UndefinedIdentifier-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.UndefinedIdentifier","text":"UndefinedIdentifier(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of UndefinedIdentifier with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.UndefinedSetting","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.UndefinedSetting","text":"UndefinedSetting <: InterpreterException\n\nOne or more necessary rendering settings have not been set up in the SceneLang script.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.UndefinedSetting-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.UndefinedSetting","text":"UndefinedSetting(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of UndefinedSetting with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.UnfinishedExpression","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.UnfinishedExpression","text":"UnfinishedExpression <: InterpreterException\n\nA special environment (e.g. a string, mathematical expression, list...) has been opened and not closed.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.UnfinishedExpression-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.UnfinishedExpression","text":"UnfinishedExpression(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of UnfinishedExpression with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.ValueLoc","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.ValueLoc","text":"ValueLoc\n\nStores a Julia value and the source location of its declaration.\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.WrongTokenType","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.WrongTokenType","text":"WrongTokenType <: InterpreterException\n\nThe given value is of a different type than expected by the syntax.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.WrongTokenType-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.WrongTokenType","text":"WrongTokenType(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of WrongTokenType with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.WrongValueType","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.WrongValueType","text":"WrongValueType <: InterpreterException\n\nThe given value has a different type than expected by the syntax.\n\nSee also: InterpreterException\n\nFields\n\nlocation::SourceLocation: location of the error\nmsg::AbstractString: descriptive error message\nlen::Int: how many characters are involved in the error\n\n\n\n\n\n","category":"type"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.WrongValueType-Tuple{Raytracer.Interpreter.SourceLocation, AbstractString}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.WrongValueType","text":"WrongValueType(location::SourceLocation, msg::AbstractString)\n\nConstruct an instance of WrongValueType with len = 1.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Base.eof-Tuple{Raytracer.Interpreter.InputStream}","page":"SceneLang interpreter API","title":"Base.eof","text":"eof(stream::InputStream)\n\nCheck if the stream has reached the end-of-file.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Base.isvalid-Tuple{Expr, Int64, Raytracer.Interpreter.SourceLocation}","page":"SceneLang interpreter API","title":"Base.isvalid","text":"Raytracer.isvalid(expr::Expr, str_len::Int, token_location::SourceLocation)\n\nReturn true if the given expression is valid in a SceneLang script, else throw an appropriate exception using str_len and token_location.\n\nSee also: valid_operations\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter._parse_command_or_type_token-Tuple{Raytracer.Interpreter.InputStream, Char, Raytracer.Interpreter.SourceLocation}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter._parse_command_or_type_token","text":"_parse_command_or_type_token(stream::InputStream, first_char::Char, token_location::SourceLocation)\n\nParse the stream into a Token with Command or LiteralType value.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter._parse_identifier_token-Tuple{Raytracer.Interpreter.InputStream, Char, Raytracer.Interpreter.SourceLocation}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter._parse_identifier_token","text":"_parse_identifier_token(stream::InputStream, first_char::Char, token_location::SourceLocation)\n\nParse the stream into a Token with Identifier value.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter._parse_keyword_token-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.SourceLocation}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter._parse_keyword_token","text":"_parse_keyword_token(stream::InputStream, first_char::Char, token_location::SourceLocation)\n\nParse the stream into a Token with Keyword value.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter._parse_math_expression_token-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.SourceLocation}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter._parse_math_expression_token","text":"_parse_math_expression_token(stream::InputStream, token_location::SourceLocation)\n\nParse the stream into a Token with MathExpression value.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter._parse_number_token-Tuple{Raytracer.Interpreter.InputStream, Char, Raytracer.Interpreter.SourceLocation}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter._parse_number_token","text":"_parse_number_token(stream::InputStream, first_char::Char, token_location::SourceLocation)\n\nParse the stream into a Token with LiteralNumber value.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter._parse_string_token-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.SourceLocation}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter._parse_string_token","text":"_parse_string_token(stream::InputStream, token_location::SourceLocation)\n\nParse the stream into a Token with LiteralString value.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter._update_pos!-Tuple{Raytracer.Interpreter.InputStream, Union{Nothing, Char}}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter._update_pos!","text":"_update_pos!(stream::InputStream, ch::Union{Char, Nothing})\n\nUpdate stream.location after having read ch from the stream.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.evaluate_math_expression-Tuple{Raytracer.Interpreter.Token{Raytracer.Interpreter.MathExpression}, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.evaluate_math_expression","text":"evaluate_math_expression(token::Token{MathExpression}, scene::Scene)\n\nReplace all identifiers in the mathematical expression stored in the MathExpression token and then evaluate it.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_command-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Command}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_command","text":"expect_command(stream::InputStream, command::Command)\n\nRead a token from an InputStream and check that it is a given Command.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_command-Tuple{Raytracer.Interpreter.InputStream, Union{Tuple{Vararg{Raytracer.Interpreter.Command, N}} where N, AbstractVector{Raytracer.Interpreter.Command}}}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_command","text":"expect_command(stream::InputStream, commands::Union{NTuple{N, Command} where {N}, AbstractVector{Command}})\n\nRead a token from an InputStream and check that it is a Command in the given commands.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_command-Tuple{Raytracer.Interpreter.InputStream}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_command","text":"expect_command(stream::InputStream)\n\nRead a token from an InputStream and check that it is a Command.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_identifier-Tuple{Raytracer.Interpreter.InputStream}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_identifier","text":"expect_identifier(stream::InputStream)\n\nRead a token from an InputStream and check that it is an Identifier.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_keyword-Tuple{Raytracer.Interpreter.InputStream, Symbol}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_keyword","text":"expect_keyword(stream::InputStream, keyword::Symbol)\n\nRead a token from an InputStream and check that it is a given Keyword.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_keyword-Tuple{Raytracer.Interpreter.InputStream, Union{Tuple{Vararg{Symbol, N}} where N, AbstractVector{Symbol}}}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_keyword","text":"expect_keyword(stream::InputStream, keywords_list::Union{NTuple{N, Symbol} where {N}, AbstractVector{Symbol}})\n\nRead a token from an InputStream and check that it is a Keyword in keywords_list.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_number-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_number","text":"expect_number(stream::InputStream, scene::Scene)\n\nRead a token from an InputStream and check that it is a LiteralNumber.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_string-Tuple{Raytracer.Interpreter.InputStream}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_string","text":"expect_string(stream::InputStream)\n\nRead a token from an InputStream and check that it is a LiteralString.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_symbol-Tuple{Raytracer.Interpreter.InputStream, Symbol}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_symbol","text":"expect_symbol(stream::InputStream, symbol::LiteralSymbol)\n\nRead a token from an InputStream and check that it is the requested LiteralSymbol.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_symbol-Tuple{Raytracer.Interpreter.InputStream, Union{Tuple{Any, Symbol}, AbstractVector{Symbol}}}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_symbol","text":"expect_symbol(stream::InputStream, symbols::Union{Tuple{N, Symbol} where {N}, AbstractVector{Symbol}})\n\nRead a token from an InputStream and check that it is one of the requested LiteralSymbols.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_type-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.LiteralType}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_type","text":"expect_type(stream::InputStream, type::LiteralType)\n\nRead a token from an InputStream and check that it is a given LiteralType.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_type-Tuple{Raytracer.Interpreter.InputStream, Union{Tuple{Vararg{Raytracer.Interpreter.LiteralType, N}} where N, AbstractVector{Raytracer.Interpreter.LiteralType}}}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_type","text":"expect_type(stream::InputStream, types::Union{NTuple{N, LiteralType} where {N}, AbstractVector{LiteralType}})\n\nRead a token from an InputStream and check that it is a LiteralType in the given types.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.expect_type-Tuple{Raytracer.Interpreter.InputStream}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.expect_type","text":"expect_type(stream::InputStream)\n\nRead a token from an InputStream and check that it is a LiteralType.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.generate_kwargs-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene, NamedTuple}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.generate_kwargs","text":"function generate_kwargs(stream::InputStream, scene::Scene, kw::NamedTuple)\n\nReturn a Dict{Symbol, Any} as instructed by the given kw NamedTuple.\n\nThe argument kw pairs all the keywords a constructor need with the parsing functions they need. This function parses keywords and/or values until it reaches the end of the constructor. The arguments may also be positional, but positional arguments must not follow keyword arguments. If a keyword is used more than once an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.isnewline-Tuple{Char}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.isnewline","text":"isnewline(c::Char)\n\nCheck if c is a newline character.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.issymbol-Tuple{Char}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.issymbol","text":"issymbol(c::Char)\n\nCheck if c is in a partucular set of characters used in a SceneLang script.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_brdf-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_brdf","text":"parse_brdf(stream::InputStream, scene::Scene)\n\nReturn a BRDF value from either a named constructor or an appropriate Identifier.\n\nThe concrete type is determined by the first keyword after the BrdfType token, which also determines the keyword arguments to be read by generate_kwargs.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_by_identifier-Tuple{Union{Raytracer.Interpreter.LiteralType, Type{<:Raytracer.Interpreter.TokenValue}}, Raytracer.Interpreter.InputStream, Dict{Union{Raytracer.Interpreter.LiteralType, Type{<:Raytracer.Interpreter.TokenValue}}, Dict{Symbol, Raytracer.Interpreter.ValueLoc}}}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_by_identifier","text":"parse_by_identifier(expected_type::IdTableKey, stream::InputStream, table::IdTable)\n\nIf the next token is an Identifier, check that its type is coherent with expected_type and return its value.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_camera-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_camera","text":"parse_camera(stream::InputStream, scene::Scene)\n\nReturn a Camera value from either a named constructor or an appropriate Identifier.\n\nThe concrete type is determined by the first keyword after the CameraType token, which also determines the keyword arguments to be read by generate_kwargs.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_color-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_color","text":"parse_color(stream::InputStream, scene::Scene)\n\nReturn a RGB{Float32} value from either a named constructor, a symbolic constructor, an appropriate MathExpression, or an appropriate Identifier.\n\nIf the constructor has not exactly three arguments an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_constructor-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_constructor","text":"parse_constructor(stream::InputStream, scene::Scene)\n\nReturn a Tuple{Any, IdTableKey} containing the result of the construction and its type.\n\nIf the expression from the stream is not a valid constructor an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_dump_command-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_dump_command","text":"parse_dump_command(stream::InputStream, scene::Scene)\n\nShow the contents of the Scene. What is shown depends on the Keyword following the DUMP Command.\n\nThe valid Keywords are .ALL for showing the whole Scene, or the name of one of its fields (in lowercase letters) to show that specific field.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_explicit_image-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_explicit_image","text":"parse_explicit_image(stream::InputStream, scene::Scene)\n\nReturn an HdrImage value from a named constructor.\n\nThere are two versions of the constructor:\n\none taking a valid file path LiteralString as the only argument and loading the image stored in that file\nthe other taking two integer LiteralNumbers as width and height and constructing an empty image.\n\nSee also: parse_image\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_explicit_shape-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_explicit_shape","text":"parse_explicit_shape(stream::InputStream, scene::Scene)\n\nReturn a Shape value from either a named constructor or an appropriate Identifier.\n\nThe concrete type is determined by the first keyword after the ShapeType token, which also determines the keyword arguments to be read by generate_kwargs.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_explicit_transformation-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_explicit_transformation","text":"parse_explicit_transformation(stream::InputStream, scene::Scene)\n\nReturn a Transformation value from a named constructor taking a 16-long list as the only argument.\n\nThere is no way to set the inverse matrix, so it will be calculated by the inv algorithm upon construction.\n\nSee also: parse_transformation\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_float-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_float","text":"parse_float(stream::InputStream, scene::Scene)\n\nReturn a Float32 value from either a LiteralNumber constructor, the TIME command, an appropriate MathExpression, or an appropriate Identifier.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_fusion-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_fusion","text":"parse_fusion(stream::InputStream, scene::Scene)\n\nReturn a FusionCSG value from the FUSE Command.\n\nSee also: parse_shape_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_image-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_image","text":"parse_image(stream::InputStream, scene::Scene)\n\nReturn an HdrImage value from either a named constructor, a construction command, or an appropriate Identifier.\n\nSee also: parse_explicit_image, parse_image_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_image_from_command-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_image_from_command","text":"parse_image_from_command(stream::InputStream, scene::Scene)\n\nReturn an HdrImage value from the LOAD Command.\n\nThe LOAD Command takes only one LiteralString representing a valid file path to an image file as an argument.\n\nSee also: parse_image\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_int-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_int","text":"parse_int(stream::InputStream, scene::Scene)\n\nReturn a Int value from either a LiteralNumber constructor, the TIME command, an appropriate MathExpression, or an appropriate Identifier.\n\nIf the Float32 number is not exactly representing an integer number an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_intersection-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_intersection","text":"parse_intersection(stream::InputStream, scene::Scene)\n\nReturn a IntersectionCSG value from the INTERSECT Command.\n\nSee also: parse_shape_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_light-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_light","text":"parse_light(stream::InputStream, scene::Scene)\n\nReturn a PointLight value from either a named constructor or an appropriate Identifier.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_list-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene, Int64}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_list","text":"parse_list(stream::InputStream, scene::Scene, list_length::Int)\n\nReturn a SVector{list_length, Float32} value from either a named constructor, a symbolic constructor or an appropriate Identifier.\n\nIf the list is not exactly list_length long an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_list-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_list","text":"parse_list(stream::InputStream, scene::Scene)\n\nReturn a Vector{Float32} value from either a named constructor, a symbolic constructor or an appropriate Identifier.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_material-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_material","text":"parse_material(stream::InputStream, scene::Scene)\n\nReturn a Material value from either a named constructor or an appropriate Identifier.\n\nThe concrete type is determined by the first keyword after the MaterialType token, which also determines the keyword arguments to be read by generate_kwargs.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_pcg-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_pcg","text":"parse_pcg(stream::InputStream, scene::Scene)\n\nReturn a PCG value from either a named constructor or an appropriate Identifier.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_pigment-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_pigment","text":"parse_pigment(stream::InputStream, scene::Scene)\n\nReturn a Pigment value from either a named constructor or an appropriate Identifier.\n\nThe concrete type is determined by the first keyword after the PigmentType token, which also determines the keyword arguments to be read by generate_kwargs.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_point-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_point","text":"parse_point(stream::InputStream, scene::Scene)\n\nReturn a Point value from either a named constructor, a symbolic constructor, an appropriate MathExpression, or an appropriate Identifier.\n\nIf the constructor has not exactly three arguments an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_renderer_settings-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_renderer_settings","text":"parse_renderer_settings(stream::InputStream, scene::Scene)\n\nReturn a RendererSettings value from either a named constructor or an appropriate Identifier.\n\nThe renderer type is determined by the first keyword after the RendererType token, which also determines the keyword arguments to be read by generate_kwargs and stored in the kwargs field of the result.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_rotation-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_rotation","text":"parse_rotation(stream::InputStream, scene::Scene)\n\nReturn a Transformation value from the ROTATE Command.\n\nThe argument of this command is a sequence of keyword arguments, with keywords representing the three axes of rotation .X, .Y, and .Z, followed by a number representing the rotation angle in degrees. Each of these keyword arguments are separated by a * operator which behaves as a concatenation of rotation following the usual rules of matrix multiplication (i.e. the rightmost rotation will be the first to be applied)\n\nSee also: parse_transformation_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_scaling-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_scaling","text":"parse_scaling(stream::InputStream, scene::Scene)\n\nReturn a Transformation value from the SCALE Command.\n\nThe arguments of this command are a sequence of keyword arguments, with keywords representing the three axes of scaling .X, .Y, and .Z, followed by a number representing the scaling factor. Each of these keyword arguments are separated by a ,. The order of these arguments is indifferent since, in our euclidean space, scalings are commutative transformations.\n\nAn alternate form of this command sees only one numeric argument, without parenthesis, and indicates uniform scaling in all directions.\n\nSee also: parse_transformation_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_set_command-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_set_command","text":"parse_set_command(stream::InputStream, scene::Scene)\n\nPush to the 'scene.variables' IdTable a constructed value and its identifier variable.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_setdiff-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_setdiff","text":"parse_setdiff(stream::InputStream, scene::Scene)\n\nReturn a DiffCSG value from the DIFF Command.\n\nSee also: parse_shape_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_shape-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_shape","text":"parse_shape(stream::InputStream, scene::Scene)\n\nReturn a Shape value from either a named constructor, a construction command, or an appropriate Identifier.\n\nSee also: parse_explicit_shape, parse_shape_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_shape_from_command-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_shape_from_command","text":"parse_shape_from_command(stream::InputStream, scene::Scene)\n\nReturn a Shape value from the UNITE, INTERSECT, DIFF, and FUSE Commands.\n\nSee also: parse_shape, parse_union, parse_intersection, parse_setdiff, parse_fusion\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_spawn_command-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_spawn_command","text":"parse_spawn_command(stream::InputStream, scene::Scene)\n\nPush the given ShapeType or LightType to the scene.world World or scene.lights Lights respectively.\n\nSee also: Scene\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_string-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_string","text":"parse_string(stream::InputStream, scene::Scene)\n\nReturn a String value from either a LiteralString constructor or an appropriate Identifier.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_tracer_settings-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_tracer_settings","text":"parse_tracer_settings(stream::InputStream, scene::Scene)\n\nReturn a TracerSettings value from either a named constructor or an appropriate Identifier.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_transformation-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_transformation","text":"parse_transformation(stream::InputStream, scene::Scene)\n\nReturn a Transformation value from either a named constructor, a construction command, or an appropriate Identifier.\n\nIf the constructor/command/identifier is followed by an * operator the transformations will be concatenated following the usual matrix multiplication rules (i.e. the rightmost transformation will be applied first).\n\nSee also: parse_explicit_transformation, parse_transformation_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_transformation_from_command-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_transformation_from_command","text":"parse_transformation_from_command(stream::InputStream, scene::Scene)\n\nReturn a Transformation value from the ROTATE, TRANSLATE, and SCALE Commands.\n\nSee also: parse_transformation, parse_rotation, parse_translation, parse_scaling\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_translation-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_translation","text":"parse_translation(stream::InputStream, scene::Scene)\n\nReturn a Transformation value from the TRANSLATE Command.\n\nThe arguments of this command are a sequence of keyword arguments, with keywords representing the three axes of translation .X, .Y, and .Z, followed by a number representing the displacement. Each of these keyword arguments are separated by a ,. The order of these arguments is indifferent since, in our euclidean space, translations are commutative transformations.\n\nSee also: parse_transformation_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_union-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_union","text":"parse_union(stream::InputStream, scene::Scene)\n\nReturn a UnionCSG value from the UNITE Command.\n\nSee also: parse_shape_from_command\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_unset_command-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_unset_command","text":"parse_unset_command(stream::InputStream, scene::Scene)\n\nPop identifier variable from the scene.variables IdTable.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.parse_using_command-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Scene}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.parse_using_command","text":"parse_using_command(stream::InputStream, scene::Scene)\n\nSet the given CameraType, ImageType or RendererType to the scene.camera, scene.image, or scene.renderer respectively.\n\nCan only be used once per type in a SceneLang script.\n\nSee also: Scene\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.read_at_line-Tuple{IO, Int64}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.read_at_line","text":"read_at_line(io::IO, line_num::Int)\n\nRead the line_num-th line of io.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.read_at_line-Tuple{String, Int64}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.read_at_line","text":"read_at_line(file_name::String, line_num::Int)\n\nRead the line_num-th line of a file named file_name.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.read_char!-Tuple{Raytracer.Interpreter.InputStream}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.read_char!","text":"read_char!(stream::InputStream)\n\nRead a new character from the stream.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.read_token-Tuple{Raytracer.Interpreter.InputStream}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.read_token","text":"read_token(stream::InputStream)\n\nRead the next token in the stream.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.skip_whitespaces_and_comments-Tuple{Raytracer.Interpreter.InputStream}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.skip_whitespaces_and_comments","text":"skip_whitespaces_and_comments(stream::InputStream)\n\nKeep reading characters until a non-whitespace character is found out of a commented line.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.unread_char!-Tuple{Raytracer.Interpreter.InputStream, Union{Nothing, Char}}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.unread_char!","text":"unread_char!(stream::InputStream, ch::Union{Char, Nothing})\n\nPush a character back to the stream. Accepts a nothing value to deal with eof.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Raytracer.Interpreter.unread_token-Tuple{Raytracer.Interpreter.InputStream, Raytracer.Interpreter.Token}","page":"SceneLang interpreter API","title":"Raytracer.Interpreter.unread_token","text":"unread_token(stream::InputStream, ch::Token)\n\nPush a token back to the stream.\n\n\n\n\n\n","category":"method"},{"location":"devs/scenelang-api/#Index","page":"SceneLang interpreter API","title":"Index","text":"","category":"section"},{"location":"devs/scenelang-api/","page":"SceneLang interpreter API","title":"SceneLang interpreter API","text":"Modules = [Raytracer.Interpreter]\nPages   = [\"scenelang-api.md\"]","category":"page"},{"location":"api/high-level/#high_level_api","page":"High-level API","title":"High-level API","text":"","category":"section"},{"location":"api/high-level/#Contents","page":"High-level API","title":"Contents","text":"","category":"section"},{"location":"api/high-level/","page":"High-level API","title":"High-level API","text":"Pages = [\"high-level.md\"]\nDepth = 2","category":"page"},{"location":"api/high-level/#High-level-API","page":"High-level API","title":"High-level API","text":"","category":"section"},{"location":"api/high-level/","page":"High-level API","title":"High-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"user_utils.jl\"]","category":"page"},{"location":"api/high-level/#Raytracer.render-Tuple{ImageTracer, Renderer}","page":"High-level API","title":"Raytracer.render","text":"render(image_tracer::ImageTracer,\n       renderer::Renderer\n       ; output_file::String = \"out.pfm\"\n         use_threads::Bool = true,\n         disable_output::Bool = false)\n\nRender an image given an ImageTracer and a Renderer, and save the generated hdr image in output_file.\n\nIf use_threads is true, use macro Threads.@threads. If disable_output is true, no message is printed.\n\n\n\n\n\n","category":"method"},{"location":"api/high-level/#Raytracer.render_from_script-Tuple{String}","page":"High-level API","title":"Raytracer.render_from_script","text":"render_from_script(input_script::String\n                   ; output_file::String = \"out.pfm\",\n                     time::Float32 = 0f0,\n                     vars::String = \"\",\n                     use_threads::Bool = true,\n                     disable_output::Bool = false)\n\nRender an image given an input_script written in SceneLang and save the generated hdr image in output_file.\n\nIf use_threads is true, use macro Threads.@threads. If disable_output is true, no message is printed.\n\n\n\n\n\n","category":"method"},{"location":"api/high-level/#Raytracer.tonemapping-Tuple{String, String}","page":"High-level API","title":"Raytracer.tonemapping","text":"tonemapping(input_file::String,\n            output_file::String\n            ; α::Float32,\n              γ::Float32,\n              luminosity::Union{Float32, Nothing} = nothing,\n              disable_output::Bool = false)\n\nLoad a pfm hdr image, apply the tone mapping, and save the generated ldr image.\n\ninput_file is the path to a valid PFM image. output_file is the path in which save the generated image + the name of the output file. The output format is deduced by the extension of the output file: if the name is example.jpg, the image will be exported in JPEG format. α is the normalization coefficient. γ is the actor of the γ correction. Optional parameter luminosity can be used for better tuning.\n\nIf disable_output is true, no message is printed.\n\n\n\n\n\n","category":"method"},{"location":"api/high-level/#Index","page":"High-level API","title":"Index","text":"","category":"section"},{"location":"api/high-level/","page":"High-level API","title":"High-level API","text":"Modules = [Raytracer]\nPages   = [\"high-level.md\"]","category":"page"},{"location":"devs/private-api/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"devs/private-api/","page":"Private API","title":"Private API","text":"Documentation of all the code not explicitly exported by module Raytracer.jl.","category":"page"},{"location":"devs/private-api/#Contents","page":"Private API","title":"Contents","text":"","category":"section"},{"location":"devs/private-api/","page":"Private API","title":"Private API","text":"Pages = [\"private-api.md\"]\nDepth = 2","category":"page"},{"location":"devs/private-api/#Private-API-2","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"devs/private-api/","page":"Private API","title":"Private API","text":"Modules = [Raytracer]\nPublic = false","category":"page"},{"location":"devs/private-api/#Raytracer.AABB","page":"Private API","title":"Raytracer.AABB","text":"AABB\n\nA type representing an Axis-Aligned Bounding Box.\n\n\n\n\n\n","category":"type"},{"location":"devs/private-api/#Raytracer.CompositeShape","page":"Private API","title":"Raytracer.CompositeShape","text":"CompositeShape <: Shape\n\nAbstract type representing a Shape composed of other shapes.\n\nThese shapes cannot be easily described as transformed versions of a unitary shape, and so they differ from SimpleShape under many aspects.\n\nSee also: CSG\n\n\n\n\n\n","category":"type"},{"location":"devs/private-api/#Raytracer.SimpleShape","page":"Private API","title":"Raytracer.SimpleShape","text":"SimpleShape <: Shape\n\nAbstract type representing a Shape that can be represented as transformed unitary shapes.\n\nAn example of simple shape is the parallelepiped: every instance of this shape can be transformed back into a cube of unitary size. Therefore, these shapes are univocally determined by their type (e.g. a cuboid) and the transformation that morphs the unitary shape in the desired shape.\n\nSee also: Cube, Cylinder, Plane, Sphere\n\n\n\n\n\n","category":"type"},{"location":"devs/private-api/#Base.:*-Tuple{Point, Vararg{Any}}","page":"Private API","title":"Base.:*","text":"*(p::Point, s...)\n\nMultiplication operator. x * y * z * ...calls this function with all arguments, i.e.*(x, y, z, ...)`.\n\nReturn a Point.\n\nExamples\n\njulia> Point(1, 2, 3) * 2 * 3\nPoint with eltype Float32\nx = 6.0, y = 12.0, z = 18.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:*-Tuple{RGB, RGB}","page":"Private API","title":"Base.:*","text":"*(c1::RGB, c2::RGB)\n\nReturn the elementwise product of two colors.\n\nExamples\n\njulia> RGB(1f0, 2f0, 3f0) * RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 4.0, G: 10.0, B: 18.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:*-Tuple{Transformation, Ray}","page":"Private API","title":"Base.:*","text":"*(t::Transformation, r::Ray)\n\nTransform a Ray with the given Transformation.\n\nExamples\n\njulia> ray = Ray(ORIGIN, VEC_X)\nRay\n ↳ origin = Point(0.0, 0.0, 0.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\njulia> Transformation() * ray\nRay\n ↳ origin = Point(0.0, 0.0, 0.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\njulia> translation(2,4,-6) * ray\nRay\n ↳ origin = Point(2.0, 4.0, -6.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:*-Union{Tuple{T}, Tuple{Number, RGB{T}}} where T","page":"Private API","title":"Base.:*","text":"*(scalar::Number, c::RGB)\n*(c::RGB, scalar::Number)\n\nReturn a RGB color with each component multiplied by scalar.\n\nExamples\n\njulia> c = 2.0 * RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 8.0, G: 10.0, B: 12.0\n\njulia> RGB(4f0, 5f0, 6f0) * 2.0 == c\ntrue\n\njulia> c = 2.0 * RGB(4.0, 5.0, 6.0)\nRGB color with eltype Float64\nR: 8.0, G: 10.0, B: 12.0\n\njulia> RGB(4.0, 5.0, 6.0) * 2.0 == c\ntrue\n\nNote that the eltype of RGB is mantained.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:+-Tuple{Point, Vec}","page":"Private API","title":"Base.:+","text":"+(p::Point, v::Vec)\n\nReturn the elementwise sum between a Point and a Vec as an instance of Point.\n\nExamples\n\njulia> Point(1, 2, 3) + Vec(4, 5, 6)\nPoint with eltype Float32\nx = 5.0, y = 7.0, z = 9.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:+-Tuple{RGB, RGB}","page":"Private API","title":"Base.:+","text":"+(c1::RGB, c2::RGB)\n\nReturn the elementwise sum of two colors.\n\nExamples\n\njulia> RGB(1f0, 2f0, 3f0) + RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 5.0, G: 7.0, B: 9.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:--Tuple{Point, Point}","page":"Private API","title":"Base.:-","text":"-(p1::Point, p2::Point)\n\nReturn the elementwise difference of two Point as an instance of Vec.\n\nExamples\n\njulia> Point(1, 2, 3) - Point(4, 5, 6)\nVec with eltype Float32\nx = -3.0, y = -3.0, z = -3.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:--Tuple{Point, Vec}","page":"Private API","title":"Base.:-","text":"-(p::Point, v::Vec)\n\nReturn the elementwise difference between a Point and a Vec as an instance of Point.\n\nExamples\n\njulia> Point(1, 2, 3) - Vec(4, 5, 6)\nPoint with eltype Float32\nx = -3.0, y = -3.0, z = -3.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:--Tuple{RGB, RGB}","page":"Private API","title":"Base.:-","text":"-(c1::RGB, c2::RGB)\n\nReturn the elementwise difference of two colors.\n\nExamples\n\njulia> RGB(1f0, 2f0, 3f0) - RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: -3.0, G: -3.0, B: -3.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:==-Tuple{RGB, RGB}","page":"Private API","title":"Base.:==","text":"==(c1::RGB, c2::RGB)\n\nElementwise comparison of two colors.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:≈-Tuple{HitRecord, HitRecord}","page":"Private API","title":"Base.:≈","text":"≈(hr1::HitRecord, hr2::HitRecord)\n\nCheck if two HitRecord represent the same hit event or not.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:≈-Tuple{Point, Point}","page":"Private API","title":"Base.:≈","text":"≈(p1::Point, p2::Point)\n\nCheck if two points are close.\n\nExamples\n\njulia> p = Point(1, 2, 3);\n\njulia> p ≈ Point(1, 2, 3)\ntrue\n\njulia> p ≈ Point(0, 0, 0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:≈-Tuple{RGB, RGB}","page":"Private API","title":"Base.:≈","text":"≈(c1::RGB, c2::RGB)\n\nCheck if two colors are close.\n\nExamples\n\njulia> c = RGB(1f0, 2f0, 3f0) * RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 4.0, G: 10.0, B: 18.0\n\njulia> c ≈ RGB(4f0, 10f0, 18f0)\ntrue\n\njulia> c ≈ RGB(0f0, 0f0, 0f0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.:≈-Tuple{Ray, Ray}","page":"Private API","title":"Base.:≈","text":"≈(r1::Ray, r2::Ray)\n\nCheck if two Ray represent the same ray of light or not.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.Filesystem.cp-Union{Tuple{Float32, Float32}, Tuple{N}} where N","page":"Private API","title":"Base.Filesystem.cp","text":"(cp::CheckeredPigment{N})(u::Float32, v::Float32) where {N}\n\nReturn the color of the surface in the given point (uv).\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.intersect-Tuple{Shape, Shape}","page":"Private API","title":"Base.intersect","text":"intersect(s1::Shape, s2::Shape; transformation::Transformation = Transformation())\n\nConstruct a IntersectionCSG with the given shapes as rbranch and lbranch repectively.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.intersect-Tuple{Shape, Vararg{Shape}}","page":"Private API","title":"Base.intersect","text":"intersect(s::Shape, ss::Shape...; transformation::Transformation = Transformation())\n\nConstruct a IntersectionCSG binary tree, by recursively calling intersect(::Shape, ::Shape).\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.inv-Tuple{Transformation}","page":"Private API","title":"Base.inv","text":"inv(t::Transformation)\n\nReturn the inverse Transformation.\n\nReturns a Transformation which has the m and invm fields swapped.\n\nExamples\n\n```jldoctest; setup = :(using LinearAlgebra: Diagonal) julia> t = Transformation(Diagonal([1, 2, 3, 1])) 4x4 Transformation: Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0  0.0f0  0.0f0  2.0f0  0.0f0  0.0f0  0.0f0  0.0f0  3.0f0  0.0f0  0.0f0  0.0f0  0.0f0  1.0f0 Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0         0.0f0  0.0f0  0.5f0  0.0f0         0.0f0  0.0f0  0.0f0  0.33333334f0  0.0f0  0.0f0  0.0f0  0.0f0         1.0f0\n\njulia> inv(t) 4x4 Transformation: Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0         0.0f0  0.0f0  0.5f0  0.0f0         0.0f0  0.0f0  0.0f0  0.33333334f0  0.0f0  0.0f0  0.0f0  0.0f0         1.0f0 Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0  0.0f0  0.0f0  2.0f0  0.0f0  0.0f0  0.0f0  0.0f0  3.0f0  0.0f0  0.0f0  0.0f0  0.0f0  1.0f0  ```\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.setdiff-Tuple{Shape, Shape}","page":"Private API","title":"Base.setdiff","text":"setdiff(s1::Shape, s2::Shape); transformation::Transformation = Transformation())\n\nConstruct a DiffCSG with the given shapes as rbranch and lbranch repectively.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.setdiff-Tuple{Shape, Vararg{Shape}}","page":"Private API","title":"Base.setdiff","text":"setdiff(s::Shape, ss::Shape...); transformation::Transformation = Transformation())\n\nConstruct a DiffCSG between s and fuse(ss...).\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.union-Tuple{Shape, Shape}","page":"Private API","title":"Base.union","text":"union(s1::Shape, s2::Shape; transformation::Transformation = Transformation())\n\nConstruct a UnionCSG with the given shapes as rbranch and lbranch repectively.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Base.union-Tuple{Shape, Vararg{Shape}}","page":"Private API","title":"Base.union","text":"union(s::Shape, ss::Shape...; transformation::Transformation = Transformation())\n\nConstruct a UnionCSG binary tree, by recursively calling union(::Shape, ::Shape).\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Raytracer.normalized_dot-Tuple{AbstractVector, AbstractVector}","page":"Private API","title":"Raytracer.normalized_dot","text":"normalized_dot(v1::AbstractVector, v2::AbstractVector)\n\nNormalize v1 and v2 and then compute the dot product.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Raytracer.scatter_ray-Tuple{DiffuseBRDF, PCG, Vec, Point, Normal, Int64}","page":"Private API","title":"Raytracer.scatter_ray","text":"scatter_ray(::DiffuseBRDF, pcg::PCG, incoming_dir::Vec, interaction_point::Point, normal::Normal, depth::Int)\n\nScatter a ray on the surface.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Raytracer.scatter_ray-Tuple{SpecularBRDF, PCG, Vec, Point, Normal, Int64}","page":"Private API","title":"Raytracer.scatter_ray","text":"scatter_ray(::SpecularBRDF, pcg::PCG, incoming_dir::Vec, interaction_point::Point, normal::Normal, depth::Int)\n\nScatter a ray on the surface.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Raytracer.valid_intervals-Tuple{Vector}","page":"Private API","title":"Raytracer.valid_intervals","text":"valid_intervals(ts::Vector)\n\nReturn a Vector of Intervals describing what ranges of the t parameter are internal to the shape, given its ts hit parameters.\n\nFor the function to work correctly ts must be of even length.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-api/#Index","page":"Private API","title":"Index","text":"","category":"section"},{"location":"devs/private-api/","page":"Private API","title":"Private API","text":"Modules = [Raytracer]\nPages   = [\"private-api.md\"]","category":"page"},{"location":"quickstart/scenelang/#Basic-SceneLang-usage","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"","category":"section"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"As it has been seen in the Basic CLI tool usage section, scenes can be rendered by the render command starting from a SceneLang script.","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"SceneLang is a custom Domain-Specific Language (DSL) conceived to allow an easy description of scenes that can be rendered by Raytracer. A SceneLang script must be stored in a file with the .sl extension and must contain a series of instructions aimed at constructing an image.","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"tip: Tip\nIf you use Visual Studio Code, you can install the SceneLang Highlighter extension, which add support for syntax highlighting.","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"We refer to the SceneLang documentation for an in-depth explanation on how the language works, but a simple example of how the scripting language works is the script that generates the Raytracer.jl logo. This script can be found in examples/logo.sl.","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"# Raytracer.jl\n# Raytracing for the generation of photorealistic images in Julia\n# Copyright (c) 2021 Samuele Colombo, Paolo Galli\n\n# Raytracer.jl logo\n\n# Set variables using symbolic constructors\nSET\n\twhite  <1.000,1.000,1.000>\n\tred    <0.800,0.235,0.204>\n\tgreen  <0.212,0.592,0.145>\n\tpurple <0.580,0.345,0.694>\n\nSET\n\tbackground <1,1,1>\n\tambient_ratio 0\n\nSET light_multiplier 5e1\n\n# Declare the needed Raytracer settings\n# Object are constructed in-place using named constructors\nUSING\n\tCamera.Perspective(.transformation TRANSLATE(.X -3))\n\tImage(500, 500)\n\tRenderer.PointLight(.ambient_color $background * ambient_ratio$, .background_color background)\n\tTracer(.samples_per_side 8)\n\n# Set variables using named constructors and keyword arguments\nSET\n\tred_material    Material(.brdf Brdf.Diffuse(.pigment Pigment.Uniform(red)))\n\tgreen_material  Material(.brdf Brdf.Diffuse(.pigment Pigment.Uniform(green)))\n\tpurple_material Material(.brdf Brdf.Diffuse(.pigment Pigment.Uniform(purple)))\n\nSET\n\toffset 1.5\n\n# These svariables are constructed by referring\n# to previously declared variables and through\n# mathematical expressions surrounded by `$`\nSET\n\tll_sphere    Shape.Sphere  (.material red_material,    .transformation TRANSLATE(.Y $ offset * 3/4$, .Z $-offset/2$))\n\tlr_cylinder  Shape.Cylinder(.material purple_material, .transformation TRANSLATE(.Y $-offset * 3/4$, .Z $-offset/2$) * SCALE 1.5)\n\tuc_cube      Shape.Cube    (.material green_material,  .transformation TRANSLATE(.Z $offset$) * SCALE 1.5)\n\nSET\n\tlight    Light(.color $white * light_multiplier$, .position {-2, 0, 0}, .linear_radius 1)\n\n# Spawns the given shapes and lights into the world,\n# This means they will be rendered by Raytracer\n# If a shape or light is not spawned it is ignored in the rendering process.\nSPAWN\n\tll_sphere\n\tuc_cube\n\tlr_cylinder\n\tlight","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"To render this script one must invoke, from the root directory of Raytracer, the following command","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"julia raytracer_cli.jl render image examples/logo.sl --with-tonemapping -O \"logo\" -e \"png\" -l 1","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"which results in the logo.pfm and logo.png files being created.","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"It is possible to alter the properties of this image using the --var option of the CLI tool. For example one can modify the script so that the offset between the shapes is a little greater and the background is black then we can override the values declared in the script by invoking the following command","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"julia raytracer_cli.jl render image examples/logo.sl --var \"offset 2, background <0,0,0>\" --with-tonemapping -O \"logo\" -e \"png\" -l 0.5","category":"page"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"The examples folder is full of various scripts that explore the capabilitiers of the Raytracer CLI tool and SceneLang. We suggest to take a look at them and try and execute them with various settings to get a feel on how to use these powerful features.","category":"page"},{"location":"cli/#cli_tool","page":"CLI tool","title":"CLI tool","text":"","category":"section"},{"location":"cli/#Contents","page":"CLI tool","title":"Contents","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"Pages = [\"cli.md\"]\nDepth = 3","category":"page"},{"location":"cli/#Description","page":"CLI tool","title":"Description","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"The CLI tool is named raytracer_cli.jl and is placed in the root of the repository. Thanks to the simple usage and the extended help messages, it makes possible the use of this package's high-level features to those who do not know Julia lang. For this purpose, you can use the CLI tool with SceneLang, a simple DSL with which to define the scenes to be rendered.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"This CLI tool recalls functions already present in the Raytracer.jl module, so is possible to run almost all these commands also from the REPL, by calling the same functions called by the tool.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nFor now, the command render animation is available only with the CLI tool.","category":"page"},{"location":"cli/#Installation","page":"CLI tool","title":"Installation","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"See CLI tool installation.","category":"page"},{"location":"cli/#Usage","page":"CLI tool","title":"Usage","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nYou must call this tool from the repo main folder! It will not work if called by another folder.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"The CLI tool is based on a series of commands, in a similar way to the git and docker CLI tools. The menu tree is:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"raytracer_cli.jl\nrender\nimage\nanimation\ntonemapping\ndocs","category":"page"},{"location":"cli/#raytracer_cli","page":"CLI tool","title":"raytracer_cli.jl","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl [--version] [-h] {render|tonemapping|docs}\n\nRaytracing for the generation of photorealistic images in Julia.\n\ncommands:\n  render       render an image from a SceneLang script\n  tonemapping  apply tone mapping to a pfm image and save it to file\n  docs         show documentation links\n\noptional arguments:\n  --version    show version information and exit\n  -h, --help   show this help message and exit","category":"page"},{"location":"cli/#raytracer_cli_render","page":"CLI tool","title":"raytracer_cli.jl render","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl render [--version] [-h] {image|animation}\n\nRender an image from a SceneLang script.\n\ncommands:\n  image       render an image from a SceneLang script\n  animation   create an animation as mp4 video from a SceneLang script\n              (require ffmpeg)\n\noptional arguments:\n  --version   show version information and exit\n  -h, --help  show this help message and exit","category":"page"},{"location":"cli/#raytracer_cli_render_image","page":"CLI tool","title":"raytracer_cli.jl render image","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl render image [-O OUTPUT-FILE] [-t TIME]\n                        [-v VARS] [-f] [--with-tonemapping]\n                        [-e LDR-EXTENSION] [-a ALPHA] [-g GAMMA]\n                        [-l LUMINOSITY] [--version] [-h] input-script\n\nRender an image from a SceneLang script.\n\npositional arguments:\n  input-script          path to the input SceneLang script\n\noptional arguments:\n  -O, --output-file OUTPUT-FILE\n                        output image name, without extension (default:\n                        \"out\")\n  -t, --time TIME       time for script (type: Float32, default: 0.0)\n  -v, --vars VARS       add variables using the SET SceneLang syntax;\n                        multiple variables separated with commas\n                        (e.g., \"a_variable 2, a_material Material()\")\n                        (default: \"\")\n  -f, --force           force overwrite\n  --version             show version information and exit\n  -h, --help            show this help message and exit\n\ntonemapping settings:\n  --with-tonemapping    apply the tone mapping process\n  -e, --ldr-extension LDR-EXTENSION\n                        only with \"--with-tonemapping\": extension of\n                        the generated ldr image (e.g., \"jpg\" or \"png\")\n                        (default: \"jpg\")\n  -a, --alpha ALPHA     only with \"--with-tonemapping\": scaling factor\n                        for the normalization process (type: Float32,\n                        default: 0.75)\n  -g, --gamma GAMMA     only with \"--with-tonemapping\": gamma value\n                        for the tone mapping process (type: Float32,\n                        default: 1.0)\n  -l, --luminosity LUMINOSITY\n                        only with \"--with-tonemapping\": luminosity for\n                        the tone mapping process (-1 = auto) (type:\n                        Float32, default: -1.0)","category":"page"},{"location":"cli/#raytracer_cli_render_animation","page":"CLI tool","title":"raytracer_cli.jl render animation","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"This is an advanced function that requires ffmpeg to be installed on the local machine and to be in the PATH. It generates an H.264 mp4 video containing the animation.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nFor now, the generation of animations is available only with the CLI tool.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl render animation {--delta-t DELTA-T |\n                        --n-frames N-FRAMES} [-F OUTPUT-DIR]\n                        [-O OUTPUT-FILE] [-v VARS] [-f] [-r FPS]\n                        [-e LDR-EXTENSION] [-a ALPHA] [-g GAMMA]\n                        [-l LUMINOSITY] [--version] [-h] input-script\n                        time-limits\n\nCreate an animation as mp4 video from a SceneLang script (require\nffmpeg).\n\npositional arguments:\n  input-script          path to the input SceneLang script\n  time-limits           time limits as \"t_start:t_end\" (e.g., \"0:10\")\n\noptional arguments:\n  -F, --output-dir OUTPUT-DIR\n                        output directory (default: \"animation\")\n  -O, --output-file OUTPUT-FILE\n                        name of saved frames and video, without\n                        extension (default: \"out\")\n  -v, --vars VARS       add variables using the SET SceneLang syntax;\n                        multiple variables separated with commas\n                        (e.g., \"a_variable 2, a_material Material()\")\n                        (default: \"\")\n  -f, --force           force overwrite\n  -r, --fps FPS         FPS (frame-per-second) of the output video\n                        (type: Int64, default: 15)\n  --version             show version information and exit\n  -h, --help            show this help message and exit\n\ndelta animation (mutually exclusive):\n  --delta-t DELTA-T     proceed from \"t_start\" to \"t_end\" in steps of\n                        \"delta-t\" (type: Float32)\n  --n-frames N-FRAMES   number of frames between \"t_start\" and \"t_end\"\n                        (type: Int64)\n\ntonemapping settings:\n  -e, --ldr-extension LDR-EXTENSION\n                        extension of the generated ldr image (e.g.,\n                        \"jpg\" or \"png\") (default: \"jpg\")\n  -a, --alpha ALPHA     scaling factor for the normalization process\n                        (type: Float32, default: 0.75)\n  -g, --gamma GAMMA     gamma value for the tone mapping process\n                        (type: Float32, default: 1.0)\n  -l, --luminosity LUMINOSITY\n                        luminosity for the tone mapping process (-1 =\n                        auto) (type: Float32, default: -1.0)","category":"page"},{"location":"cli/#raytracer_cli_tonemapping","page":"CLI tool","title":"raytracer_cli.jl tonemapping","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nWe support as output image type all the formats supported by the packages ImageIO, ImageMagick and QuartzImageIO, including: jpg, png, tiff, ppm, bmp, gif, ...","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl tonemapping [-f] [-a ALPHA] [-g GAMMA]\n                        [-l LUMINOSITY] [--version] [-h] input-file\n                        output-file\n\nApply tone mapping to a pfm image and save it to file.\n\npositional arguments:\n  input-file            path to input file, it must be a PFM file\n  output-file           output file name\n\noptional arguments:\n  -f, --force           force overwrite\n  --version             show version information and exit\n  -h, --help            show this help message and exit\n\ntonemapping settings:\n  -a, --alpha ALPHA     scaling factor for the normalization process\n                        (type: Float32, default: 0.5)\n  -g, --gamma GAMMA     gamma value for the tone mapping process\n                        (type: Float32, default: 1.0)\n  -l, --luminosity LUMINOSITY\n                        luminosity for the tone mapping process (type:\n                        Union{Nothing, Float32})","category":"page"},{"location":"cli/#raytracer_cli_docs","page":"CLI tool","title":"raytracer_cli.jl docs","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl docs [--dev] [--version] [-h]\n\nShow documentation links.\n\noptional arguments:\n  --dev       documentation of the dev version\n  --version   show version information and exit\n  -h, --help  show this help message and exit","category":"page"},{"location":"cli/#Multithreading","page":"CLI tool","title":"Multithreading","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"To enable multithreading, e.g. use 8 threads, add -t num_threads after the julia command:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia -t 8 raytracer_cli.jl render image input-script","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"Here all the examples use only one thread, but you can specify the number of threads you prefer: Raytracer.jl is optimized to run with multiple threads.","category":"page"},{"location":"cli/#Examples","page":"CLI tool","title":"Examples","text":"","category":"section"},{"location":"cli/#Tone-mapping","page":"CLI tool","title":"Tone mapping","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can use the tonemapping command to apply the tone mapping process to a pfm image. For example, you can use the following command to convert the image test/memorial.pfm into a jpg image:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl tonemapping test/memorial.pfm memorial.jpg","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"(Image: )","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can also convert to a png image:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl tonemapping test/memorial.pfm memorial.png","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"or any other format supported (see here).","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can also change the default values of alpha, gamma and luminosity to obtain a better tone mapping, according to your source image and the desired final effect:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl tonemapping --alpha 0.2 --gamma 1.8 --luminosity 2 test/memorial.pfm memorial.jpg","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"(Image: )","category":"page"},{"location":"cli/#Render-an-image","page":"CLI tool","title":"Render an image","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can use the render image command to render an image from a SceneLang script:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl render image examples/logo.sl -O logo","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"This will generate only the logo.pfm HDR image. Then you can use the tonemapping command to generate the LDR image.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"Otherwise, you can apply the tone mapping immediately after the rendering using this command with the option --with-tonemapping. In this way you can see the generated image immediately. It creates two files: logo.pfm (the HDR image) and logo.jpg (the LDR image).","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl render image examples/logo.sl -O logo --with-tonemapping","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"(Image: )","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can change the output file name, the LDR extension, and other rendering parameters using the command line options.","category":"page"},{"location":"cli/#Generate-an-animation","page":"CLI tool","title":"Generate an animation","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"To create an animation, use the command render animation:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl render animation examples/demo/animation.sl 0:360 --delta-t 1 --fps 60 --luminosity 0.08","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"<video autoplay=\"\" controls=\"\" loop=\"\" width=\"540\" height=\"540\">\n  <source src=\"https://i.imgur.com/KOTcQ4E.mp4\">\n</video>","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"It creates a new folder animation with the video out.mp4 and all the frames in jpeg format.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can change the output folder and file name, the LDR frame extension, and other rendering and animation parameters using the command line options.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"An important argument of the render animation command is time_limits, as it sets the TIME setting for the rendered scene, which can used in a SceneLang script as described here.","category":"page"},{"location":"quickstart/api/#Basic-API-usage","page":"Basic API usage","title":"Basic API usage","text":"","category":"section"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Using the API, you can interact directly with the renderer.","category":"page"},{"location":"quickstart/api/#Image-generation","page":"Basic API usage","title":"Image generation","text":"","category":"section"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Let's assume we want to render a sphere in the origin using a flat renderer.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"First, import the module:","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"using Raytracer","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"We need to create the scene. All the shapes of the image must be included in a World instance.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"world = World()","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Then, we need to create the shape and add it to world. Here we create a Sphere with radius 2 in the origin, with a DiffuseBRDF. The pigment of the BRDF is a CheckeredPigment with a RED and GREEN pattern.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"sphere = Sphere(\n    transformation = scaling(2),\n    material = Material(\n        brdf = DiffuseBRDF(\n            pigment = CheckeredPigment{8}(\n                color_on = RED,\n                color_off = GREEN\n            )\n        )\n    )\n)\nappend!(world, [sphere])","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Now we can choose the renderer. For this example, we use a FlatRenderer.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"renderer = FlatRenderer(world)","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Now we need to create a Camera, representing an observer. For this example, we use a PerspectiveCamera positioned at the point (-1000) and looking the origin.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"camera = PerspectiveCamera(\n    aspect_ratio = 16//9,\n    screen_distance = 3,\n    transformation = translation(-10,0,0)\n)","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Now we can create the ImageTracer, with the observer informations, an empty FHD (i.e. with resolution of 1920x1080) HdrImage and no antialiasing:","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"image = HdrImage(1920, 1080)\nimage_tracer = ImageTracer(image, camera)","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Now we can render the image, using the function fire_all_rays!:","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"julia> fire_all_rays!(image_tracer, renderer)\nProgress: 100%|███████████████████████████████████████| Time: 0:00:03","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Finally, we can save the generated HDR image. Remember to use permutedims when saving the image, otherwise you will have an output image reflected along the diagonal!","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"julia> save(\"myimage.pfm\", permutedims(image_tracer.image.pixel_matrix))\n24883218","category":"page"},{"location":"quickstart/api/#Tone-mapping","page":"Basic API usage","title":"Tone mapping","text":"","category":"section"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"We can apply tone mapping to an HDR image to get a LDR image, for example a jpeg or png file.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"julia> tonemapping(\"myimage.pfm\", \"myimage.jpg\", 0.5f0, 1f0)\n\n-> TONE MAPPING PROCESS\nLoading input file 'myimage.pfm'... done!\nApplying tone mapping...  done!\nSaving final image to 'myimage.jpg'... done!","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"The final image is:","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"(Image: )","category":"page"},{"location":"api/low-level/#low_level_api","page":"Low-level API","title":"Low-level API","text":"","category":"section"},{"location":"api/low-level/#Contents","page":"Low-level API","title":"Contents","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Pages = [\"low-level.md\"]\nDepth = 3","category":"page"},{"location":"api/low-level/#Colors-and-images","page":"Low-level API","title":"Colors and images","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"We use the ColorTypes.RGB from ColorTypes.jl. Our package extends the methods of this type, for example by implementing sum and difference between two color instances. We also add iterability and broadcasting.","category":"page"},{"location":"api/low-level/#Colors","page":"Low-level API","title":"Colors","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"colors.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.BLACK","page":"Low-level API","title":"Raytracer.BLACK","text":"BLACK\n\nA RGB{Float32} representing a black color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.BLUE","page":"Low-level API","title":"Raytracer.BLUE","text":"BLUE\n\nA RGB{Float32} representing a blue color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.CYAN","page":"Low-level API","title":"Raytracer.CYAN","text":"CYAN\n\nA RGB{Float32} representing a cyan color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.GREEN","page":"Low-level API","title":"Raytracer.GREEN","text":"GREEN\n\nA RGB{Float32} representing a green color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.MAGENTA","page":"Low-level API","title":"Raytracer.MAGENTA","text":"MAGENTA\n\nA RGB{Float32} representing a magenta color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.RED","page":"Low-level API","title":"Raytracer.RED","text":"RED\n\nA RGB{Float32} representing a red color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.WHITE","page":"Low-level API","title":"Raytracer.WHITE","text":"WHITE\n\nA RGB{Float32} representing a white color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.YELLOW","page":"Low-level API","title":"Raytracer.YELLOW","text":"YELLOW\n\nA RGB{Float32} representing a yellow color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Base.Math.clamp-Union{Tuple{RGB{T}}, Tuple{T}} where T","page":"Low-level API","title":"Base.Math.clamp","text":"clamp(c::RGB)\n\nReturn a clamped RGB color, with each component x obtained with the formula:\n\nfracx1 + x\n\nExamples\n\njulia> clamp(RGB(1f0, 2f0, 3f0))\nRGB color with eltype Float32\nR: 0.5, G: 0.6666667, B: 0.75\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.luminosity-Tuple{RGB}","page":"Low-level API","title":"Raytracer.luminosity","text":"luminosity(c::RGB)\n\nReturn the mean value between the maximum component and the minumum component of a color:\n\nfracmathrmmax(c) + mathrmmin(c)2\n\nExamples\n\njulia> luminosity(RGB(1f0, 2f0, 3f0))\n2.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.γ_correction-Union{Tuple{T}, Tuple{RGB{T}, Float32}} where T","page":"Low-level API","title":"Raytracer.γ_correction","text":"γ_correction(c::RGB, γ::Float32)\n\nReturn a RGB color, with each component x corrected with the formula:\n\nx^1  gamma\n\nExamples\n\njulia> c = RGB(1f0, 2f0, 3f0);\n\njulia> γ_correction(c, 1f0)\nRGB color with eltype Float32\nR: 1.0, G: 2.0, B: 3.0\n\njulia> γ_correction(c, 0.8f0)\nRGB color with eltype Float32\nR: 1.0, G: 2.3784142, B: 3.948222\n\njulia> γ_correction(c, 2.4f0)\nRGB color with eltype Float32\nR: 1.0, G: 1.3348398, B: 1.580522\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#HDR-image","page":"Low-level API","title":"HDR image","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"hdrimage.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.HdrImage","page":"Low-level API","title":"Raytracer.HdrImage","text":"HdrImage\n\nWrapper of a Matrix of elements of type RGB{Float32}, used to represent an image in hdr format.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.HdrImage-Tuple{AbstractVector, Integer, Integer}","page":"Low-level API","title":"Raytracer.HdrImage","text":"HdrImage(arr::AbstractArray{<:Any, 1}, im_width::Integer, im_height::Integer)\nHdrImage(arr::AbstractArray{<:Any, 1}, shape)\n\nConstruct an HdrImage wrapping a matrix obtained from reshape.\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> HdrImage(arr, 3, 2)\n3x2 HdrImage:\n (1.0 2.0 3.0)  (10.0 11.0 12.0)\n (4.0 5.0 6.0)  (13.0 14.0 15.0)\n (7.0 8.0 9.0)  (16.0 17.0 18.0)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.HdrImage-Tuple{Integer, Integer}","page":"Low-level API","title":"Raytracer.HdrImage","text":"HdrImage(img_width::Integer, img_height::Integer)\n\nConstruct an HdrImage wrapping a zero-initialized matrix of size (img_width, img_height).\n\nExamples\n\njulia> HdrImage(3, 2)\n3x2 HdrImage:\n (0.0 0.0 0.0)  (0.0 0.0 0.0)\n (0.0 0.0 0.0)  (0.0 0.0 0.0)\n (0.0 0.0 0.0)  (0.0 0.0 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.HdrImage-Tuple{Matrix{RGB{Float32}}}","page":"Low-level API","title":"Raytracer.HdrImage","text":"HdrImage(pixel_matrix::Matrix{RGB{Float32}})\n\nConstructor for a HdrImage instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Base.Math.clamp-Tuple{HdrImage}","page":"Low-level API","title":"Base.Math.clamp","text":"clamp(image::HdrImage)\n\nAdjust the color levels of the brightest pixels of a HdrImage, by applying the clamp(::RGB) function to each pixel.\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> clamp(HdrImage(arr, 3, 2))\n3x2 HdrImage:\n (0.5 0.6666667 0.75)        (0.90909094 0.9166667 0.9230769)\n (0.8 0.8333333 0.85714287)  (0.9285714 0.93333334 0.9375)\n (0.875 0.8888889 0.9)       (0.9411765 0.9444444 0.94736844)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#LinearAlgebra.normalize-Tuple{HdrImage, Float32}","page":"Low-level API","title":"LinearAlgebra.normalize","text":"normalize(image::HdrImage, α::Float32\n          ; luminosity::Float32 = average_luminosity(image))\n\nNormalize a HdrImage for a given luminosity.\n\nIf the luminosity parameter is not specified, the image will be normalized according to the result of luminosity(::HdrImage; ::Float32).\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> normalize(HdrImage(arr, 3, 2), 1f0)\n3x2 HdrImage:\n (0.12976472 0.25952944 0.38929415)  (1.2976472 1.4274119 1.5571766)\n (0.5190589 0.6488236 0.7785883)     (1.6869414 1.8167061 1.9464709)\n (0.90835303 1.0381178 1.1678824)    (2.0762355 2.2060003 2.335765)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.luminosity-Tuple{HdrImage}","page":"Low-level API","title":"Raytracer.luminosity","text":"luminosity(image::HdrImage; δ::Float32 = eps(Float32))\n\nReturn the average luminosity an HdrImage as the logaritmic mean of the luminosity(::RGB) l_i of each pixel:\n\nleft l right = 10^fracsum_i log_10(delta + l_i)N\n\nThe parameter δ avoid singularities for l_i = 0 (black pixels).\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> luminosity(HdrImage(arr, 3, 2))\n7.706255f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.γ_correction-Tuple{HdrImage, Float32}","page":"Low-level API","title":"Raytracer.γ_correction","text":"γ_correction(image::HdrImage, γ::Float32)\n\nCompute the γ correction of a HdrImage, by applying the γ_correction(::RGB, ::Float32) function to each pixel.\n\nBefore calling this function, you should apply a tone-mapping algorithm to the image and be sure that the R, G, and B values of the colors in the image are all in the range 0 1. Use normalize(::HdrImage, ::Float32; ::Float32) and clamp(image::HdrImage) to do this.\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> image = normalize(HdrImage(arr, 3, 2), 1f0) |> clamp;\n\njulia> γ_correction(image, 1f0)\n3x2 HdrImage:\n (0.11485995 0.20605269 0.28021002)  (0.5647722 0.58803856 0.6089437)\n (0.34169766 0.393507 0.43775633)    (0.6278296 0.64497536 0.660611)\n (0.47598794 0.5093512 0.53872037)   (0.67492735 0.6880849 0.7002187)\n\njulia> γ_correction(image, 0.8f0)\n3x2 HdrImage:\n (0.06686684 0.13882665 0.20387058)  (0.48960024 0.51494074 0.53792465)\n (0.26124772 0.31166682 0.35607424)  (0.558859 0.57800144 0.5955692)\n (0.39536202 0.43030033 0.4615346)   (0.6117462 0.6266897 0.64053386)\n\njulia> γ_correction(image, 2.4f0)\n3x2 HdrImage:\n (0.40588558 0.5177947 0.58855206)  (0.7881591 0.8015287 0.8132807)\n (0.63926977 0.6780008 0.7087834)   (0.82369685 0.83299613 0.8413514)\n (0.73394746 0.7549599 0.77280176)  (0.8489011 0.8557578 0.86201346)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Geometry","page":"Low-level API","title":"Geometry","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"geometry.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.NORMAL_X","page":"Low-level API","title":"Raytracer.NORMAL_X","text":"NORMAL_X\n\nA unitary and normalized Normal{true} along the x-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_X_false","page":"Low-level API","title":"Raytracer.NORMAL_X_false","text":"NORMAL_X_false\n\nA unitary and non-normalized Normal{false} along the x-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_Y","page":"Low-level API","title":"Raytracer.NORMAL_Y","text":"NORMAL_Y\n\nA unitary and normalized Normal{true} along the y-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_Y_false","page":"Low-level API","title":"Raytracer.NORMAL_Y_false","text":"NORMAL_Y_false\n\nA unitary and non-normalized Normal{false} along the y-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_Z","page":"Low-level API","title":"Raytracer.NORMAL_Z","text":"NORMAL_Z\n\nA unitary and normalized Normal{true} along the z-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_Z_false","page":"Low-level API","title":"Raytracer.NORMAL_Z_false","text":"NORMAL_Z_false\n\nA unitary and non-normalized Normal{false} along the z-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.ORIGIN","page":"Low-level API","title":"Raytracer.ORIGIN","text":"ORIGIN\n\nA Point representing the origin of the frame of reference.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.VEC_X","page":"Low-level API","title":"Raytracer.VEC_X","text":"VEC_X\n\nA unitary Vec along the x-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.VEC_Y","page":"Low-level API","title":"Raytracer.VEC_Y","text":"VEC_Y\n\nA unitary Vec along the y-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.VEC_Z","page":"Low-level API","title":"Raytracer.VEC_Z","text":"VEC_Z\n\nA unitary Vec along the z-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.Normal","page":"Low-level API","title":"Raytracer.Normal","text":"Normal{V} <: StaticArrays.FieldVector{3, Float32}\n\nA pseudo-vector in 3D space with 3 fields x, y, and z of type Float32. The parameter V tells if the normal is normalized or not.\n\nFor inherited properties and constructors see StaticArrays.FieldVector.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Normal-Tuple{Any, Any, Any}","page":"Low-level API","title":"Raytracer.Normal","text":"Normal(x, y, z)\n\nConstruct a non-normalized Normal{false} with given coordinates. All values are converted in Float32.\n\nExamples\n\njulia> Normal(1.2, 3.3, 5)\nNormal with eltype Float32, not normalized\nx = 1.2, y = 3.3, z = 5.0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Normal-Union{Tuple{Float32, Float32, Float32}, Tuple{V}} where V","page":"Low-level API","title":"Raytracer.Normal","text":"Normal{V}(x::Float32, y::Float32, z::Float32)\n\nConstructor for a Normal instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Point","page":"Low-level API","title":"Raytracer.Point","text":"Point\n\nA point in a 3D space. Implemented as a wrapper struct around a SVector{3, Float32}.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Point-Tuple{AbstractVector}","page":"Low-level API","title":"Raytracer.Point","text":"Point(p::AbstractVector)\n\nConstructor for a Point instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Point-Tuple{Any, Any, Any}","page":"Low-level API","title":"Raytracer.Point","text":"Point(x, y, z)\n\nConstruct a Point with given coordinates. All values are converted in Float32.\n\nExamples\n\njulia> Point(1.2, 3.3, 5)\nPoint with eltype Float32\nx = 1.2, y = 3.3, z = 5.0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Vec","page":"Low-level API","title":"Raytracer.Vec","text":"Vec <: StaticArrays.FieldVector{3, Float32}\n\nA vector in 3D space with 3 fields x, y, and z of type Float32.\n\nFor inherited properties and constructors see StaticArrays.FieldVector.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Vec-Tuple{Float32, Float32, Float32}","page":"Low-level API","title":"Raytracer.Vec","text":"Vec(x::Float32, y::Float32, z::Float32)\n\nConstructor for a Vec instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Vec2D","page":"Low-level API","title":"Raytracer.Vec2D","text":"Vec2D\n\nAlias to SVector{2, Float32}, used for uv mapping on shapes.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Base.convert-Tuple{Type{Vec}, Point}","page":"Low-level API","title":"Base.convert","text":"convert(::Type{Vec}, p::Point)\nconvert(::Type{Normal}, p::Point)\n\nConvert a Point into the specified type (Vec or Normal{false}).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#LinearAlgebra.norm-Tuple{Normal{true}}","page":"Low-level API","title":"LinearAlgebra.norm","text":"norm(n::Normal{true})\n\nCompute the squared norm of a Normal{true}. Since n is already normalized, 1f0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#LinearAlgebra.normalize-Tuple{Normal{false}}","page":"Low-level API","title":"LinearAlgebra.normalize","text":"normalize(n::Normal)\n\nNormalize n and return a Normal{true}. If n is already a Normal{true} instance, no normalization is computed and n is returned.\n\nExamples\n\njulia> n = normalize(Normal(1,2,4))\nNormal with eltype Float32, normalized\nx = 0.21821788, y = 0.43643576, z = 0.8728715\n\njulia> normalize(n)\nNormal with eltype Float32, normalized\nx = 0.21821788, y = 0.43643576, z = 0.8728715\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.create_onb_from_z-Tuple{Normal}","page":"Low-level API","title":"Raytracer.create_onb_from_z","text":"create_onb_from_z(input_normal::Normal)\n\nCreate an orthonormal base from a input Normal representing the z-axis using the Duff et al. 2017 algorithm.\n\nExamples\n\njulia> n = Normal(0,0,5);\n\njulia> nn = normalize(Normal(0,0,5));\n\njulia> create_onb_from_z(n)\n(Vec(1.0, -0.0, -0.0), Vec(-0.0, 1.0, -0.0), Vec(0.0, 0.0, 1.0))\n\njulia> create_onb_from_z(nn)\n(Vec(1.0, -0.0, -0.0), Vec(-0.0, 1.0, -0.0), Vec(0.0, 0.0, 1.0))\n\nNote that create_onb_from_z(n) and create_onb_from_z(nn) give the same result.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.norm²-Tuple{Normal{false}}","page":"Low-level API","title":"Raytracer.norm²","text":"norm²(n::Normal)\n\nCompute the squared norm of a Normal. If n is a Normal{true} instance then 1f0 is returned.\n\nExamples\n\njulia> n = Normal(1, 2, 3);\n\njulia> norm²(n)\n14.0f0\n\njulia> norm²(normalize(n))\n1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.norm²-Tuple{Vec}","page":"Low-level API","title":"Raytracer.norm²","text":"norm²(v::Vec)\n\nCompute the squared norm of a Vec.\n\nExamples\n\njulia> norm²(Vec(1, 2, 3))\n14.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Transformations","page":"Low-level API","title":"Transformations","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"transformations.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.Transformation","page":"Low-level API","title":"Raytracer.Transformation","text":"Transformation\n\nA wrapper around two 4x4 matrices representing a transformation for Vec, Normal, and Point instances.\n\nA 4x4 matrix is needed to use the properties of homogeneous coordinates in 3D space. Storing the inverse of the transformation significantly increases performance at the cost of memory space.\n\nFields\n\nm::SMatrix{4, 4, Float32}: the homogeneous matrix representation of the transformation.\ninvm::SMatrix{4, 4, Float32}: the homogeneous matrix representation of the inverse transformation.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Transformation-Tuple{AbstractMatrix}","page":"Low-level API","title":"Raytracer.Transformation","text":"Transformation(m::AbstractMatrix)\nTransformation(m::AbstractMatrix, invm::AbstractMatrix)\n\nConstruct a Transformation instance from m and invm. The elements of the matrix will be casted to Float32.\n\nIf any argument is an AbstractMatrix, it will be implicitly casted to a StaticArrays.SMatrix to increase performance.\n\nExamples\n\njulia> Transformation(StaticArrays.SMatrix{4,4}([1 0 0 0; 0 2 0 0; 0 0 4 0; 0 0 0 1]))\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  4.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0   0.0f0\n 0.0f0  0.5f0  0.0f0   0.0f0\n 0.0f0  0.0f0  0.25f0  0.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\njulia> Transformation([1 0 0 0; 0 2 0 0; 0 0 4 0; 0 0 0 1])\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  4.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0   0.0f0\n 0.0f0  0.5f0  0.0f0   0.0f0\n 0.0f0  0.0f0  0.25f0  0.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\njulia> Transformation(LinearAlgebra.Diagonal([1,2,4,1]))\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  4.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0   0.0f0\n 0.0f0  0.5f0  0.0f0   0.0f0\n 0.0f0  0.0f0  0.25f0  0.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Transformation-Tuple{StaticArrays.SMatrix{4, 4, Float32}, StaticArrays.SMatrix{4, 4, Float32}}","page":"Low-level API","title":"Raytracer.Transformation","text":"Transformation(m::SMatrix{4, 4, Float32} = SMatrix{4, 4, Float32}(I(4)),\n               invm::SMatrix{4, 4, Float32} = inv(m))\n\nConstructor for a Transformation instance.\n\nIf no parameter is specified, then an identity transformation is returned. If only the direct matrix is specified, then the inverse matrix is automatically computed.\n\nExamples\n\njulia> Transformation()\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  1.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  1.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  1.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  1.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.isconsistent-Tuple{Transformation}","page":"Low-level API","title":"Raytracer.isconsistent","text":"isconsistent(t::Transformation)\n\nReturn true if t.m * t.invm is similar to the identity matrix and so the Transformation is consistent.\n\nMainly used for testing and to verify matrices haven't been mutated.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.rotationX","page":"Low-level API","title":"Raytracer.rotationX","text":"rotationX(θ::Real)\n\nReturn a Transformation that rotates a 3D vector field of the given angle in radians around the X-axis.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> rotationX(π/4)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0          0.0f0         0.0f0\n 0.0f0  0.70710677f0  -0.70710677f0  0.0f0\n 0.0f0  0.70710677f0   0.70710677f0  0.0f0\n 0.0f0  0.0f0          0.0f0         1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0   0.0f0         0.0f0         0.0f0\n 0.0f0   0.70710677f0  0.70710677f0  0.0f0\n 0.0f0  -0.70710677f0  0.70710677f0  0.0f0\n 0.0f0   0.0f0         0.0f0         1.0f0\n\n\n\n\n\n","category":"function"},{"location":"api/low-level/#Raytracer.rotationY","page":"Low-level API","title":"Raytracer.rotationY","text":"rotationY(θ::Real)\n\nReturn a Transformation that rotates a 3D vector field of the given angle in radians around the Y-axis.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> rotationY(π/4)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n  0.70710677f0  0.0f0  0.70710677f0  0.0f0\n  0.0f0         1.0f0  0.0f0         0.0f0\n -0.70710677f0  0.0f0  0.70710677f0  0.0f0\n  0.0f0         0.0f0  0.0f0         1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 0.70710677f0  0.0f0  -0.70710677f0  0.0f0\n 0.0f0         1.0f0   0.0f0         0.0f0\n 0.70710677f0  0.0f0   0.70710677f0  0.0f0\n 0.0f0         0.0f0   0.0f0         1.0f0\n\n\n\n\n\n","category":"function"},{"location":"api/low-level/#Raytracer.rotationZ","page":"Low-level API","title":"Raytracer.rotationZ","text":"rotationZ(θ::Real)\n\nReturn a Transformation that rotates a 3D vector field of the given angle in radians around the Z-axis.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> rotationZ(π/4)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 0.70710677f0  -0.70710677f0  0.0f0  0.0f0\n 0.70710677f0   0.70710677f0  0.0f0  0.0f0\n 0.0f0          0.0f0         1.0f0  0.0f0\n 0.0f0          0.0f0         0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n  0.70710677f0  0.70710677f0  0.0f0  0.0f0\n -0.70710677f0  0.70710677f0  0.0f0  0.0f0\n  0.0f0         0.0f0         1.0f0  0.0f0\n  0.0f0         0.0f0         0.0f0  1.0f0\n\n\n\n\n\n","category":"function"},{"location":"api/low-level/#Raytracer.scaling-Tuple{Real, Real, Real}","page":"Low-level API","title":"Raytracer.scaling","text":"scaling(x::Real, y::Real, z::Real)\nscaling(s::Real)\nscaling(v::AbstractVector)\n\nReturn a Transformation that scales a 3D vector field of a given factor for each axis.\n\nIf a single Real is provided as argument then the scaling is considered uniform. If an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> scaling(1, 2, 3)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  3.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0         0.0f0\n 0.0f0  0.5f0  0.0f0         0.0f0\n 0.0f0  0.0f0  0.33333334f0  0.0f0\n 0.0f0  0.0f0  0.0f0         1.0f0\n\njulia> scaling(2)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 2.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  2.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 0.5f0  0.0f0  0.0f0  0.0f0\n 0.0f0  0.5f0  0.0f0  0.0f0\n 0.0f0  0.0f0  0.5f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\n\njulia> scaling([1, 2, 3])\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  3.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0         0.0f0\n 0.0f0  0.5f0  0.0f0         0.0f0\n 0.0f0  0.0f0  0.33333334f0  0.0f0\n 0.0f0  0.0f0  0.0f0         1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.translation-Tuple{AbstractVector}","page":"Low-level API","title":"Raytracer.translation","text":"translation(v::AbstractVector)\ntranslation(x::Real, y::Real, z::Real)\n\nReturn a Transformation that translates a 3D vector field of the given coordinates.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> translation(1, 2, 3)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  1.0f0\n 0.0f0  1.0f0  0.0f0  2.0f0\n 0.0f0  0.0f0  1.0f0  3.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  -1.0f0\n 0.0f0  1.0f0  0.0f0  -2.0f0\n 0.0f0  0.0f0  1.0f0  -3.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\njulia> translation([1, 2, 3])\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  1.0f0\n 0.0f0  1.0f0  0.0f0  2.0f0\n 0.0f0  0.0f0  1.0f0  3.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  -1.0f0\n 0.0f0  1.0f0  0.0f0  -2.0f0\n 0.0f0  0.0f0  1.0f0  -3.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Ray","page":"Low-level API","title":"Ray","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"ray.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.Ray","page":"Low-level API","title":"Raytracer.Ray","text":"Ray\n\nA ray of light propagating in space.\n\nFields\n\norigin::Point: the (Point) where the ray originated.\ndir::Vec: a (Vec) representing the direction along which this ray propagates.\ntmin::Float32: the minimum distance travelled by the ray is this number times dir.\ntmax::Float32: the maximum distance travelled by the ray is this number times dir.\ndepth::Int: number of times this ray was reflected/refracted.\n\nSee also: Ray(::Float32)\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Ray-Tuple{Float32}","page":"Low-level API","title":"Raytracer.Ray","text":"(r::Ray)(t::Float32)\n\nReturn a Point lying on the given Ray at t.\n\nAn instance of Ray can be called as a function returning a Point given the position parameter t:\n\nmathrmray_origin + mathrmray_direction cdot t\n\nArgument t must be included between r.tmin and r.tmax or be equal to 0. If t is zero, then the returned point is the origin of r.\n\nExamples\n\njulia> ray = Ray(ORIGIN, VEC_X)\nRay\n ↳ origin = Point(0.0, 0.0, 0.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\njulia> ray(5f0)\nPoint with eltype Float32\nx = 5.0, y = 0.0, z = 0.0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Ray-Tuple{Point, Vec, Float32, Float32, Int64}","page":"Low-level API","title":"Raytracer.Ray","text":"Ray(origin::Point, dir::Vec, tmin::Float32, tmax::Float32, depth::Int)\n\nConstructor for a Ray instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Ray-Tuple{Point, Vec}","page":"Low-level API","title":"Raytracer.Ray","text":"Ray(origin::Point, dir::Vec\n    ; tmin::Float32 = 1f-5,\n      tmax::Float32 = Inf32,\n      depth::Int = 0)\n\nConstructor for a Ray instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Cameras","page":"Low-level API","title":"Cameras","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"cameras.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.Camera","page":"Low-level API","title":"Raytracer.Camera","text":"Camera\n\nAn abstract type representing an observer.\n\nSee also: OrthogonalCamera, PerspectiveCamera\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.OrthogonalCamera","page":"Low-level API","title":"Raytracer.OrthogonalCamera","text":"OrthogonalCamera <: Camera\n\nA Camera implementing an orthogonal 3D → 2D projection.\n\nFields\n\naspect_ratio::Float32: defines how larger than the height is the image (16/9, 4/3, ...).\ntransformation::Transformation: define the Transformation applied to the rays generated by the camera.\n\nSee also: fire_ray(::OrthogonalCamera, ::Float32, ::Float32)\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.OrthogonalCamera-Tuple{Float32, Transformation}","page":"Low-level API","title":"Raytracer.OrthogonalCamera","text":"OrthogonalCamera(aspect_ratio::Float32, transformation::Transformation)\n\nConstructor for an OrthogonalCamera instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.OrthogonalCamera-Tuple{}","page":"Low-level API","title":"Raytracer.OrthogonalCamera","text":"OrthogonalCamera(; aspect_ratio::Float32 = 1f0,\n                   transformation::Transformation = Transformation())\n\nKeyword-based constructor for an OrthogonalCamera instance.\n\nIf no parameter is specified, it return a camera with square aspect ratio and an identity transformation.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PerspectiveCamera","page":"Low-level API","title":"Raytracer.PerspectiveCamera","text":"PerspectiveCamera <: Camera\n\nA Camera implementing a perspective 3D → 2D projection.\n\nFields\n\naspect_ratio::Float32: defines how larger than the height is the image (16/9, 4/3, ...).\ntransformation::Transformation: define the Transformation applied to the rays generated by the camera.\nscreen_distance::Float32: tells how much far from the eye of the observer is the screen and it influences the FOV (field-of-view).\n\nSee also: fire_ray(::PerspectiveCamera, ::Float32, ::Float32), aperture_deg\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PerspectiveCamera-Tuple{Float32, Transformation, Float32}","page":"Low-level API","title":"Raytracer.PerspectiveCamera","text":"PerspectiveCamera(aspect_ratio::Float32, transformation::Transformation, screen_distance::Float32)\n\nConstructor for an PerspectiveCamera instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PerspectiveCamera-Tuple{}","page":"Low-level API","title":"Raytracer.PerspectiveCamera","text":"PerspectiveCamera(; aspect_ratio::Float32 = 1f0,\n                    transformation::Transformation = Transformation(),\n                    screen_distance::Float32 = 1f0)\n\nKeyword-based constructor for a PerspectiveCamera instance.\n\nIf no parameter is specified, it return a camera with square aspect ratio, an identity transformation, and a screen distance of 1, giving a FOV of 90°.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.aperture_deg-Tuple{PerspectiveCamera}","page":"Low-level API","title":"Raytracer.aperture_deg","text":"aperture_deg(camera::PerspectiveCamera)\n\nCompute the FOV of the camera in degrees for a PerspectiveCamera.\n\nExamples\n\nFOV for a camera with screen distance of 1 and aspect ratio of 1:\n\njulia> aperture_deg(PerspectiveCamera())\n90.0f0\n\nFOV for a camera with screen distance of 1 and aspect ratio of 16/9:\n\njulia> aperture_deg(PerspectiveCamera(aspect_ratio = 16//9))\n58.715508f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.fire_ray-Tuple{OrthogonalCamera, Float32, Float32}","page":"Low-level API","title":"Raytracer.fire_ray","text":"fire_ray(camera::OrthogonalCamera, u::Float32, v::Float32)\n\nFire a Ray through an OrthogonalCamera at a position (u v) on the screen, using an orthogonal projection.\n\nParameters u and v are bound between 0 and 1:\n\n(0, 1)                            (1, 1)\n    +------------------------------+\n    |                              |\n    |                              |\n    |                              |\n    +------------------------------+\n(0, 0)                            (1, 0)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.fire_ray-Tuple{PerspectiveCamera, Float32, Float32}","page":"Low-level API","title":"Raytracer.fire_ray","text":"fire_ray(camera::PerspectiveCamera, u::Float32, v::Float32)\n\nFire a Ray through a PerspectiveCamera at a position (u v) on the screen, using a perspective projection.\n\nParameters u and v are bound between 0 and 1:\n\n(0, 1)                            (1, 1)\n    +------------------------------+\n    |                              |\n    |                              |\n    |                              |\n    +------------------------------+\n(0, 0)                            (1, 0)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Materials,-BRDF-and-pigments","page":"Low-level API","title":"Materials, BRDF and pigments","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"materials.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.BRDF","page":"Low-level API","title":"Raytracer.BRDF","text":"BRDF\n\nAn abstract type representing a Bidirectional Reflectance Distribution Function.\n\nEach subtype of this type must include a field pigment::Pigment storing the pigment on which the BRDF operates. Each subtype of this type must implement an at(::NewBRDF, ::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D) function, where NewBRDF should be swubstituted with your new type name. This function evaluates the BRDF of a point with given normal, input and output directions and uv coordinates (which are used to evaluate)\n\nSee also: DiffuseBRDF, SpecularBRDF,\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.CheckeredPigment","page":"Low-level API","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment{N} <: Pigment\n\nA checkered Pigment. The number of rows/columns in the checkered pattern is tunable with N, but you cannot have a different number of repetitions along the u/v directions.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.CheckeredPigment-Tuple{}","page":"Low-level API","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment(; N::Int = 2, color_on::RGB{Float32} = WHITE,\n                  color_off::RGB{Float32} = BLACK) where {N}\n\nConstructor for a CheckeredPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.CheckeredPigment-Union{Tuple{RGB{Float32}, RGB{Float32}}, Tuple{N}} where N","page":"Low-level API","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment{N}(color_on::RGB{Float32}, color_off::RGB{Float32}) where {N}\n\nConstructor for a CheckeredPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.CheckeredPigment-Union{Tuple{}, Tuple{N}} where N","page":"Low-level API","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment{N}(; color_on::RGB{Float32} = WHITE,\n                  color_off::RGB{Float32} = BLACK) where {N}\n\nConstructor for a CheckeredPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.DiffuseBRDF","page":"Low-level API","title":"Raytracer.DiffuseBRDF","text":"DiffuseBRDF <: BRDF\n\nA class representing an ideal diffuse BRDF (also called \"Lambertian\").\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.DiffuseBRDF-Tuple{Pigment, Float32}","page":"Low-level API","title":"Raytracer.DiffuseBRDF","text":"DiffuseBRDF(pigment::Pigment, reflectance::Float32)\n\nConstructor for a DiffuseBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.DiffuseBRDF-Tuple{}","page":"Low-level API","title":"Raytracer.DiffuseBRDF","text":"DiffuseBRDF(; pigment::Pigment = UniformPigment(),\n              reflectance::Float32 = 1f0)\n\nConstructor for a DiffuseBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ImagePigment","page":"Low-level API","title":"Raytracer.ImagePigment","text":"ImagePigment <: Pigment\n\nA textured Pigment. The texture is given through a PFM image.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.ImagePigment-Tuple{Float32, Float32}","page":"Low-level API","title":"Raytracer.ImagePigment","text":"(ip::ImagePigment)(u::Float32, v::Float32)\n\nReturn the color of the surface in the given point (uv).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ImagePigment-Tuple{HdrImage}","page":"Low-level API","title":"Raytracer.ImagePigment","text":"ImagePigment(image::HdrImage)\n\nConstructor for a ImagePigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ImagePigment-Tuple{}","page":"Low-level API","title":"Raytracer.ImagePigment","text":"ImagePigment(; image::HdrImage = HdrImage(1, 1))\n\nConstructor for a ImagePigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Material","page":"Low-level API","title":"Raytracer.Material","text":"Material\n\nA material with a brdf::BRDF (BRDF) and and emitted_radiance::Pigment (Pigment).\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Material-Tuple{BRDF, Pigment}","page":"Low-level API","title":"Raytracer.Material","text":"Material(brdf::BRDF, emitted_radiance::Pigment)\n\nConstructor for a Material instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Material-Tuple{}","page":"Low-level API","title":"Raytracer.Material","text":"Material(; brdf::BRDF = DiffuseBRDF(), emitted_radiance::Pigment = UniformPigment(BLACK))\n\nConstructor for a Material instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Pigment","page":"Low-level API","title":"Raytracer.Pigment","text":"Pigment\n\nThis abstract type represents a pigment, i.e., a function that associates a color with each point on a parametric surface (uv).\n\nEach subtype of this type must be a callable like (p::Pigment)(uv::Vec2D) and must return the color of the surface as a RGB{Float32} in a given Vec2D point.\n\nSee also: UniformPigment, CheckeredPigment, ImagePigment\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Pigment-Tuple{StaticArrays.SVector{2, Float32}}","page":"Low-level API","title":"Raytracer.Pigment","text":"(p::Pigment)(uv::Vec2D)\n\nReturn the color of the surface in the given point Vec2D.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.SpecularBRDF","page":"Low-level API","title":"Raytracer.SpecularBRDF","text":"SpecularBRDF <: BRDF\n\nA class representing an ideal mirror BRDF.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.SpecularBRDF-Tuple{Pigment, Float32}","page":"Low-level API","title":"Raytracer.SpecularBRDF","text":"SpecularBRDF(pigment::Pigment, threshold_angle_rad::Float32)\n\nConstructor for a SpecularBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.SpecularBRDF-Tuple{}","page":"Low-level API","title":"Raytracer.SpecularBRDF","text":"SpecularBRDF(; pigment::Pigment = UniformPigment(),\n               threshold_angle_rad::Float32 = π / 1800f0)\n\nConstructor for a SpecularBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.UniformPigment","page":"Low-level API","title":"Raytracer.UniformPigment","text":"UniformPigment <: Pigment\n\nA uniform Pigment over the whole surface.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.UniformPigment-Tuple{Float32, Float32}","page":"Low-level API","title":"Raytracer.UniformPigment","text":"(up::UniformPigment)(u::Float32, v::Float32)\n\nReturn the color of the surface in the given point (uv).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.UniformPigment-Tuple{RGB{Float32}}","page":"Low-level API","title":"Raytracer.UniformPigment","text":"UniformPigment(color::RGB{Float32})\n\nConstructor for a UniformPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.UniformPigment-Tuple{}","page":"Low-level API","title":"Raytracer.UniformPigment","text":"UniformPigment(; color::RGB{Float32} = WHITE)\n\nConstructor for a UniformPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.at-Tuple{DiffuseBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}","page":"Low-level API","title":"Raytracer.at","text":"at(brdf::DiffuseBRDF, normal::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D)\n\nGet the radiance, given a point uv (Vec2D) on the surface with a DiffuseBRDF., an incoming direction in_dir and outcoming direction (Vec), a normal of the surface point (Normal).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.at-Tuple{SpecularBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}","page":"Low-level API","title":"Raytracer.at","text":"at(brdf::SpecularBRDF, normal::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D)\n\nGet the radiance, given a point uv (Vec2D) on the surface with a SpecularBRDF., an incoming direction in_dir and outcoming direction (Vec), a normal of the surface point (Normal).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Shapes","page":"Low-level API","title":"Shapes","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"hitrecord.jl\", \"shapes.jl\", \"world.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.HitOrMiss","page":"Low-level API","title":"Raytracer.HitOrMiss","text":"HitOrMiss\n\nAlias for Union{HitRecord, Nothing}.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.HitRecord","page":"Low-level API","title":"Raytracer.HitRecord","text":"HitRecord\n\nA struct representing the result of an intersection between a Ray and a Shape.\n\nFields\n\nworld_point::Point: a Point representing the world coordinates of the hit point.\nnormal::Normal: a Normal representing the orientation of the normal to the surface where the hit happened.\nsurface_point::Vec2D: a Vec2D representing the position of the hit point on the surface of the object.\nt::Float32: distance from the origin of the ray where the hit happened.\nray::Ray: a Ray representing the the ray that hit the surface.\nmaterial::Material: a Material representing the material of the point where the hit happened.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Shape","page":"Low-level API","title":"Raytracer.Shape","text":"Shape\n\nAn abstract type representing a shape.\n\nSee also: SimpleShape, CompositeShape,\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.all_ray_intersections-Tuple{Ray, Shape}","page":"Low-level API","title":"Raytracer.all_ray_intersections","text":"all_ray_intersections(ray, s)\n\nReturn a Vector of HitRecords of all the ray intersections with the given Shape for every finite value of t, even outside of the ray domain.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.all_ray_intersections-Union{Tuple{S}, Tuple{Ray, S}} where S<:SimpleShape","page":"Low-level API","title":"Raytracer.all_ray_intersections","text":"all_ray_intersections(ray::Ray, s::S) where {S <: SimpleShape}\n\nReturn a vector of HitRecord with all the Ray intersections with the given SimpleShape. If none exists, return an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.get_all_ts-Tuple{Shape, Ray}","page":"Low-level API","title":"Raytracer.get_all_ts","text":"get_all_ts(s::Shape, ray::Ray)\n\nReturn a Vector of the hit parameter t against the given Shape, even outside of the ray domain.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.get_all_ts-Tuple{Type{<:SimpleShape}, Ray}","page":"Low-level API","title":"Raytracer.get_all_ts","text":"get_all_ts(::Type{<:SimpleShape}, ray::Ray)\n\nReturn a Vector of the hit parameter t against the unitary shape of the given SimpleShape type, even outside of the ray domain.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.get_normal-Tuple{Type{<:SimpleShape}, Point, Ray}","page":"Low-level API","title":"Raytracer.get_normal","text":"get_normal(::Type{<:SimpleShape}, ::Point, ::Ray)\n\nReturn the Normal{true} of a shape given a point on its surface and the ray that hits it.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.get_t-Tuple{Type{<:SimpleShape}, Ray}","page":"Low-level API","title":"Raytracer.get_t","text":"get_t(::Type{<:SimpleShape}, ray::Ray)\n\nReturn the parameter t at which Ray first hits the unitary SimpleShape. If no hit exists, return Inf32.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.get_uv-Tuple{Type{<:SimpleShape}, Point}","page":"Low-level API","title":"Raytracer.get_uv","text":"get_uv(::Type{<:SimpleShape}, ::Point)\n\nReturn the uv coordinates of a shape associated with the given point on its surface.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.quick_ray_intersection-Tuple{Ray, Shape}","page":"Low-level API","title":"Raytracer.quick_ray_intersection","text":"quick_ray_intersection(ray, s)\n\nReturn whether the ray intersects the given Shape.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.quick_ray_intersection-Tuple{Ray, SimpleShape}","page":"Low-level API","title":"Raytracer.quick_ray_intersection","text":"quick_ray_intersection(ray::Ray, s::SimpleShape)\n\nTells if a Ray intersect a SimpleShape or not.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ray_intersection-Tuple{Ray, Shape}","page":"Low-level API","title":"Raytracer.ray_intersection","text":"ray_intersection(ray, s)\n\nReturn an HitRecord of the nearest ray intersection with the given Shape, if none exists, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ray_intersection-Union{Tuple{S}, Tuple{Ray, S}} where S<:SimpleShape","page":"Low-level API","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, s::S) where {S <: SimpleShape}\n\nReturn an HitRecord of the nearest Ray intersection with the given SimpleShape. If none exists, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.World","page":"Low-level API","title":"Raytracer.World","text":"World\n\nAlias of Vector{Shape}, to store a list of Shape.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.is_point_visible-Tuple{Vector{Shape}, Point, Point}","page":"Low-level API","title":"Raytracer.is_point_visible","text":"is_point_visible(world::World, point::Point, observer_pos::Point)\n\nTells if a particular Point in a World filled with Shape is visible from the observer position.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ray_intersection-Tuple{Ray, Vector{Shape}}","page":"Low-level API","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, world::World)\n\nIntersect a Ray with each Shape in World and return the nearest hit point.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Simple-shapes","page":"Low-level API","title":"Simple shapes","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"shapes/cube.jl\", \"shapes/cylinder.jl\", \"shapes/plane.jl\", \"shapes/sphere.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.Cube","page":"Low-level API","title":"Raytracer.Cube","text":"Cube <: SimpleShape\n\nA SimpleShape representing a cube of unitary size.\n\nMembers\n\ntransformation::Transformation: the Transformation associated with the cube.\nmaterial::Material: the Material of the cube.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Cube-Tuple{Transformation, Material}","page":"Low-level API","title":"Raytracer.Cube","text":"Cube(transformation::Transformation, material::Material)\n\nConstructor for a Cube instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Cube-Tuple{}","page":"Low-level API","title":"Raytracer.Cube","text":"Cube(transformation::Transformation = Transformation(),\n       material::Material = Material())\n\nConstructor for a Cube instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Cylinder","page":"Low-level API","title":"Raytracer.Cylinder","text":"Cylinder <: SimpleShape\n\nA SimpleShape representing a cylinder of unitary height and diameter.\n\nMembers\n\ntransformation::Transformation: the Transformation associated with the cylinder.\nmaterial::Material: the Material of the cylinder.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Cylinder-Tuple{Transformation, Material}","page":"Low-level API","title":"Raytracer.Cylinder","text":"Cylinder(transformation::Transformation, material::Material)\n\nConstructor for a Cylinder instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Cylinder-Tuple{}","page":"Low-level API","title":"Raytracer.Cylinder","text":"Cylinder(transformation::Transformation = Transformation(),\n       material::Material = Material())\n\nConstructor for a Cylinder instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Plane","page":"Low-level API","title":"Raytracer.Plane","text":"Plane <: SimpleShape\n\nA SimpleShape representing an infinite plane.\n\nMembers\n\ntransformation::Transformation: the Transformation associated with the plane.\nmaterial::Material: the Material of the plane.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Plane-Tuple{Transformation, Material}","page":"Low-level API","title":"Raytracer.Plane","text":"Plane(transformation::Transformation, material::Material)\n\nConstructor for a Plane instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Plane-Tuple{}","page":"Low-level API","title":"Raytracer.Plane","text":"Plane(transformation::Transformation = Transformation(),\n       material::Material = Material())\n\nConstructor for a Plane instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Sphere","page":"Low-level API","title":"Raytracer.Sphere","text":"Sphere <: SimpleShape\n\nA SimpleShape representing a sphere.\n\nThis is a unitary sphere centered in the origin. A generic sphere can be specified by applying a Transformation.\n\nMembers\n\ntransformation::Transformation: the Transformation associated with the sphere.\nmaterial::Material: the Material of the spere.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Sphere-Tuple{Transformation, Material}","page":"Low-level API","title":"Raytracer.Sphere","text":"Sphere(transformation::Transformation, material::Material)\n\nConstructor for a Sphere instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Sphere-Tuple{}","page":"Low-level API","title":"Raytracer.Sphere","text":"Sphere(transformation::Transformation = Transformation(),\n       material::Material = Material())\n\nConstructor for a Sphere instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Composite-shapes","page":"Low-level API","title":"Composite shapes","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"shapes/csg.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.CSG","page":"Low-level API","title":"Raytracer.CSG","text":"CSG{R} <: CompositeShape\n\nA Shape representing a Constructive Solid Geometry tree.\n\nThe behavior of the CSG tree is determined by the Rule R.\n\nMembers\n\nrbranch::Shape: represents the right branch of the tree\nlbranch::Shape: represents the left branch of the tree\ntransformation::Transformation: represents the Transformation of the whole composite shape\n\nExternal references\n\nConstructive Solid Geometry: https://en.wikipedia.org/wiki/Constructivesolidgeometry\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.DiffCSG","page":"Low-level API","title":"Raytracer.DiffCSG","text":"DiffCSG\n\nAlias for CSG{DiffRule}.\n\nSee also: CSG, Rule.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.FusionCSG","page":"Low-level API","title":"Raytracer.FusionCSG","text":"FusionCSG\n\nAlias for CSG{FuseRule}.\n\nSee also: CSG, Rule.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.IntersectionCSG","page":"Low-level API","title":"Raytracer.IntersectionCSG","text":"IntersectionCSG\n\nAlias for CSG{IntersectRule}.\n\nSee also: CSG, Rule.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Rule","page":"Low-level API","title":"Raytracer.Rule","text":"Rule\n\nEnum type representing the hit point selection of a CSG.\n\nInstances\n\nUniteRule: indicates that every hit point is valid\nIntersectRule: indicates that only hit points located inside of other shapes are valid\nDiffRule: indicates that only hit points outside of the lbranch and inside the rbranch are valid\nFuseRule: indicates that every hit point outside of other shapes is valid\n\nSee also: CSG.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.UnionCSG","page":"Low-level API","title":"Raytracer.UnionCSG","text":"UnionCSG\n\nAlias for CSG{UniteRule}.\n\nSee also: CSG, Rule.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.fuse-Tuple{Shape, Shape}","page":"Low-level API","title":"Raytracer.fuse","text":"fuse(s1::Shape, s2::Shape); transformation::Transformation = Transformation())\n\nConstruct a FusionCSG with the given shapes as rbranch and lbranch repectively.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.fuse-Tuple{Shape, Vararg{Shape}}","page":"Low-level API","title":"Raytracer.fuse","text":"fuse(s::Shape, ss::Shape...); transformation::Transformation = Transformation())\n\nConstruct a FusionCSG binary tree, by recursively calling intersect(::Shape, ::Shape).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#AABB","page":"Low-level API","title":"AABB","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"shapes/aabb.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.get_t-Tuple{Ray, Raytracer.AABB}","page":"Low-level API","title":"Raytracer.get_t","text":"get_t(ray::Ray, aabb::AABB)\n\nReturn the parameter t at which Ray first hits the AABB. If no hit exists, return Inf32.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Lights","page":"Low-level API","title":"Lights","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"lights.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.Lights","page":"Low-level API","title":"Raytracer.Lights","text":"Lights\n\nAlias of Vector{PointLight}, to store a list of PointLight sources.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PointLight","page":"Low-level API","title":"Raytracer.PointLight","text":"PointLight\n\nA point light (used by PointLightRenderer).\n\nThis type holds information about a point light.\n\nFields\n\nposition::Point: a Point object holding the position of the point light in 3D space.\ncolor::RGB{Float32}: the color of the point light.\nlinear_radius::Float32: radius of the source, used to compute solid angle subtended by the light.\n\nIf linear_radius is non-zero, it is used to compute the solid angle subtended by the light at a given distance d through the formula:\n\nleft(fracmathrmlinear_radiusdright)^2\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PointLight-Tuple{Point, RGB{Float32}, Float32}","page":"Low-level API","title":"Raytracer.PointLight","text":"PointLight(position::Point, color::RGB{Float32}, linear_radius::Float32)\n\nConstructor for a PointLight instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PointLight-Tuple{}","page":"Low-level API","title":"Raytracer.PointLight","text":"PointLight(; position::Point = ORIGIN,\n             color::RGB{Float32} = WHITE,\n             linear_radius::Float32 = 0f0)\n\nConstructor for a PointLight instance.\n\nIf no parameter is specified, it return a white point light in the origin with no radius.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#PCG-random-number-generator","page":"Low-level API","title":"PCG random number generator","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"pcg.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.PCG","page":"Low-level API","title":"Raytracer.PCG","text":"mutable struct PCG <: AbstractRNG\n\nRandom number generator that implement the Permuted Congruential Generator, a simple fast space-efficient statistically good algorithms for random number generation. See O'Neill (2014).\n\nFields\n\nstate::UInt64: the state of the generator.\ninc::UInt64: sequence identifier.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PCG-Tuple{UInt64, UInt64}","page":"Low-level API","title":"Raytracer.PCG","text":"PCG(state::UInt64 = UInt64(42), inc::UInt64 = UInt64(54))\n\nConstructor for a PCG instance.\n\nIf no parameter is specified, the generated instance will have a state of 42 and a sequence identifier of 54.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Renderer","page":"Low-level API","title":"Renderer","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"renderers.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.FlatRenderer","page":"Low-level API","title":"Raytracer.FlatRenderer","text":"FlatRenderer <: Renderer\n\nA basic Renderer that returns the color of the Shape first hit by a given Ray.\n\nThis renderer returns the color stored in the material field of the Shape first hit by the given Ray at the hit point. To this renderer there is no difference between radiated light and reflected color. There are no shades, diffusions or reflections. If there are no hits this renderer returns the value of its field background_color.\n\nFields\n\nworld::World: the World to render.\nbackground_color::RGB{Float32}: color if the ray do not collide.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.FlatRenderer-Tuple{Ray}","page":"Low-level API","title":"Raytracer.FlatRenderer","text":"(oor::FlatRenderer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.FlatRenderer-Tuple{Vector{Shape}, RGB{Float32}}","page":"Low-level API","title":"Raytracer.FlatRenderer","text":"FlatRenderer(world::World, background_color::RGB{Float32})\n\nConstructor for a FlatRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.FlatRenderer-Tuple{Vector{Shape}}","page":"Low-level API","title":"Raytracer.FlatRenderer","text":"FlatRenderer(world::World; background_color::RGB{Float32} = BLACK)\n\nConstructor for a FlatRenderer instance.\n\nIf no color is specified, it will default on BLACK.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.OnOffRenderer","page":"Low-level API","title":"Raytracer.OnOffRenderer","text":"OnOffRenderer <: Renderer\n\nA basic bichrome Renderer that checks whether a Ray has collided or not.\n\nThis renderer returns its field off_color when the given Ray is nothing, else it returns its field on_color.\n\nFields\n\nworld::World: the World to render.\non_color::RGB{Float32}: color if the ray collide.\noff_color::RGB{Float32}: color if the ray do not collide.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.OnOffRenderer-Tuple{Ray}","page":"Low-level API","title":"Raytracer.OnOffRenderer","text":"(oor::OnOffRenderer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.OnOffRenderer-Tuple{Vector{Shape}, RGB{Float32}, RGB{Float32}}","page":"Low-level API","title":"Raytracer.OnOffRenderer","text":"OnOffRenderer(world::World, on_color::RGB{Float32}, off_color::RGB{Float32})\n\nConstructor for a OnOffRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.OnOffRenderer-Tuple{Vector{Shape}}","page":"Low-level API","title":"Raytracer.OnOffRenderer","text":"OnOffRenderer(world::World\n              ; on_color::RGB{Float32} = WHITE,\n                off_color::RGB{Float32} = BLACK)\n\nConstructor for a OnOffRenderer instance.\n\nIf no color is specified, it will default on WHITE and BLACK.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PathTracer","page":"Low-level API","title":"Raytracer.PathTracer","text":"PathTracer <: Renderer\n\nA path-tracing Renderer that considers the optical path of a Ray from the observer to a light source.\n\nFields\n\nworld::World: the World to render.\nbackground_color::RGB{Float32}: color if the ray do not collide.\nrng::PCG: a PCG random number generator to appropriately scatter rays.\nn::Int: how many scattered rays should be generated for the mc integration.\nmax_depth::Int: the maximum number of scatters a ray should be subjected to before stopping.\nroulette_depth::Int: the depth at which the russian roulette algorithm should start (if > 'max_depth` then it will never start).\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PathTracer-Tuple{Ray}","page":"Low-level API","title":"Raytracer.PathTracer","text":"(oor::PathTracer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PathTracer-Tuple{Vector{Shape}, RGB{Float32}, PCG, Int64, Int64, Int64}","page":"Low-level API","title":"Raytracer.PathTracer","text":"PathTracer(world::World, background_color::RGB{Float32}, rng::PCG, n::Int, max_depth::Int, roulette_depth::Int)\n\nConstructor for a PathTracer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PathTracer-Tuple{Vector{Shape}}","page":"Low-level API","title":"Raytracer.PathTracer","text":"PathTracer(world::World\n           ; background_color::RGB{Float32} = BLACK,\n             rng::PCG = PCG(),\n             n::Int = 10,\n             max_depth::Int = 2,\n             roulette_depth::Int = 3)\n\nConstructor for a PathTracer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PointLightRenderer","page":"Low-level API","title":"Raytracer.PointLightRenderer","text":"PointLightRenderer <: Renderer\n\nPoint-light tracing Renderer. This renderer is similar to what POV-Ray provides by default.\n\nFields\n\nworld::World: the World to render.\nlights::Lights: a Lights instance that contain a list of lights.\nbackground_color::RGB{Float32}: color if the ray do not collide.\nambient_color::RGB{Float32}: the ambient color of the scene.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PointLightRenderer-Tuple{Ray}","page":"Low-level API","title":"Raytracer.PointLightRenderer","text":"(oor::PointLightRenderer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}, RGB{Float32}, RGB{Float32}}","page":"Low-level API","title":"Raytracer.PointLightRenderer","text":"PointLightRenderer(world::World, lights::Lights, background_color::RGB{Float32}, ambient_color::RGB{Float32})\n\nConstructor for a PointLightRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}}","page":"Low-level API","title":"Raytracer.PointLightRenderer","text":"PointLightRenderer(world::World, lights::Lights\n                   ; background_color::RGB{Float32} = BLACK,\n                     ambient_color::RGB{Float32} = WHITE * 1f-3)\n\nConstructor for a PointLightRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Renderer","page":"Low-level API","title":"Raytracer.Renderer","text":"Renderer\n\nAbstract type for functors that map Ray to RGB{Float32}.\n\nEach subtype of this type must be a callable like (r::Renderer)(ray::Ray) and must return a RGB{Float32}. Each subtype of this type should have a member of type World to check for intersections of the given Ray.\n\nSee also: OnOffRenderer, FlatRenderer, PathTracer, PointLightRenderer\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Image-tracer","page":"Low-level API","title":"Image tracer","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"imagetracer.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.ImageTracer","page":"Low-level API","title":"Raytracer.ImageTracer","text":"ImageTracer\n\nTrace an image by shooting light rays through each of its pixels.\n\nTo fill an image store it into ImageTracer along with the desired camera and apply fire_all_rays! to it. Alternatively apply iteratively fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32) on the desired ranges.\n\nFields\n\nimage::HdrImage: a HdrImage in which save the rendered image.\ncamera::Camera: a Camera holding the observer informations.\nsamples_per_side::Int: the number of samples per side of a pixel for antialiasing algorithm.\nrng::PCG: a PCG random number generator for antialiasing algorithm.\n\nIf samples_per_side is larger than zero, antialiasing will be applied to each pixel in the image, using the random number generator rng.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.ImageTracer-Tuple{HdrImage, Camera, Int64, PCG}","page":"Low-level API","title":"Raytracer.ImageTracer","text":"ImageTracer(image::HdrImage, camera::Camera, samples_per_side::Int, rng::PCG)\n\nConstructor for an ImageTracer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ImageTracer-Tuple{HdrImage, Camera}","page":"Low-level API","title":"Raytracer.ImageTracer","text":"ImageTracer(image::HdrImage, camera::Camera\n            ; samples_per_side::Int = 0,\n              rng::PCG = PCG())\n\nConstruct a ImageTracer.\n\nIf samples_per_side is not specified, antialiasing will be disabled and rng is ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.fire_all_rays!-Tuple{ImageTracer, Renderer}","page":"Low-level API","title":"Raytracer.fire_all_rays!","text":"fire_all_rays!(tracer::ImageTracer, renderer::Renderer\n               ; use_threads::Bool = true,\n                 enable_progress_bar::Bool = true)\n\nRender an image with informations stored in an ImageTracer using the specified Renderer.\n\nThis function apply iteratively fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32) for each pixel in the image contained in tracer using its camera, and then render the point using renderer.\n\nIf use_threads is true, the function will use the Threads.@threads macro to parallelize the computation.\n\nIf enable_progress_bar is true, the function will display a progress bar during the computation; this is thread safe.\n\nSee also: fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.fire_ray-Tuple{ImageTracer, Int64, Int64}","page":"Low-level API","title":"Raytracer.fire_ray","text":"fire_ray(tracer::ImageTracer, col::Int, row::Int\n         ; u_pixel::Float32 = 0.5f0,\n           v_pixel::Float32 = 0.5f0)\n\nShoot a Ray through the pixel (col, row) of the image contained in an [ImageTracer], using its camera informations.\n\nThe function use the fire_ray function of the associated camera (fire_ray(::OrthogonalCamera, ::Float32, ::Float32),     fire_ray(::PerspectiveCamera, ::Float32, ::Float32))\n\nThe parameters col and row are measured in the same way as they are in HdrImage: the bottom left corner is placed at (0 0). The values of u_pixel and v_pixel are floating-point numbers in the range 0 1: they specify where the ray should cross the pixel; passing 0.5 to both means that the ray will pass through the pixel's center.\n\nSee also: fire_all_rays!\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Index","page":"Low-level API","title":"Index","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPages   = [\"low-level.md\"]","category":"page"},{"location":"devs/collab/#Collaboration-instructions","page":"Collaboration instructions","title":"Collaboration instructions","text":"","category":"section"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"To contribute to the package development, clone this repository:","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"git clone https://github.com/Paolo97Gll/Raytracer.jl.git\ncd Raytracer.jl","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"Then open the julia REPL and type the following commands to update your environment:","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"import Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"Please make sure to update tests as appropriate.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: logo)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Raytracing package for the generation of photorealistic images in Julia.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\"]\nDepth = 3","category":"page"},{"location":"#Brief-description","page":"Introduction","title":"Brief description","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main purpose of this package is to generate photorealistic images given an input scene.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The input scene is composed by a list of shapes (spheres, planes, ...) of various materials (for now diffusive or reflective) with different colors, each one with in a particular position in the 3D space. The observer is represented by a camera, that can do a perspective or an orthogonal projection. The camera will see the scene through a screen, characterized by its aspect ratio, distance from the camera and resolution. The image can be rendered with different backwards ray tracing algorithms: a path tracer (the default renderer), a point-light tracer, a flat renderer and an on-off renderer; this process can be parallelized using multiple threads. Each of these aspects can be managed, tuned and modified using the low-level API of the package (see below).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are two main steps in the image generation. We offer high-level API and a CLI tool for these steps (see below).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The generation of an HDR (high dynamic range) image in the PFM format. In this step, the scene is loaded along with the informations about the observer (position, orientation, type of the camera, ...) and the chosen renderer. Then the image is rendered using the chosen algorithm.\nThe conversion of this image to an LDR (low dynamic range) image, such as jpg or png, using a tone mapping process.","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We provide:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A package with both high-level API and low-level API. It's possible to use the package's features directly from the REPL or in more complex scripts. See Basic API usage.\nA CLI tool. Thanks to the simple usage and the extended help messages, it makes possible the use of this package's high-level features to those who do not know Julia lang. See Basic CLI tool usage.\nSceneLang is a Domain-Specific Language (DSL) used to describe a 3D scene that can be rendered by Raytracer. Being a DSL, SceneLang lacks some of the basic features of general purpose languages: there are no functions or custom types or even flexible arithmetic operations. SceneLang is made only to construct scenes to be rendered. See Basic SceneLang usage.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For example, to generate an image from a SceneLang script, you can use the julia REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Raytracer\n\njulia> render_from_script(\"path/to/script.sl\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or equivalently the CLI tool:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"~/Raytracer.jl❯ julia raytracer_cli.jl render image path/to/script.sl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The CLI tool has more advanced features, like the generation of animations, but using the package from the REPL gives more flexibility.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#Package","page":"Introduction","title":"Package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is not available in the official registry.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To add this package to your main environment (not recommended), open the julia REPL and type the following commands:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(url=\"https://github.com/Samuele-Colombo/FileIO.jl\")\nPkg.add(url=\"https://github.com/Samuele-Colombo/ImagePFM.jl\")\nPkg.add(url=\"https://github.com/Paolo97Gll/Raytracer.jl\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We use a custom version of FileIO that provides load/save functionalities for pfm files: this integration is done by the package ImagePFM. If FileIO is already present (e.g. the original package), it will be overwritten by this custom version.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can also create a new environment (recommended). First create a new folder and cd into this folder: this will become the home of the new environment. Then open the julia REPL and type the following commands:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.activate(\".\")\nPkg.add(url=\"https://github.com/Samuele-Colombo/FileIO.jl\")\nPkg.add(url=\"https://github.com/Samuele-Colombo/ImagePFM.jl\")\nPkg.add(url=\"https://github.com/Paolo97Gll/Raytracer.jl\")","category":"page"},{"location":"#cli_tool_installation","page":"Introduction","title":"CLI tool","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To use the CLI tool, you don't need to install the package or create a new environment: you just need to clone the repository:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"git clone https://github.com/Paolo97Gll/Raytracer.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then cd into the cloned folder, open the julia REPL, and type the following commands to instantiate the environment:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"}]
}
