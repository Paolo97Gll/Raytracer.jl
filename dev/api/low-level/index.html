<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Low-level API · Raytracer.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Raytracer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Raytracer.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Quickstart</span><ul><li><a class="tocitem" href="../../quickstart/cli/">Basic CLI usage</a></li><li><a class="tocitem" href="../../quickstart/scenelang/">Basic SceneLang usage</a></li><li><a class="tocitem" href="../../quickstart/api/">Basic API usage</a></li></ul></li><li><a class="tocitem" href="../../scenelang/">SceneLang</a></li><li><a class="tocitem" href="../../cli/">CLI tool</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../high-level/">High-level API</a></li><li class="is-active"><a class="tocitem" href>Low-level API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Colors-and-images"><span>Colors and images</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li><li><a class="tocitem" href="#Ray"><span>Ray</span></a></li><li><a class="tocitem" href="#Cameras"><span>Cameras</span></a></li><li><a class="tocitem" href="#Materials,-BRDF-and-pigments"><span>Materials, BRDF and pigments</span></a></li><li><a class="tocitem" href="#Shapes"><span>Shapes</span></a></li><li><a class="tocitem" href="#Lights"><span>Lights</span></a></li><li><a class="tocitem" href="#PCG-random-number-generator"><span>PCG random number generator</span></a></li><li><a class="tocitem" href="#Renderer"><span>Renderer</span></a></li><li><a class="tocitem" href="#Image-tracer"><span>Image tracer</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../extendability/">Extendability</a></li><li><span class="tocitem">For devs</span><ul><li><a class="tocitem" href="../../devs/collab/">Collaboration instructions</a></li><li><a class="tocitem" href="../../devs/private-api/">Private API</a></li><li><a class="tocitem" href="../../devs/scenelang-api/">SceneLang interpreter API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Low-level API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Low-level API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/master/docs/src/api/low-level.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="low_level_api"><a class="docs-heading-anchor" href="#low_level_api">Low-level API</a><a id="low_level_api-1"></a><a class="docs-heading-anchor-permalink" href="#low_level_api" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#low_level_api">Low-level API</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Colors-and-images">Colors and images</a></li><ul><li><a href="#Colors">Colors</a></li><li><a href="#HDR-image">HDR image</a></li></ul><li><a href="#Geometry">Geometry</a></li><li><a href="#Transformations">Transformations</a></li><li><a href="#Ray">Ray</a></li><li><a href="#Cameras">Cameras</a></li><li><a href="#Materials,-BRDF-and-pigments">Materials, BRDF and pigments</a></li><li><a href="#Shapes">Shapes</a></li><ul><li><a href="#Simple-shapes">Simple shapes</a></li><li><a href="#Composite-shapes">Composite shapes</a></li><li><a href="#AABB">AABB</a></li></ul><li><a href="#Lights">Lights</a></li><li><a href="#PCG-random-number-generator">PCG random number generator</a></li><li><a href="#Renderer">Renderer</a></li><li><a href="#Image-tracer">Image tracer</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Colors-and-images"><a class="docs-heading-anchor" href="#Colors-and-images">Colors and images</a><a id="Colors-and-images-1"></a><a class="docs-heading-anchor-permalink" href="#Colors-and-images" title="Permalink"></a></h2><p>We use the <code>ColorTypes.RGB</code> from <a href="https://github.com/JuliaGraphics/ColorTypes.jl">ColorTypes.jl</a>. Our package extends the methods of this type, for example by implementing sum and difference between two color instances. We also add iterability and broadcasting.</p><h3 id="Colors"><a class="docs-heading-anchor" href="#Colors">Colors</a><a id="Colors-1"></a><a class="docs-heading-anchor-permalink" href="#Colors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Raytracer.BLACK" href="#Raytracer.BLACK"><code>Raytracer.BLACK</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">BLACK</code></pre><p>A <code>RGB{Float32}</code> representing a black color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.BLUE" href="#Raytracer.BLUE"><code>Raytracer.BLUE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">BLUE</code></pre><p>A <code>RGB{Float32}</code> representing a blue color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L318-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.CYAN" href="#Raytracer.CYAN"><code>Raytracer.CYAN</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">CYAN</code></pre><p>A <code>RGB{Float32}</code> representing a cyan color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L325-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.GREEN" href="#Raytracer.GREEN"><code>Raytracer.GREEN</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">GREEN</code></pre><p>A <code>RGB{Float32}</code> representing a green color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.MAGENTA" href="#Raytracer.MAGENTA"><code>Raytracer.MAGENTA</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">MAGENTA</code></pre><p>A <code>RGB{Float32}</code> representing a magenta color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.RED" href="#Raytracer.RED"><code>Raytracer.RED</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">RED</code></pre><p>A <code>RGB{Float32}</code> representing a red color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L304-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.WHITE" href="#Raytracer.WHITE"><code>Raytracer.WHITE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">WHITE</code></pre><p>A <code>RGB{Float32}</code> representing a white color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.YELLOW" href="#Raytracer.YELLOW"><code>Raytracer.YELLOW</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">YELLOW</code></pre><p>A <code>RGB{Float32}</code> representing a yellow color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L339-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.clamp-Union{Tuple{RGB{T}}, Tuple{T}} where T" href="#Base.Math.clamp-Union{Tuple{RGB{T}}, Tuple{T}} where T"><code>Base.Math.clamp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clamp(c::RGB)</code></pre><p>Return a clamped <code>RGB</code> color, with each component <code>x</code> obtained with the formula:</p><p class="math-container">\[\frac{x}{1 + x}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; clamp(RGB(1f0, 2f0, 3f0))
RGB color with eltype Float32
R: 0.5, G: 0.6666667, B: 0.75</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L226-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.luminosity-Tuple{RGB}" href="#Raytracer.luminosity-Tuple{RGB}"><code>Raytracer.luminosity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">luminosity(c::RGB)</code></pre><p>Return the mean value between the maximum component and the minumum component of a color:</p><p class="math-container">\[\frac{\mathrm{max}(c) + \mathrm{min}(c)}{2}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; luminosity(RGB(1f0, 2f0, 3f0))
2.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L208-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.γ_correction-Union{Tuple{T}, Tuple{RGB{T}, Float32}} where T" href="#Raytracer.γ_correction-Union{Tuple{T}, Tuple{RGB{T}, Float32}} where T"><code>Raytracer.γ_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">γ_correction(c::RGB, γ::Float32)</code></pre><p>Return a <code>RGB</code> color, with each component <code>x</code> corrected with the formula:</p><p class="math-container">\[x^{1 / \gamma}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; c = RGB(1f0, 2f0, 3f0);

julia&gt; γ_correction(c, 1f0)
RGB color with eltype Float32
R: 1.0, G: 2.0, B: 3.0

julia&gt; γ_correction(c, 0.8f0)
RGB color with eltype Float32
R: 1.0, G: 2.3784142, B: 3.948222

julia&gt; γ_correction(c, 2.4f0)
RGB color with eltype Float32
R: 1.0, G: 1.3348398, B: 1.580522</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/colors.jl#L245-L271">source</a></section></article><h3 id="HDR-image"><a class="docs-heading-anchor" href="#HDR-image">HDR image</a><a id="HDR-image-1"></a><a class="docs-heading-anchor-permalink" href="#HDR-image" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Raytracer.HdrImage" href="#Raytracer.HdrImage"><code>Raytracer.HdrImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HdrImage</code></pre><p>Wrapper of a <code>Matrix</code> of elements of type <code>RGB{Float32}</code>, used to represent an image in hdr format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hdrimage.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.HdrImage-Tuple{AbstractVector{var&quot;#s4&quot;} where var&quot;#s4&quot;, Integer, Integer}" href="#Raytracer.HdrImage-Tuple{AbstractVector{var&quot;#s4&quot;} where var&quot;#s4&quot;, Integer, Integer}"><code>Raytracer.HdrImage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HdrImage(arr::AbstractArray{&lt;:Any, 1}, im_width::Integer, im_height::Integer)
HdrImage(arr::AbstractArray{&lt;:Any, 1}, shape)</code></pre><p>Construct an <a href="#Raytracer.HdrImage"><code>HdrImage</code></a> wrapping a matrix obtained from <code>reshape</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),
              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];

julia&gt; HdrImage(arr, 3, 2)
3x2 HdrImage:
 (1.0 2.0 3.0)  (10.0 11.0 12.0)
 (4.0 5.0 6.0)  (13.0 14.0 15.0)
 (7.0 8.0 9.0)  (16.0 17.0 18.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hdrimage.jl#L40-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.HdrImage-Tuple{Integer, Integer}" href="#Raytracer.HdrImage-Tuple{Integer, Integer}"><code>Raytracer.HdrImage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HdrImage(img_width::Integer, img_height::Integer)</code></pre><p>Construct an <a href="#Raytracer.HdrImage"><code>HdrImage</code></a> wrapping a zero-initialized matrix of size <code>(img_width, img_height)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; HdrImage(3, 2)
3x2 HdrImage:
 (0.0 0.0 0.0)  (0.0 0.0 0.0)
 (0.0 0.0 0.0)  (0.0 0.0 0.0)
 (0.0 0.0 0.0)  (0.0 0.0 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hdrimage.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.HdrImage-Tuple{Matrix{RGB{Float32}}}" href="#Raytracer.HdrImage-Tuple{Matrix{RGB{Float32}}}"><code>Raytracer.HdrImage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HdrImage(pixel_matrix::Matrix{RGB{Float32}})</code></pre><p>Constructor for a <a href="#Raytracer.HdrImage"><code>HdrImage</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hdrimage.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Math.clamp-Tuple{HdrImage}" href="#Base.Math.clamp-Tuple{HdrImage}"><code>Base.Math.clamp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clamp(image::HdrImage)</code></pre><p>Adjust the color levels of the brightest pixels of a <a href="#Raytracer.HdrImage"><code>HdrImage</code></a>, by applying the <a href="#Base.Math.clamp-Union{Tuple{RGB{T}}, Tuple{T}} where T"><code>clamp(::RGB)</code></a> function to each pixel.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),
              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];

julia&gt; clamp(HdrImage(arr, 3, 2))
3x2 HdrImage:
 (0.5 0.6666667 0.75)        (0.90909094 0.9166667 0.9230769)
 (0.8 0.8333333 0.85714287)  (0.9285714 0.93333334 0.9375)
 (0.875 0.8888889 0.9)       (0.9411765 0.9444444 0.94736844)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hdrimage.jl#L155-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize-Tuple{HdrImage, Float32}" href="#LinearAlgebra.normalize-Tuple{HdrImage, Float32}"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize(image::HdrImage, α::Float32
          ; luminosity::Float32 = average_luminosity(image))</code></pre><p>Normalize a <a href="#Raytracer.HdrImage"><code>HdrImage</code></a> for a given luminosity.</p><p>If the <code>luminosity</code> parameter is not specified, the image will be normalized according to the result of <a href="#Raytracer.luminosity-Tuple{HdrImage}"><code>luminosity(::HdrImage; ::Float32)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),
              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];

julia&gt; normalize(HdrImage(arr, 3, 2), 1f0)
3x2 HdrImage:
 (0.12976472 0.25952944 0.38929415)  (1.2976472 1.4274119 1.5571766)
 (0.5190589 0.6488236 0.7785883)     (1.6869414 1.8167061 1.9464709)
 (0.90835303 1.0381178 1.1678824)    (2.0762355 2.2060003 2.335765)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hdrimage.jl#L129-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.luminosity-Tuple{HdrImage}" href="#Raytracer.luminosity-Tuple{HdrImage}"><code>Raytracer.luminosity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">luminosity(image::HdrImage; δ::Float32 = eps(Float32))</code></pre><p>Return the average luminosity an <a href="#Raytracer.HdrImage"><code>HdrImage</code></a> as the logaritmic mean of the <a href="#Raytracer.luminosity-Tuple{RGB}"><code>luminosity(::RGB)</code></a> <span>$l_i$</span> of each pixel:</p><p class="math-container">\[\left&lt; l \right&gt; = 10^{\frac{\sum_i \log_{10}(\delta + l_i)}{N}}\]</p><p>The parameter <code>δ</code> avoid singularities for <span>$l_i = 0$</span> (black pixels).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),
              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];

julia&gt; luminosity(HdrImage(arr, 3, 2))
7.706255f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hdrimage.jl#L103-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.γ_correction-Tuple{HdrImage, Float32}" href="#Raytracer.γ_correction-Tuple{HdrImage, Float32}"><code>Raytracer.γ_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">γ_correction(image::HdrImage, γ::Float32)</code></pre><p>Compute the γ correction of a <a href="#Raytracer.HdrImage"><code>HdrImage</code></a>, by applying the <a href="#Raytracer.γ_correction-Union{Tuple{T}, Tuple{RGB{T}, Float32}} where T"><code>γ_correction(::RGB, ::Float32)</code></a> function to each pixel.</p><p>Before calling this function, you should apply a tone-mapping algorithm to the image and be sure that the R, G, and B values of the colors in the image are all in the range <span>$[0, 1]$</span>. Use <a href="#LinearAlgebra.normalize-Tuple{HdrImage, Float32}"><code>normalize(::HdrImage, ::Float32; ::Float32)</code></a> and <a href="#Base.Math.clamp-Tuple{HdrImage}"><code>clamp(image::HdrImage)</code></a> to do this.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),
              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];

julia&gt; image = normalize(HdrImage(arr, 3, 2), 1f0) |&gt; clamp;

julia&gt; γ_correction(image, 1f0)
3x2 HdrImage:
 (0.11485995 0.20605269 0.28021002)  (0.5647722 0.58803856 0.6089437)
 (0.34169766 0.393507 0.43775633)    (0.6278296 0.64497536 0.660611)
 (0.47598794 0.5093512 0.53872037)   (0.67492735 0.6880849 0.7002187)

julia&gt; γ_correction(image, 0.8f0)
3x2 HdrImage:
 (0.06686684 0.13882665 0.20387058)  (0.48960024 0.51494074 0.53792465)
 (0.26124772 0.31166682 0.35607424)  (0.558859 0.57800144 0.5955692)
 (0.39536202 0.43030033 0.4615346)   (0.6117462 0.6266897 0.64053386)

julia&gt; γ_correction(image, 2.4f0)
3x2 HdrImage:
 (0.40588558 0.5177947 0.58855206)  (0.7881591 0.8015287 0.8132807)
 (0.63926977 0.6780008 0.7087834)   (0.82369685 0.83299613 0.8413514)
 (0.73394746 0.7549599 0.77280176)  (0.8489011 0.8557578 0.86201346)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hdrimage.jl#L176-L212">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.NORMAL_X" href="#Raytracer.NORMAL_X"><code>Raytracer.NORMAL_X</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">NORMAL_X</code></pre><p>A unitary and normalized <a href="#Raytracer.Normal"><code>Normal{true}</code></a> along the x-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L340-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.NORMAL_X_false" href="#Raytracer.NORMAL_X_false"><code>Raytracer.NORMAL_X_false</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">NORMAL_X_false</code></pre><p>A unitary and non-normalized <a href="#Raytracer.Normal"><code>Normal{false}</code></a> along the x-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L361-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.NORMAL_Y" href="#Raytracer.NORMAL_Y"><code>Raytracer.NORMAL_Y</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">NORMAL_Y</code></pre><p>A unitary and normalized <a href="#Raytracer.Normal"><code>Normal{true}</code></a> along the y-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L347-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.NORMAL_Y_false" href="#Raytracer.NORMAL_Y_false"><code>Raytracer.NORMAL_Y_false</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">NORMAL_Y_false</code></pre><p>A unitary and non-normalized <a href="#Raytracer.Normal"><code>Normal{false}</code></a> along the y-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L368-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.NORMAL_Z" href="#Raytracer.NORMAL_Z"><code>Raytracer.NORMAL_Z</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">NORMAL_Z</code></pre><p>A unitary and normalized <a href="#Raytracer.Normal"><code>Normal{true}</code></a> along the z-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.NORMAL_Z_false" href="#Raytracer.NORMAL_Z_false"><code>Raytracer.NORMAL_Z_false</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">NORMAL_Z_false</code></pre><p>A unitary and non-normalized <a href="#Raytracer.Normal"><code>Normal{false}</code></a> along the z-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ORIGIN" href="#Raytracer.ORIGIN"><code>Raytracer.ORIGIN</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">ORIGIN</code></pre><p>A <a href="#Raytracer.Point"><code>Point</code></a> representing the origin of the frame of reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L382-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.VEC_X" href="#Raytracer.VEC_X"><code>Raytracer.VEC_X</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">VEC_X</code></pre><p>A unitary <a href="#Raytracer.Vec"><code>Vec</code></a> along the x-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.VEC_Y" href="#Raytracer.VEC_Y"><code>Raytracer.VEC_Y</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">VEC_Y</code></pre><p>A unitary <a href="#Raytracer.Vec"><code>Vec</code></a> along the y-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.VEC_Z" href="#Raytracer.VEC_Z"><code>Raytracer.VEC_Z</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">VEC_Z</code></pre><p>A unitary <a href="#Raytracer.Vec"><code>Vec</code></a> along the z-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Normal" href="#Raytracer.Normal"><code>Raytracer.Normal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Normal{V} &lt;: StaticArrays.FieldVector{3, Float32}</code></pre><p>A pseudo-vector in 3D space with 3 fields <code>x</code>, <code>y</code>, and <code>z</code> of type <code>Float32</code>. The parameter <code>V</code> tells if the normal is normalized or not.</p><p>For inherited properties and constructors see <code>StaticArrays.FieldVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Normal-Tuple{Any, Any, Any}" href="#Raytracer.Normal-Tuple{Any, Any, Any}"><code>Raytracer.Normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Normal(x, y, z)</code></pre><p>Construct a non-normalized <a href="#Raytracer.Normal"><code>Normal{false}</code></a> with given coordinates. All values are converted in <code>Float32</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Normal(1.2, 3.3, 5)
Normal with eltype Float32, not normalized
x = 1.2, y = 3.3, z = 5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Normal-Union{Tuple{Float32, Float32, Float32}, Tuple{V}} where V" href="#Raytracer.Normal-Union{Tuple{Float32, Float32, Float32}, Tuple{V}} where V"><code>Raytracer.Normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Normal{V}(x::Float32, y::Float32, z::Float32)</code></pre><p>Constructor for a <a href="#Raytracer.Normal"><code>Normal</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Point" href="#Raytracer.Point"><code>Raytracer.Point</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Point</code></pre><p>A point in a 3D space. Implemented as a wrapper struct around a <code>SVector{3, Float32}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Point-Tuple{AbstractVector{T} where T}" href="#Raytracer.Point-Tuple{AbstractVector{T} where T}"><code>Raytracer.Point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Point(p::AbstractVector)</code></pre><p>Constructor for a <a href="#Raytracer.Point"><code>Point</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Point-Tuple{Any, Any, Any}" href="#Raytracer.Point-Tuple{Any, Any, Any}"><code>Raytracer.Point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Point(x, y, z)</code></pre><p>Construct a <a href="#Raytracer.Point"><code>Point</code></a> with given coordinates. All values are converted in <code>Float32</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Point(1.2, 3.3, 5)
Point with eltype Float32
x = 1.2, y = 3.3, z = 5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L179-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Vec" href="#Raytracer.Vec"><code>Raytracer.Vec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Vec &lt;: StaticArrays.FieldVector{3, Float32}</code></pre><p>A vector in 3D space with 3 fields <code>x</code>, <code>y</code>, and <code>z</code> of type <code>Float32</code>.</p><p>For inherited properties and constructors see <code>StaticArrays.FieldVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Vec-Tuple{Float32, Float32, Float32}" href="#Raytracer.Vec-Tuple{Float32, Float32, Float32}"><code>Raytracer.Vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Vec(x::Float32, y::Float32, z::Float32)</code></pre><p>Constructor for a <a href="#Raytracer.Vec"><code>Vec</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Vec2D" href="#Raytracer.Vec2D"><code>Raytracer.Vec2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Vec2D</code></pre><p>Alias to <code>SVector{2, Float32}</code>, used for uv mapping on shapes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L308-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Vec}, Point}" href="#Base.convert-Tuple{Type{Vec}, Point}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(::Type{Vec}, p::Point)
convert(::Type{Normal}, p::Point)</code></pre><p>Convert a <a href="#Raytracer.Point"><code>Point</code></a> into the specified type (<a href="#Raytracer.Vec"><code>Vec</code></a> or <a href="#Raytracer.Normal"><code>Normal{false}</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Normal{true}}" href="#LinearAlgebra.norm-Tuple{Normal{true}}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(n::Normal{true})</code></pre><p>Compute the squared norm of a <a href="#Raytracer.Normal"><code>Normal{true}</code></a>. Since <code>n</code> is already normalized, <code>1f0</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize-Tuple{Normal{false}}" href="#LinearAlgebra.normalize-Tuple{Normal{false}}"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize(n::Normal)</code></pre><p>Normalize <code>n</code> and return a <a href="#Raytracer.Normal"><code>Normal{true}</code></a>. If <code>n</code> is already a <code>Normal{true}</code> instance, no normalization is computed and <code>n</code> is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; n = normalize(Normal(1,2,4))
Normal with eltype Float32, normalized
x = 0.21821788, y = 0.43643576, z = 0.8728715

julia&gt; normalize(n)
Normal with eltype Float32, normalized
x = 0.21821788, y = 0.43643576, z = 0.8728715</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L108-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.create_onb_from_z-Tuple{Normal}" href="#Raytracer.create_onb_from_z-Tuple{Normal}"><code>Raytracer.create_onb_from_z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_onb_from_z(input_normal::Normal)</code></pre><p>Create an orthonormal base from a input <a href="#Raytracer.Normal"><code>Normal</code></a> representing the z-axis using the <a href="https://graphics.pixar.com/library/OrthonormalB/paper.pdf">Duff et al. 2017</a> algorithm.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; n = Normal(0,0,5);

julia&gt; nn = normalize(Normal(0,0,5));

julia&gt; create_onb_from_z(n)
(Vec(1.0, -0.0, -0.0), Vec(-0.0, 1.0, -0.0), Vec(0.0, 0.0, 1.0))

julia&gt; create_onb_from_z(nn)
(Vec(1.0, -0.0, -0.0), Vec(-0.0, 1.0, -0.0), Vec(0.0, 0.0, 1.0))</code></pre><p>Note that <code>create_onb_from_z(n)</code> and <code>create_onb_from_z(nn)</code> give the same result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L393-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.norm²-Tuple{Normal{false}}" href="#Raytracer.norm²-Tuple{Normal{false}}"><code>Raytracer.norm²</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm²(n::Normal)</code></pre><p>Compute the squared norm of a <a href="#Raytracer.Normal"><code>Normal</code></a>. If <code>n</code> is a <code>Normal{true}</code> instance then <code>1f0</code> is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; n = Normal(1, 2, 3);

julia&gt; norm²(n)
14.0f0

julia&gt; norm²(normalize(n))
1.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L135-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.norm²-Tuple{Vec}" href="#Raytracer.norm²-Tuple{Vec}"><code>Raytracer.norm²</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm²(v::Vec)</code></pre><p>Compute the squared norm of a <a href="#Raytracer.Vec"><code>Vec</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; norm²(Vec(1, 2, 3))
14.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/geometry.jl#L43-L54">source</a></section></article><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Transformation" href="#Raytracer.Transformation"><code>Raytracer.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Transformation</code></pre><p>A wrapper around two 4x4 matrices representing a transformation for <a href="#Raytracer.Vec"><code>Vec</code></a>, <a href="#Raytracer.Normal"><code>Normal</code></a>, and <a href="#Raytracer.Point"><code>Point</code></a> instances.</p><p>A 4x4 matrix is needed to use the properties of homogeneous coordinates in 3D space. Storing the inverse of the transformation significantly increases performance at the cost of memory space.</p><p><strong>Fields</strong></p><ul><li><code>m::SMatrix{4, 4, Float32}</code>: the homogeneous matrix representation of the transformation.</li><li><code>invm::SMatrix{4, 4, Float32}</code>: the homogeneous matrix representation of the inverse transformation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/transformations.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Transformation-Tuple{AbstractMatrix{T} where T}" href="#Raytracer.Transformation-Tuple{AbstractMatrix{T} where T}"><code>Raytracer.Transformation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transformation(m::AbstractMatrix)
Transformation(m::AbstractMatrix, invm::AbstractMatrix)</code></pre><p>Construct a <a href="#Raytracer.Transformation"><code>Transformation</code></a> instance from <code>m</code> and <code>invm</code>. The elements of the matrix will be casted to <code>Float32</code>.</p><p>If any argument is an <code>AbstractMatrix</code>, it will be implicitly casted to a <code>StaticArrays.SMatrix</code> to increase performance.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Transformation(StaticArrays.SMatrix{4,4}([1 0 0 0; 0 2 0 0; 0 0 4 0; 0 0 0 1]))
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  0.0f0
 0.0f0  2.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  4.0f0  0.0f0
 0.0f0  0.0f0  0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0   0.0f0
 0.0f0  0.5f0  0.0f0   0.0f0
 0.0f0  0.0f0  0.25f0  0.0f0
 0.0f0  0.0f0  0.0f0   1.0f0

julia&gt; Transformation([1 0 0 0; 0 2 0 0; 0 0 4 0; 0 0 0 1])
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  0.0f0
 0.0f0  2.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  4.0f0  0.0f0
 0.0f0  0.0f0  0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0   0.0f0
 0.0f0  0.5f0  0.0f0   0.0f0
 0.0f0  0.0f0  0.25f0  0.0f0
 0.0f0  0.0f0  0.0f0   1.0f0</code></pre><pre><code class="language-julia-repl">julia&gt; Transformation(LinearAlgebra.Diagonal([1,2,4,1]))
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  0.0f0
 0.0f0  2.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  4.0f0  0.0f0
 0.0f0  0.0f0  0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0   0.0f0
 0.0f0  0.5f0  0.0f0   0.0f0
 0.0f0  0.0f0  0.25f0  0.0f0
 0.0f0  0.0f0  0.0f0   1.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/transformations.jl#L58-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Transformation-Tuple{StaticArrays.SMatrix{4, 4, Float32, L} where L, StaticArrays.SMatrix{4, 4, Float32, L} where L}" href="#Raytracer.Transformation-Tuple{StaticArrays.SMatrix{4, 4, Float32, L} where L, StaticArrays.SMatrix{4, 4, Float32, L} where L}"><code>Raytracer.Transformation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Transformation(m::SMatrix{4, 4, Float32} = SMatrix{4, 4, Float32}(I(4)),
               invm::SMatrix{4, 4, Float32} = inv(m))</code></pre><p>Constructor for a <a href="#Raytracer.Transformation"><code>Transformation</code></a> instance.</p><p>If no parameter is specified, then an identity transformation is returned. If only the direct matrix is specified, then the inverse matrix is automatically computed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Transformation()
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  0.0f0
 0.0f0  1.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  1.0f0  0.0f0
 0.0f0  0.0f0  0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  0.0f0
 0.0f0  1.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  1.0f0  0.0f0
 0.0f0  0.0f0  0.0f0  1.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/transformations.jl#L31-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.isconsistent-Tuple{Transformation}" href="#Raytracer.isconsistent-Tuple{Transformation}"><code>Raytracer.isconsistent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isconsistent(t::Transformation)</code></pre><p>Return <code>true</code> if <code>t.m * t.invm</code> is similar to the identity matrix and so the <a href="#Raytracer.Transformation"><code>Transformation</code></a> is consistent.</p><p>Mainly used for testing and to verify matrices haven&#39;t been mutated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/transformations.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.rotationX" href="#Raytracer.rotationX"><code>Raytracer.rotationX</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotationX(θ::Real)</code></pre><p>Return a <a href="#Raytracer.Transformation"><code>Transformation</code></a> that rotates a 3D vector field of the given angle in radians around the X-axis.</p><p>If an <code>AbstractVector</code> is provided as argument it must have a <code>size = (3,)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rotationX(π/4)
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0          0.0f0         0.0f0
 0.0f0  0.70710677f0  -0.70710677f0  0.0f0
 0.0f0  0.70710677f0   0.70710677f0  0.0f0
 0.0f0  0.0f0          0.0f0         1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0   0.0f0         0.0f0         0.0f0
 0.0f0   0.70710677f0  0.70710677f0  0.0f0
 0.0f0  -0.70710677f0  0.70710677f0  0.0f0
 0.0f0   0.0f0         0.0f0         1.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/transformations.jl#L237-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.rotationY" href="#Raytracer.rotationY"><code>Raytracer.rotationY</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotationY(θ::Real)</code></pre><p>Return a <a href="#Raytracer.Transformation"><code>Transformation</code></a> that rotates a 3D vector field of the given angle in radians around the Y-axis.</p><p>If an <code>AbstractVector</code> is provided as argument it must have a <code>size = (3,)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rotationY(π/4)
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
  0.70710677f0  0.0f0  0.70710677f0  0.0f0
  0.0f0         1.0f0  0.0f0         0.0f0
 -0.70710677f0  0.0f0  0.70710677f0  0.0f0
  0.0f0         0.0f0  0.0f0         1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 0.70710677f0  0.0f0  -0.70710677f0  0.0f0
 0.0f0         1.0f0   0.0f0         0.0f0
 0.70710677f0  0.0f0   0.70710677f0  0.0f0
 0.0f0         0.0f0   0.0f0         1.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/transformations.jl#L238-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.rotationZ" href="#Raytracer.rotationZ"><code>Raytracer.rotationZ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotationZ(θ::Real)</code></pre><p>Return a <a href="#Raytracer.Transformation"><code>Transformation</code></a> that rotates a 3D vector field of the given angle in radians around the Z-axis.</p><p>If an <code>AbstractVector</code> is provided as argument it must have a <code>size = (3,)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rotationZ(π/4)
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 0.70710677f0  -0.70710677f0  0.0f0  0.0f0
 0.70710677f0   0.70710677f0  0.0f0  0.0f0
 0.0f0          0.0f0         1.0f0  0.0f0
 0.0f0          0.0f0         0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
  0.70710677f0  0.70710677f0  0.0f0  0.0f0
 -0.70710677f0  0.70710677f0  0.0f0  0.0f0
  0.0f0         0.0f0         1.0f0  0.0f0
  0.0f0         0.0f0         0.0f0  1.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/transformations.jl#L239-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.scaling-Tuple{Real, Real, Real}" href="#Raytracer.scaling-Tuple{Real, Real, Real}"><code>Raytracer.scaling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scaling(x::Real, y::Real, z::Real)
scaling(s::Real)
scaling(v::AbstractVector)</code></pre><p>Return a <a href="#Raytracer.Transformation"><code>Transformation</code></a> that scales a 3D vector field of a given factor for each axis.</p><p>If a single <code>Real</code> is provided as argument then the scaling is considered uniform. If an <code>AbstractVector</code> is provided as argument it must have a <code>size = (3,)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; scaling(1, 2, 3)
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  0.0f0
 0.0f0  2.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  3.0f0  0.0f0
 0.0f0  0.0f0  0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0         0.0f0
 0.0f0  0.5f0  0.0f0         0.0f0
 0.0f0  0.0f0  0.33333334f0  0.0f0
 0.0f0  0.0f0  0.0f0         1.0f0</code></pre><pre><code class="language-julia-repl">julia&gt; scaling(2)
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 2.0f0  0.0f0  0.0f0  0.0f0
 0.0f0  2.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  2.0f0  0.0f0
 0.0f0  0.0f0  0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 0.5f0  0.0f0  0.0f0  0.0f0
 0.0f0  0.5f0  0.0f0  0.0f0
 0.0f0  0.0f0  0.5f0  0.0f0
 0.0f0  0.0f0  0.0f0  1.0f0</code></pre><pre><code class="language-julia-repl">julia&gt; scaling([1, 2, 3])
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  0.0f0
 0.0f0  2.0f0  0.0f0  0.0f0
 0.0f0  0.0f0  3.0f0  0.0f0
 0.0f0  0.0f0  0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0         0.0f0
 0.0f0  0.5f0  0.0f0         0.0f0
 0.0f0  0.0f0  0.33333334f0  0.0f0
 0.0f0  0.0f0  0.0f0         1.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/transformations.jl#L305-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.translation-Tuple{AbstractVector{T} where T}" href="#Raytracer.translation-Tuple{AbstractVector{T} where T}"><code>Raytracer.translation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translation(v::AbstractVector)
translation(x::Real, y::Real, z::Real)</code></pre><p>Return a <a href="#Raytracer.Transformation"><code>Transformation</code></a> that translates a 3D vector field of the given coordinates.</p><p>If an <code>AbstractVector</code> is provided as argument it must have a <code>size = (3,)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; translation(1, 2, 3)
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  1.0f0
 0.0f0  1.0f0  0.0f0  2.0f0
 0.0f0  0.0f0  1.0f0  3.0f0
 0.0f0  0.0f0  0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  -1.0f0
 0.0f0  1.0f0  0.0f0  -2.0f0
 0.0f0  0.0f0  1.0f0  -3.0f0
 0.0f0  0.0f0  0.0f0   1.0f0</code></pre><pre><code class="language-julia-repl">julia&gt; translation([1, 2, 3])
4x4 Transformation:
Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  1.0f0
 0.0f0  1.0f0  0.0f0  2.0f0
 0.0f0  0.0f0  1.0f0  3.0f0
 0.0f0  0.0f0  0.0f0  1.0f0
Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:
 1.0f0  0.0f0  0.0f0  -1.0f0
 0.0f0  1.0f0  0.0f0  -2.0f0
 0.0f0  0.0f0  1.0f0  -3.0f0
 0.0f0  0.0f0  0.0f0   1.0f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/transformations.jl#L248-L287">source</a></section></article><h2 id="Ray"><a class="docs-heading-anchor" href="#Ray">Ray</a><a id="Ray-1"></a><a class="docs-heading-anchor-permalink" href="#Ray" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Ray" href="#Raytracer.Ray"><code>Raytracer.Ray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ray</code></pre><p>A ray of light propagating in space.</p><p><strong>Fields</strong></p><ul><li><code>origin::Point</code>: the (<a href="#Raytracer.Point"><code>Point</code></a>) where the ray originated.</li><li><code>dir::Vec</code>: a (<a href="#Raytracer.Vec"><code>Vec</code></a>) representing the direction along which this ray propagates.</li><li><code>tmin::Float32</code>: the minimum distance travelled by the ray is this number times <code>dir</code>.</li><li><code>tmax::Float32</code>: the maximum distance travelled by the ray is this number times <code>dir</code>.</li><li><code>depth::Int</code>: number of times this ray was reflected/refracted.</li></ul><p>See also: <a href="#Raytracer.Ray-Tuple{Float32}"><code>Ray(::Float32)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/ray.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Ray-Tuple{Float32}" href="#Raytracer.Ray-Tuple{Float32}"><code>Raytracer.Ray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(r::Ray)(t::Float32)</code></pre><p>Return a <a href="#Raytracer.Point"><code>Point</code></a> lying on the given <a href="#Raytracer.Ray"><code>Ray</code></a> at <code>t</code>.</p><p>An instance of <code>Ray</code> can be called as a function returning a <code>Point</code> given the position parameter <code>t</code>:</p><p class="math-container">\[\mathrm{ray\_origin} + \mathrm{ray\_direction} \cdot t\]</p><p>Argument <code>t</code> must be included between <code>r.tmin</code> and <code>r.tmax</code> or be equal to 0. If <code>t</code> is zero, then the returned point is the origin of <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ray = Ray(ORIGIN, VEC_X)
Ray
 ↳ origin = Point(0.0, 0.0, 0.0)
 ↳ dir    = Vec(1.0, 0.0, 0.0)
 ↳ tmin   = 1.0e-5
 ↳ tmax   = Inf
 ↳ depth  = 0

julia&gt; ray(5f0)
Point with eltype Float32
x = 5.0, y = 0.0, z = 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/ray.jl#L52-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Ray-Tuple{Point, Vec, Float32, Float32, Int64}" href="#Raytracer.Ray-Tuple{Point, Vec, Float32, Float32, Int64}"><code>Raytracer.Ray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Ray(origin::Point, dir::Vec, tmin::Float32, tmax::Float32, depth::Int)</code></pre><p>Constructor for a <a href="#Raytracer.Ray"><code>Ray</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/ray.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Ray-Tuple{Point, Vec}" href="#Raytracer.Ray-Tuple{Point, Vec}"><code>Raytracer.Ray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Ray(origin::Point, dir::Vec
    ; tmin::Float32 = 1f-5,
      tmax::Float32 = Inf32,
      depth::Int = 0)</code></pre><p>Constructor for a <a href="#Raytracer.Ray"><code>Ray</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/ray.jl#L42-L49">source</a></section></article><h2 id="Cameras"><a class="docs-heading-anchor" href="#Cameras">Cameras</a><a id="Cameras-1"></a><a class="docs-heading-anchor-permalink" href="#Cameras" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Camera" href="#Raytracer.Camera"><code>Raytracer.Camera</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Camera</code></pre><p>An abstract type representing an observer.</p><p>See also: <a href="#Raytracer.OrthogonalCamera"><code>OrthogonalCamera</code></a>, <a href="#Raytracer.PerspectiveCamera"><code>PerspectiveCamera</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.OrthogonalCamera" href="#Raytracer.OrthogonalCamera"><code>Raytracer.OrthogonalCamera</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrthogonalCamera &lt;: Camera</code></pre><p>A <a href="#Raytracer.Camera"><code>Camera</code></a> implementing an orthogonal 3D → 2D projection.</p><p><strong>Fields</strong></p><ul><li><code>aspect_ratio::Float32</code>: defines how larger than the height is the image (16/9, 4/3, ...).</li><li><code>transformation::Transformation</code>: define the <a href="#Raytracer.Transformation"><code>Transformation</code></a> applied to the rays generated by the camera.</li></ul><p>See also: <a href="#Raytracer.fire_ray-Tuple{OrthogonalCamera, Float32, Float32}"><code>fire_ray(::OrthogonalCamera, ::Float32, ::Float32)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L22-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.OrthogonalCamera-Tuple{Float32, Transformation}" href="#Raytracer.OrthogonalCamera-Tuple{Float32, Transformation}"><code>Raytracer.OrthogonalCamera</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OrthogonalCamera(aspect_ratio::Float32, transformation::Transformation)</code></pre><p>Constructor for an <a href="#Raytracer.OrthogonalCamera"><code>OrthogonalCamera</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.OrthogonalCamera-Tuple{}" href="#Raytracer.OrthogonalCamera-Tuple{}"><code>Raytracer.OrthogonalCamera</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OrthogonalCamera(; aspect_ratio::Float32 = 1f0,
                   transformation::Transformation = Transformation())</code></pre><p>Keyword-based constructor for an <a href="#Raytracer.OrthogonalCamera"><code>OrthogonalCamera</code></a> instance.</p><p>If no parameter is specified, it return a camera with square aspect ratio and an identity transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PerspectiveCamera" href="#Raytracer.PerspectiveCamera"><code>Raytracer.PerspectiveCamera</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PerspectiveCamera &lt;: Camera</code></pre><p>A <a href="#Raytracer.Camera"><code>Camera</code></a> implementing a perspective 3D → 2D projection.</p><p><strong>Fields</strong></p><ul><li><code>aspect_ratio::Float32</code>: defines how larger than the height is the image (16/9, 4/3, ...).</li><li><code>transformation::Transformation</code>: define the <a href="#Raytracer.Transformation"><code>Transformation</code></a> applied to the rays generated by the camera.</li><li><code>screen_distance::Float32</code>: tells how much far from the eye of the observer is the screen and it influences the FOV (field-of-view).</li></ul><p>See also: <a href="#Raytracer.fire_ray-Tuple{PerspectiveCamera, Float32, Float32}"><code>fire_ray(::PerspectiveCamera, ::Float32, ::Float32)</code></a>, <a href="#Raytracer.aperture_deg-Tuple{PerspectiveCamera}"><code>aperture_deg</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PerspectiveCamera-Tuple{Float32, Transformation, Float32}" href="#Raytracer.PerspectiveCamera-Tuple{Float32, Transformation, Float32}"><code>Raytracer.PerspectiveCamera</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PerspectiveCamera(aspect_ratio::Float32, transformation::Transformation, screen_distance::Float32)</code></pre><p>Constructor for an <a href="#Raytracer.PerspectiveCamera"><code>PerspectiveCamera</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PerspectiveCamera-Tuple{}" href="#Raytracer.PerspectiveCamera-Tuple{}"><code>Raytracer.PerspectiveCamera</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PerspectiveCamera(; aspect_ratio::Float32 = 1f0,
                    transformation::Transformation = Transformation(),
                    screen_distance::Float32 = 1f0)</code></pre><p>Keyword-based constructor for a <a href="#Raytracer.PerspectiveCamera"><code>PerspectiveCamera</code></a> instance.</p><p>If no parameter is specified, it return a camera with square aspect ratio, an identity transformation, and a screen distance of 1, giving a FOV of 90°.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L80-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.aperture_deg-Tuple{PerspectiveCamera}" href="#Raytracer.aperture_deg-Tuple{PerspectiveCamera}"><code>Raytracer.aperture_deg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aperture_deg(camera::PerspectiveCamera)</code></pre><p>Compute the FOV of the camera in degrees for a <a href="#Raytracer.PerspectiveCamera"><code>PerspectiveCamera</code></a>.</p><p><strong>Examples</strong></p><p>FOV for a camera with screen distance of 1 and aspect ratio of 1:</p><pre><code class="language-julia-repl">julia&gt; aperture_deg(PerspectiveCamera())
90.0f0</code></pre><p>FOV for a camera with screen distance of 1 and aspect ratio of 16/9:</p><pre><code class="language-julia-repl">julia&gt; aperture_deg(PerspectiveCamera(aspect_ratio = 16//9))
58.715508f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L140-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.fire_ray-Tuple{OrthogonalCamera, Float32, Float32}" href="#Raytracer.fire_ray-Tuple{OrthogonalCamera, Float32, Float32}"><code>Raytracer.fire_ray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fire_ray(camera::OrthogonalCamera, u::Float32, v::Float32)</code></pre><p>Fire a <a href="#Raytracer.Ray"><code>Ray</code></a> through an <a href="#Raytracer.OrthogonalCamera"><code>OrthogonalCamera</code></a> at a position <span>$(u, v)$</span> on the screen, using an orthogonal projection.</p><p>Parameters <code>u</code> and <code>v</code> are bound between 0 and 1:</p><pre><code class="nohighlight">(0, 1)                            (1, 1)
    +------------------------------+
    |                              |
    |                              |
    |                              |
    +------------------------------+
(0, 0)                            (1, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L96-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.fire_ray-Tuple{PerspectiveCamera, Float32, Float32}" href="#Raytracer.fire_ray-Tuple{PerspectiveCamera, Float32, Float32}"><code>Raytracer.fire_ray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fire_ray(camera::PerspectiveCamera, u::Float32, v::Float32)</code></pre><p>Fire a <a href="#Raytracer.Ray"><code>Ray</code></a> through a <a href="#Raytracer.PerspectiveCamera"><code>PerspectiveCamera</code></a> at a position <span>$(u, v)$</span> on the screen, using a perspective projection.</p><p>Parameters <code>u</code> and <code>v</code> are bound between 0 and 1:</p><pre><code class="nohighlight">(0, 1)                            (1, 1)
    +------------------------------+
    |                              |
    |                              |
    |                              |
    +------------------------------+
(0, 0)                            (1, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/cameras.jl#L118-L133">source</a></section></article><h2 id="Materials,-BRDF-and-pigments"><a class="docs-heading-anchor" href="#Materials,-BRDF-and-pigments">Materials, BRDF and pigments</a><a id="Materials,-BRDF-and-pigments-1"></a><a class="docs-heading-anchor-permalink" href="#Materials,-BRDF-and-pigments" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.BRDF" href="#Raytracer.BRDF"><code>Raytracer.BRDF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BRDF</code></pre><p>An abstract type representing a Bidirectional Reflectance Distribution Function.</p><p>Each subtype of this type must include a field <code>pigment::</code><a href="#Raytracer.Pigment"><code>Pigment</code></a> storing the pigment on which the BRDF operates. Each subtype of this type must implement an <code>at(::NewBRDF, ::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D)</code> function, where <code>NewBRDF</code> should be swubstituted with your new type name. This function evaluates the BRDF of a point with given normal, input and output directions and uv coordinates (which are used to evaluate)</p><p>See also: <a href="#Raytracer.DiffuseBRDF"><code>DiffuseBRDF</code></a>, <a href="#Raytracer.SpecularBRDF"><code>SpecularBRDF</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L168-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.CheckeredPigment" href="#Raytracer.CheckeredPigment"><code>Raytracer.CheckeredPigment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CheckeredPigment{N} &lt;: Pigment</code></pre><p>A checkered <a href="#Raytracer.Pigment"><code>Pigment</code></a>. The number of rows/columns in the checkered pattern is tunable with <code>N</code>, but you cannot have a different number of repetitions along the u/v directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.CheckeredPigment-Tuple{}" href="#Raytracer.CheckeredPigment-Tuple{}"><code>Raytracer.CheckeredPigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CheckeredPigment(; N::Int = 2, color_on::RGB{Float32} = WHITE,
                  color_off::RGB{Float32} = BLACK) where {N}</code></pre><p>Constructor for a <a href="#Raytracer.CheckeredPigment"><code>CheckeredPigment</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.CheckeredPigment-Union{Tuple{RGB{Float32}, RGB{Float32}}, Tuple{N}} where N" href="#Raytracer.CheckeredPigment-Union{Tuple{RGB{Float32}, RGB{Float32}}, Tuple{N}} where N"><code>Raytracer.CheckeredPigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CheckeredPigment{N}(color_on::RGB{Float32}, color_off::RGB{Float32}) where {N}</code></pre><p>Constructor for a <a href="#Raytracer.CheckeredPigment"><code>CheckeredPigment</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.CheckeredPigment-Union{Tuple{}, Tuple{N}} where N" href="#Raytracer.CheckeredPigment-Union{Tuple{}, Tuple{N}} where N"><code>Raytracer.CheckeredPigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CheckeredPigment{N}(; color_on::RGB{Float32} = WHITE,
                  color_off::RGB{Float32} = BLACK) where {N}</code></pre><p>Constructor for a <a href="#Raytracer.CheckeredPigment"><code>CheckeredPigment</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.DiffuseBRDF" href="#Raytracer.DiffuseBRDF"><code>Raytracer.DiffuseBRDF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiffuseBRDF &lt;: BRDF</code></pre><p>A class representing an ideal diffuse <a href="#Raytracer.BRDF"><code>BRDF</code></a> (also called &quot;Lambertian&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L185-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.DiffuseBRDF-Tuple{Pigment, Float32}" href="#Raytracer.DiffuseBRDF-Tuple{Pigment, Float32}"><code>Raytracer.DiffuseBRDF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiffuseBRDF(pigment::Pigment, reflectance::Float32)</code></pre><p>Constructor for a <a href="#Raytracer.DiffuseBRDF"><code>DiffuseBRDF</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.DiffuseBRDF-Tuple{}" href="#Raytracer.DiffuseBRDF-Tuple{}"><code>Raytracer.DiffuseBRDF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiffuseBRDF(; pigment::Pigment = UniformPigment(),
              reflectance::Float32 = 1f0)</code></pre><p>Constructor for a <a href="#Raytracer.DiffuseBRDF"><code>DiffuseBRDF</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ImagePigment" href="#Raytracer.ImagePigment"><code>Raytracer.ImagePigment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImagePigment &lt;: Pigment</code></pre><p>A textured <a href="#Raytracer.Pigment"><code>Pigment</code></a>. The texture is given through a PFM image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ImagePigment-Tuple{Float32, Float32}" href="#Raytracer.ImagePigment-Tuple{Float32, Float32}"><code>Raytracer.ImagePigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(ip::ImagePigment)(u::Float32, v::Float32)</code></pre><p>Return the color of the surface in the given point <span>$(u,v)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ImagePigment-Tuple{HdrImage}" href="#Raytracer.ImagePigment-Tuple{HdrImage}"><code>Raytracer.ImagePigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ImagePigment(image::HdrImage)</code></pre><p>Constructor for a <a href="#Raytracer.ImagePigment"><code>ImagePigment</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ImagePigment-Tuple{}" href="#Raytracer.ImagePigment-Tuple{}"><code>Raytracer.ImagePigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ImagePigment(; image::HdrImage = HdrImage(1, 1))</code></pre><p>Constructor for a <a href="#Raytracer.ImagePigment"><code>ImagePigment</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Material" href="#Raytracer.Material"><code>Raytracer.Material</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Material</code></pre><p>A material with a <code>brdf::BRDF</code> (<a href="#Raytracer.BRDF"><code>BRDF</code></a>) and and <code>emitted_radiance::Pigment</code> (<a href="#Raytracer.Pigment"><code>Pigment</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L299-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Material-Tuple{BRDF, Pigment}" href="#Raytracer.Material-Tuple{BRDF, Pigment}"><code>Raytracer.Material</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Material(brdf::BRDF, emitted_radiance::Pigment)</code></pre><p>Constructor for a <a href="#Raytracer.Material"><code>Material</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L309-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Material-Tuple{}" href="#Raytracer.Material-Tuple{}"><code>Raytracer.Material</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Material(; brdf::BRDF = DiffuseBRDF(), emitted_radiance::Pigment = UniformPigment(BLACK))</code></pre><p>Constructor for a <a href="#Raytracer.Material"><code>Material</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Pigment" href="#Raytracer.Pigment"><code>Raytracer.Pigment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pigment</code></pre><p>This abstract type represents a pigment, i.e., a function that associates a color with each point on a parametric surface <span>$(u,v)$</span>.</p><p>Each subtype of this type must be a callable like <code>(p::Pigment)(uv::Vec2D)</code> and must return the color of the surface as a <code>RGB{Float32}</code> in a given <a href="#Raytracer.Vec2D"><code>Vec2D</code></a> point.</p><p>See also: <a href="#Raytracer.UniformPigment"><code>UniformPigment</code></a>, <a href="#Raytracer.CheckeredPigment"><code>CheckeredPigment</code></a>, <a href="#Raytracer.ImagePigment"><code>ImagePigment</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Pigment-Tuple{StaticArrays.SVector{2, Float32}}" href="#Raytracer.Pigment-Tuple{StaticArrays.SVector{2, Float32}}"><code>Raytracer.Pigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(p::Pigment)(uv::Vec2D)</code></pre><p>Return the color of the surface in the given point <a href="#Raytracer.Vec2D"><code>Vec2D</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.SpecularBRDF" href="#Raytracer.SpecularBRDF"><code>Raytracer.SpecularBRDF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpecularBRDF &lt;: BRDF</code></pre><p>A class representing an ideal mirror <a href="#Raytracer.BRDF"><code>BRDF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L243-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.SpecularBRDF-Tuple{Pigment, Float32}" href="#Raytracer.SpecularBRDF-Tuple{Pigment, Float32}"><code>Raytracer.SpecularBRDF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SpecularBRDF(pigment::Pigment, threshold_angle_rad::Float32)</code></pre><p>Constructor for a <a href="#Raytracer.SpecularBRDF"><code>SpecularBRDF</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.SpecularBRDF-Tuple{}" href="#Raytracer.SpecularBRDF-Tuple{}"><code>Raytracer.SpecularBRDF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SpecularBRDF(; pigment::Pigment = UniformPigment(),
               threshold_angle_rad::Float32 = π / 1800f0)</code></pre><p>Constructor for a <a href="#Raytracer.SpecularBRDF"><code>SpecularBRDF</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L259-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.UniformPigment" href="#Raytracer.UniformPigment"><code>Raytracer.UniformPigment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniformPigment &lt;: Pigment</code></pre><p>A uniform <a href="#Raytracer.Pigment"><code>Pigment</code></a> over the whole surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.UniformPigment-Tuple{Float32, Float32}" href="#Raytracer.UniformPigment-Tuple{Float32, Float32}"><code>Raytracer.UniformPigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(up::UniformPigment)(u::Float32, v::Float32)</code></pre><p>Return the color of the surface in the given point <span>$(u,v)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.UniformPigment-Tuple{RGB{Float32}}" href="#Raytracer.UniformPigment-Tuple{RGB{Float32}}"><code>Raytracer.UniformPigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UniformPigment(color::RGB{Float32})</code></pre><p>Constructor for a <a href="#Raytracer.UniformPigment"><code>UniformPigment</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.UniformPigment-Tuple{}" href="#Raytracer.UniformPigment-Tuple{}"><code>Raytracer.UniformPigment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UniformPigment(; color::RGB{Float32} = WHITE)</code></pre><p>Constructor for a <a href="#Raytracer.UniformPigment"><code>UniformPigment</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.at-Tuple{DiffuseBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}" href="#Raytracer.at-Tuple{DiffuseBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}"><code>Raytracer.at</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">at(brdf::DiffuseBRDF, normal::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D)</code></pre><p>Get the radiance, given a point <code>uv</code> (<a href="#Raytracer.Vec2D"><code>Vec2D</code></a>) on the surface with a <a href="#Raytracer.DiffuseBRDF"><code>DiffuseBRDF</code></a>., an incoming direction <code>in_dir</code> and outcoming direction (<a href="#Raytracer.Vec"><code>Vec</code></a>), a <code>normal</code> of the surface point (<a href="#Raytracer.Normal"><code>Normal</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L207-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.at-Tuple{SpecularBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}" href="#Raytracer.at-Tuple{SpecularBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}"><code>Raytracer.at</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">at(brdf::SpecularBRDF, normal::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D)</code></pre><p>Get the radiance, given a point <code>uv</code> (<a href="#Raytracer.Vec2D"><code>Vec2D</code></a>) on the surface with a <a href="#Raytracer.SpecularBRDF"><code>SpecularBRDF</code></a>., an incoming direction <code>in_dir</code> and outcoming direction (<a href="#Raytracer.Vec"><code>Vec</code></a>), a <code>normal</code> of the surface point (<a href="#Raytracer.Normal"><code>Normal</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/materials.jl#L266-L271">source</a></section></article><h2 id="Shapes"><a class="docs-heading-anchor" href="#Shapes">Shapes</a><a id="Shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Shapes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.HitOrMiss" href="#Raytracer.HitOrMiss"><code>Raytracer.HitOrMiss</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HitOrMiss</code></pre><p>Alias for <code>Union{HitRecord, Nothing}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hitrecord.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.HitRecord" href="#Raytracer.HitRecord"><code>Raytracer.HitRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HitRecord</code></pre><p>A struct representing the result of an intersection between a <a href="#Raytracer.Ray"><code>Ray</code></a> and a <a href="#Raytracer.Shape"><code>Shape</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>world_point::Point</code>: a <a href="#Raytracer.Point"><code>Point</code></a> representing the world coordinates of the hit point.</li><li><code>normal::Normal</code>: a <a href="#Raytracer.Normal"><code>Normal</code></a> representing the orientation of the normal to the surface where the hit happened.</li><li><code>surface_point::Vec2D</code>: a <a href="#Raytracer.Vec2D"><code>Vec2D</code></a> representing the position of the hit point on the surface of the object.</li><li><code>t::Float32</code>: distance from the origin of the ray where the hit happened.</li><li><code>ray::Ray</code>: a <a href="#Raytracer.Ray"><code>Ray</code></a> representing the the ray that hit the surface.</li><li><code>material::Material</code>: a <a href="#Raytracer.Material"><code>Material</code></a> representing the material of the point where the hit happened.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/hitrecord.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Shape" href="#Raytracer.Shape"><code>Raytracer.Shape</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Shape</code></pre><p>An abstract type representing a shape.</p><p>See also: <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a>, <a href="../../devs/private-api/#Raytracer.CompositeShape"><code>CompositeShape</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.all_ray_intersections-Tuple{Ray, Shape}" href="#Raytracer.all_ray_intersections-Tuple{Ray, Shape}"><code>Raytracer.all_ray_intersections</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">all_ray_intersections(ray, s)</code></pre><p>Return a <code>Vector</code> of <a href="#Raytracer.HitRecord"><code>HitRecord</code></a>s of all the ray intersections with the given <a href="#Raytracer.Shape"><code>Shape</code></a> for every finite value of <code>t</code>, even outside of the ray domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.all_ray_intersections-Union{Tuple{S}, Tuple{Ray, S}} where S&lt;:SimpleShape" href="#Raytracer.all_ray_intersections-Union{Tuple{S}, Tuple{Ray, S}} where S&lt;:SimpleShape"><code>Raytracer.all_ray_intersections</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">all_ray_intersections(ray::Ray, s::S) where {S &lt;: SimpleShape}</code></pre><p>Return a vector of <a href="#Raytracer.HitRecord"><code>HitRecord</code></a> with all the <a href="#Raytracer.Ray"><code>Ray</code></a> intersections with the given <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a>. If none exists, return an empty vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L149-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.get_all_ts-Tuple{Shape, Ray}" href="#Raytracer.get_all_ts-Tuple{Shape, Ray}"><code>Raytracer.get_all_ts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_all_ts(s::Shape, ray::Ray)</code></pre><p>Return a <code>Vector</code> of the hit parameter <code>t</code> against the given <a href="#Raytracer.Shape"><code>Shape</code></a>, even outside of the ray domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.get_all_ts-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Ray}" href="#Raytracer.get_all_ts-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Ray}"><code>Raytracer.get_all_ts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_all_ts(::Type{&lt;:SimpleShape}, ray::Ray)</code></pre><p>Return a <code>Vector</code> of the hit parameter <code>t</code> against the unitary shape of the given <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a> type, even outside of the ray domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.get_normal-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Point, Ray}" href="#Raytracer.get_normal-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Point, Ray}"><code>Raytracer.get_normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_normal(::Type{&lt;:SimpleShape}, ::Point, ::Ray)</code></pre><p>Return the <a href="#Raytracer.Normal"><code>Normal</code></a><code>{true}</code> of a shape given a point on its surface and the ray that hits it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.get_t-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Ray}" href="#Raytracer.get_t-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Ray}"><code>Raytracer.get_t</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_t(::Type{&lt;:SimpleShape}, ray::Ray)</code></pre><p>Return the parameter <code>t</code> at which <a href="#Raytracer.Ray"><code>Ray</code></a> first hits the unitary <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a>. If no hit exists, return <code>Inf32</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.get_uv-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Point}" href="#Raytracer.get_uv-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Point}"><code>Raytracer.get_uv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_uv(::Type{&lt;:SimpleShape}, ::Point)</code></pre><p>Return the uv coordinates of a shape associated with the given point on its surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.quick_ray_intersection-Tuple{Ray, Shape}" href="#Raytracer.quick_ray_intersection-Tuple{Ray, Shape}"><code>Raytracer.quick_ray_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quick_ray_intersection(ray, s)</code></pre><p>Return whether the ray intersects the given <a href="#Raytracer.Shape"><code>Shape</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.quick_ray_intersection-Tuple{Ray, SimpleShape}" href="#Raytracer.quick_ray_intersection-Tuple{Ray, SimpleShape}"><code>Raytracer.quick_ray_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quick_ray_intersection(ray::Ray, s::SimpleShape)</code></pre><p>Tells if a <a href="#Raytracer.Ray"><code>Ray</code></a> intersect a <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a> or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ray_intersection-Tuple{Ray, Shape}" href="#Raytracer.ray_intersection-Tuple{Ray, Shape}"><code>Raytracer.ray_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ray_intersection(ray, s)</code></pre><p>Return an <a href="#Raytracer.HitRecord"><code>HitRecord</code></a> of the nearest ray intersection with the given <a href="#Raytracer.Shape"><code>Shape</code></a>, if none exists, return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ray_intersection-Union{Tuple{S}, Tuple{Ray, S}} where S&lt;:SimpleShape" href="#Raytracer.ray_intersection-Union{Tuple{S}, Tuple{Ray, S}} where S&lt;:SimpleShape"><code>Raytracer.ray_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ray_intersection(ray::Ray, s::S) where {S &lt;: SimpleShape}</code></pre><p>Return an <a href="#Raytracer.HitRecord"><code>HitRecord</code></a> of the nearest <a href="#Raytracer.Ray"><code>Ray</code></a> intersection with the given <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a>. If none exists, return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.World" href="#Raytracer.World"><code>Raytracer.World</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">World</code></pre><p>Alias of <code>Vector{Shape}</code>, to store a list of <a href="#Raytracer.Shape"><code>Shape</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/world.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.is_point_visible-Tuple{Vector{Shape}, Point, Point}" href="#Raytracer.is_point_visible-Tuple{Vector{Shape}, Point, Point}"><code>Raytracer.is_point_visible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_point_visible(world::World, point::Point, observer_pos::Point)</code></pre><p>Tells if a particular <a href="#Raytracer.Point"><code>Point</code></a> in a <a href="#Raytracer.World"><code>World</code></a> filled with <a href="#Raytracer.Shape"><code>Shape</code></a> is visible from the observer position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/world.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ray_intersection-Tuple{Ray, Vector{Shape}}" href="#Raytracer.ray_intersection-Tuple{Ray, Vector{Shape}}"><code>Raytracer.ray_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ray_intersection(ray::Ray, world::World)</code></pre><p>Intersect a <a href="#Raytracer.Ray"><code>Ray</code></a> with each <a href="#Raytracer.Shape"><code>Shape</code></a> in <a href="#Raytracer.World"><code>World</code></a> and return the nearest hit point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/world.jl#L15-L19">source</a></section></article><h3 id="Simple-shapes"><a class="docs-heading-anchor" href="#Simple-shapes">Simple shapes</a><a id="Simple-shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-shapes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Cube" href="#Raytracer.Cube"><code>Raytracer.Cube</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cube &lt;: SimpleShape</code></pre><p>A <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a> representing a cube of unitary size.</p><p><strong>Members</strong></p><ul><li><code>transformation::Transformation</code>: the <code>Transformation</code> associated with the cube.</li><li><code>material::Material</code>: the <a href="#Raytracer.Material"><code>Material</code></a> of the cube.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/cube.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Cube-Tuple{Transformation, Material}" href="#Raytracer.Cube-Tuple{Transformation, Material}"><code>Raytracer.Cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Cube(transformation::Transformation, material::Material)</code></pre><p>Constructor for a <a href="#Raytracer.Cube"><code>Cube</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/cube.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Cube-Tuple{}" href="#Raytracer.Cube-Tuple{}"><code>Raytracer.Cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Cube(transformation::Transformation = Transformation(),
       material::Material = Material())</code></pre><p>Constructor for a <a href="#Raytracer.Cube"><code>Cube</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/cube.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Cylinder" href="#Raytracer.Cylinder"><code>Raytracer.Cylinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cylinder &lt;: SimpleShape</code></pre><p>A <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a> representing a cylinder of unitary height and diameter.</p><p><strong>Members</strong></p><ul><li><code>transformation::Transformation</code>: the <code>Transformation</code> associated with the cylinder.</li><li><code>material::Material</code>: the <a href="#Raytracer.Material"><code>Material</code></a> of the cylinder.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/cylinder.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Cylinder-Tuple{Transformation, Material}" href="#Raytracer.Cylinder-Tuple{Transformation, Material}"><code>Raytracer.Cylinder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Cylinder(transformation::Transformation, material::Material)</code></pre><p>Constructor for a <a href="#Raytracer.Cylinder"><code>Cylinder</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/cylinder.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Cylinder-Tuple{}" href="#Raytracer.Cylinder-Tuple{}"><code>Raytracer.Cylinder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Cylinder(transformation::Transformation = Transformation(),
       material::Material = Material())</code></pre><p>Constructor for a <a href="#Raytracer.Cylinder"><code>Cylinder</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/cylinder.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Plane" href="#Raytracer.Plane"><code>Raytracer.Plane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Plane &lt;: SimpleShape</code></pre><p>A <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a> representing an infinite plane.</p><p><strong>Members</strong></p><ul><li><code>transformation::Transformation</code>: the <code>Transformation</code> associated with the plane.</li><li><code>material::Material</code>: the <a href="#Raytracer.Material"><code>Material</code></a> of the plane.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/plane.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Plane-Tuple{Transformation, Material}" href="#Raytracer.Plane-Tuple{Transformation, Material}"><code>Raytracer.Plane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Plane(transformation::Transformation, material::Material)</code></pre><p>Constructor for a <a href="#Raytracer.Plane"><code>Plane</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/plane.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Plane-Tuple{}" href="#Raytracer.Plane-Tuple{}"><code>Raytracer.Plane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Plane(transformation::Transformation = Transformation(),
       material::Material = Material())</code></pre><p>Constructor for a <a href="#Raytracer.Plane"><code>Plane</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/plane.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Sphere" href="#Raytracer.Sphere"><code>Raytracer.Sphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Sphere &lt;: SimpleShape</code></pre><p>A <a href="../../devs/private-api/#Raytracer.SimpleShape"><code>SimpleShape</code></a> representing a sphere.</p><p>This is a unitary sphere centered in the origin. A generic sphere can be specified by applying a <a href="#Raytracer.Transformation"><code>Transformation</code></a>.</p><p><strong>Members</strong></p><ul><li><code>transformation::Transformation</code>: the <code>Transformation</code> associated with the sphere.</li><li><code>material::Material</code>: the <a href="#Raytracer.Material"><code>Material</code></a> of the spere.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/sphere.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Sphere-Tuple{Transformation, Material}" href="#Raytracer.Sphere-Tuple{Transformation, Material}"><code>Raytracer.Sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Sphere(transformation::Transformation, material::Material)</code></pre><p>Constructor for a <a href="#Raytracer.Sphere"><code>Sphere</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/sphere.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Sphere-Tuple{}" href="#Raytracer.Sphere-Tuple{}"><code>Raytracer.Sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Sphere(transformation::Transformation = Transformation(),
       material::Material = Material())</code></pre><p>Constructor for a <a href="#Raytracer.Sphere"><code>Sphere</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/sphere.jl#L31-L36">source</a></section></article><h3 id="Composite-shapes"><a class="docs-heading-anchor" href="#Composite-shapes">Composite shapes</a><a id="Composite-shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-shapes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Raytracer.CSG" href="#Raytracer.CSG"><code>Raytracer.CSG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CSG{R} &lt;: CompositeShape</code></pre><p>A <a href="#Raytracer.Shape"><code>Shape</code></a> representing a Constructive Solid Geometry tree.</p><p>The behavior of the CSG tree is determined by the <a href="#Raytracer.Rule"><code>Rule</code></a> <code>R</code>.</p><p><strong>Members</strong></p><ul><li><code>rbranch::Shape</code>: represents the right branch of the tree</li><li><code>lbranch::Shape</code>: represents the left branch of the tree</li><li><code>transformation::Transformation</code>: represents the <a href="#Raytracer.Transformation"><code>Transformation</code></a> of the whole composite shape</li></ul><p><strong>External references</strong></p><ul><li>Constructive Solid Geometry: https://en.wikipedia.org/wiki/Constructive<em>solid</em>geometry</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/csg.jl#L47-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.DiffCSG" href="#Raytracer.DiffCSG"><code>Raytracer.DiffCSG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiffCSG</code></pre><p>Alias for <code>CSG{DiffRule}</code>.</p><p>See also: <a href="#Raytracer.CSG"><code>CSG</code></a>, <a href="#Raytracer.Rule"><code>Rule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/csg.jl#L98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.FusionCSG" href="#Raytracer.FusionCSG"><code>Raytracer.FusionCSG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FusionCSG</code></pre><p>Alias for <code>CSG{FuseRule}</code>.</p><p>See also: <a href="#Raytracer.CSG"><code>CSG</code></a>, <a href="#Raytracer.Rule"><code>Rule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/csg.jl#L107-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.IntersectionCSG" href="#Raytracer.IntersectionCSG"><code>Raytracer.IntersectionCSG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IntersectionCSG</code></pre><p>Alias for <code>CSG{IntersectRule}</code>.</p><p>See also: <a href="#Raytracer.CSG"><code>CSG</code></a>, <a href="#Raytracer.Rule"><code>Rule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/csg.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Rule" href="#Raytracer.Rule"><code>Raytracer.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rule</code></pre><p>Enum type representing the hit point selection of a <a href="#Raytracer.CSG"><code>CSG</code></a>.</p><p><strong>Instances</strong></p><ul><li><code>UniteRule</code>: indicates that every hit point is valid</li><li><code>IntersectRule</code>: indicates that only hit points located inside of other shapes are valid</li><li><code>DiffRule</code>: indicates that only hit points outside of the <code>lbranch</code> and inside the <code>rbranch</code> are valid</li><li><code>FuseRule</code>: indicates that every hit point outside of other shapes is valid</li></ul><p>See also: <a href="#Raytracer.CSG"><code>CSG</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/csg.jl#L26-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.UnionCSG" href="#Raytracer.UnionCSG"><code>Raytracer.UnionCSG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UnionCSG</code></pre><p>Alias for <code>CSG{UniteRule}</code>.</p><p>See also: <a href="#Raytracer.CSG"><code>CSG</code></a>, <a href="#Raytracer.Rule"><code>Rule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/csg.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.fuse-Tuple{Shape, Shape}" href="#Raytracer.fuse-Tuple{Shape, Shape}"><code>Raytracer.fuse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fuse(s1::Shape, s2::Shape); transformation::Transformation = Transformation())</code></pre><p>Construct a <a href="#Raytracer.FusionCSG"><code>FusionCSG</code></a> with the given shapes as <code>rbranch</code> and <code>lbranch</code> repectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/csg.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.fuse-Tuple{Shape, Vararg{Shape, N} where N}" href="#Raytracer.fuse-Tuple{Shape, Vararg{Shape, N} where N}"><code>Raytracer.fuse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fuse(s::Shape, ss::Shape...); transformation::Transformation = Transformation())</code></pre><p>Construct a <a href="#Raytracer.FusionCSG"><code>FusionCSG</code></a> binary tree, by recursively calling <a href="../../devs/private-api/#Base.intersect-Tuple{Shape, Shape}"><code>intersect</code></a><code>(::Shape, ::Shape)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/csg.jl#L187-L191">source</a></section></article><h3 id="AABB"><a class="docs-heading-anchor" href="#AABB">AABB</a><a id="AABB-1"></a><a class="docs-heading-anchor-permalink" href="#AABB" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Raytracer.get_t-Tuple{Ray, Raytracer.AABB}" href="#Raytracer.get_t-Tuple{Ray, Raytracer.AABB}"><code>Raytracer.get_t</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_t(ray::Ray, aabb::AABB)</code></pre><p>Return the parameter <code>t</code> at which <a href="#Raytracer.Ray"><code>Ray</code></a> first hits the <a href="../../devs/private-api/#Raytracer.AABB"><code>AABB</code></a>. If no hit exists, return <code>Inf32</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/shapes/aabb.jl#L18-L22">source</a></section></article><h2 id="Lights"><a class="docs-heading-anchor" href="#Lights">Lights</a><a id="Lights-1"></a><a class="docs-heading-anchor-permalink" href="#Lights" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Lights" href="#Raytracer.Lights"><code>Raytracer.Lights</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lights</code></pre><p>Alias of <code>Vector{PointLight}</code>, to store a list of <a href="#Raytracer.PointLight"><code>PointLight</code></a> sources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/lights.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PointLight" href="#Raytracer.PointLight"><code>Raytracer.PointLight</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointLight</code></pre><p>A point light (used by <a href="#Raytracer.PointLightRenderer"><code>PointLightRenderer</code></a>).</p><p>This type holds information about a point light.</p><p><strong>Fields</strong></p><ul><li><code>position::Point</code>: a <a href="#Raytracer.Point"><code>Point</code></a> object holding the position of the point light in 3D space.</li><li><code>color::RGB{Float32}</code>: the color of the point light.</li><li><code>linear_radius::Float32</code>: radius of the source, used to compute solid angle subtended by the light.</li></ul><p>If <code>linear_radius</code> is non-zero, it is used to compute the solid angle subtended by the light at a given distance <code>d</code> through the formula:</p><p class="math-container">\[\left(\frac{\mathrm{linear\_radius}}{d}\right)^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/lights.jl#L8-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PointLight-Tuple{Point, RGB{Float32}, Float32}" href="#Raytracer.PointLight-Tuple{Point, RGB{Float32}, Float32}"><code>Raytracer.PointLight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PointLight(position::Point, color::RGB{Float32}, linear_radius::Float32)</code></pre><p>Constructor for a <a href="#Raytracer.PointLight"><code>PointLight</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/lights.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PointLight-Tuple{}" href="#Raytracer.PointLight-Tuple{}"><code>Raytracer.PointLight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PointLight(; position::Point = ORIGIN,
             color::RGB{Float32} = WHITE,
             linear_radius::Float32 = 0f0)</code></pre><p>Constructor for a <a href="#Raytracer.PointLight"><code>PointLight</code></a> instance.</p><p>If no parameter is specified, it return a white point light in the origin with no radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/lights.jl#L40-L48">source</a></section></article><h2 id="PCG-random-number-generator"><a class="docs-heading-anchor" href="#PCG-random-number-generator">PCG random number generator</a><a id="PCG-random-number-generator-1"></a><a class="docs-heading-anchor-permalink" href="#PCG-random-number-generator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PCG" href="#Raytracer.PCG"><code>Raytracer.PCG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct PCG &lt;: AbstractRNG</code></pre><p>Random number generator that implement the Permuted Congruential Generator, a simple fast space-efficient statistically good algorithms for random number generation. See <a href="https://www.pcg-random.org/paper.html">O&#39;Neill (2014)</a>.</p><p><strong>Fields</strong></p><ul><li><code>state::UInt64</code>: the state of the generator.</li><li><code>inc::UInt64</code>: sequence identifier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/pcg.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PCG-Tuple{UInt64, UInt64}" href="#Raytracer.PCG-Tuple{UInt64, UInt64}"><code>Raytracer.PCG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PCG(state::UInt64 = UInt64(42), inc::UInt64 = UInt64(54))</code></pre><p>Constructor for a <a href="#Raytracer.PCG"><code>PCG</code></a> instance.</p><p>If no parameter is specified, the generated instance will have a state of 42 and a sequence identifier of 54.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/pcg.jl#L32-L38">source</a></section></article><h2 id="Renderer"><a class="docs-heading-anchor" href="#Renderer">Renderer</a><a id="Renderer-1"></a><a class="docs-heading-anchor-permalink" href="#Renderer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.FlatRenderer" href="#Raytracer.FlatRenderer"><code>Raytracer.FlatRenderer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FlatRenderer &lt;: Renderer</code></pre><p>A basic <a href="#Raytracer.Renderer"><code>Renderer</code></a> that returns the color of the <a href="#Raytracer.Shape"><code>Shape</code></a> first hit by a given <a href="#Raytracer.Ray"><code>Ray</code></a>.</p><p>This renderer returns the color stored in the <code>material</code> field of the <a href="#Raytracer.Shape"><code>Shape</code></a> first hit by the given <a href="#Raytracer.Ray"><code>Ray</code></a> at the hit point. To this renderer there is no difference between radiated light and reflected color. There are no shades, diffusions or reflections. If there are no hits this renderer returns the value of its field <code>background_color</code>.</p><p><strong>Fields</strong></p><ul><li><code>world::World</code>: the <a href="#Raytracer.World"><code>World</code></a> to render.</li><li><code>background_color::RGB{Float32}</code>: color if the ray do not collide.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L73-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.FlatRenderer-Tuple{Ray}" href="#Raytracer.FlatRenderer-Tuple{Ray}"><code>Raytracer.FlatRenderer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(oor::FlatRenderer)(ray::Ray)</code></pre><p>Render a <a href="#Raytracer.Ray"><code>Ray</code></a> and return a <code>RBG{Float32}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.FlatRenderer-Tuple{Vector{Shape}, RGB{Float32}}" href="#Raytracer.FlatRenderer-Tuple{Vector{Shape}, RGB{Float32}}"><code>Raytracer.FlatRenderer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FlatRenderer(world::World, background_color::RGB{Float32})</code></pre><p>Constructor for a <a href="#Raytracer.FlatRenderer"><code>FlatRenderer</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.FlatRenderer-Tuple{Vector{Shape}}" href="#Raytracer.FlatRenderer-Tuple{Vector{Shape}}"><code>Raytracer.FlatRenderer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FlatRenderer(world::World; background_color::RGB{Float32} = BLACK)</code></pre><p>Constructor for a <a href="#Raytracer.FlatRenderer"><code>FlatRenderer</code></a> instance.</p><p>If no color is specified, it will default on <a href="#Raytracer.BLACK"><code>BLACK</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.OnOffRenderer" href="#Raytracer.OnOffRenderer"><code>Raytracer.OnOffRenderer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OnOffRenderer &lt;: Renderer</code></pre><p>A basic bichrome <a href="#Raytracer.Renderer"><code>Renderer</code></a> that checks whether a <a href="#Raytracer.Ray"><code>Ray</code></a> has collided or not.</p><p>This renderer returns its field <code>off_color</code> when the given <code>Ray</code> is <code>nothing</code>, else it returns its field <code>on_color</code>.</p><p><strong>Fields</strong></p><ul><li><code>world::World</code>: the <a href="#Raytracer.World"><code>World</code></a> to render.</li><li><code>on_color::RGB{Float32}</code>: color if the ray collide.</li><li><code>off_color::RGB{Float32}</code>: color if the ray do not collide.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L24-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.OnOffRenderer-Tuple{Ray}" href="#Raytracer.OnOffRenderer-Tuple{Ray}"><code>Raytracer.OnOffRenderer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(oor::OnOffRenderer)(ray::Ray)</code></pre><p>Render a <a href="#Raytracer.Ray"><code>Ray</code></a> and return a <code>RBG{Float32}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.OnOffRenderer-Tuple{Vector{Shape}, RGB{Float32}, RGB{Float32}}" href="#Raytracer.OnOffRenderer-Tuple{Vector{Shape}, RGB{Float32}, RGB{Float32}}"><code>Raytracer.OnOffRenderer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OnOffRenderer(world::World, on_color::RGB{Float32}, off_color::RGB{Float32})</code></pre><p>Constructor for a <a href="#Raytracer.OnOffRenderer"><code>OnOffRenderer</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.OnOffRenderer-Tuple{Vector{Shape}}" href="#Raytracer.OnOffRenderer-Tuple{Vector{Shape}}"><code>Raytracer.OnOffRenderer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OnOffRenderer(world::World
              ; on_color::RGB{Float32} = WHITE,
                off_color::RGB{Float32} = BLACK)</code></pre><p>Constructor for a <a href="#Raytracer.OnOffRenderer"><code>OnOffRenderer</code></a> instance.</p><p>If no color is specified, it will default on <a href="#Raytracer.WHITE"><code>WHITE</code></a> and <a href="#Raytracer.BLACK"><code>BLACK</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PathTracer" href="#Raytracer.PathTracer"><code>Raytracer.PathTracer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PathTracer &lt;: Renderer</code></pre><p>A path-tracing <a href="#Raytracer.Renderer"><code>Renderer</code></a> that considers the optical path of a <a href="#Raytracer.Ray"><code>Ray</code></a> from the observer to a light source.</p><p><strong>Fields</strong></p><ul><li><code>world::World</code>: the <a href="#Raytracer.World"><code>World</code></a> to render.</li><li><code>background_color::RGB{Float32}</code>: color if the ray do not collide.</li><li><code>rng::PCG</code>: a <a href="#Raytracer.PCG"><code>PCG</code></a> random number generator to appropriately scatter rays.</li><li><code>n::Int</code>: how many scattered rays should be generated for the mc integration.</li><li><code>max_depth::Int</code>: the maximum number of scatters a ray should be subjected to before stopping.</li><li><code>roulette_depth::Int</code>: the depth at which the russian roulette algorithm should start (if &gt; &#39;max_depth` then it will never start).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L121-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PathTracer-Tuple{Ray}" href="#Raytracer.PathTracer-Tuple{Ray}"><code>Raytracer.PathTracer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(oor::PathTracer)(ray::Ray)</code></pre><p>Render a <a href="#Raytracer.Ray"><code>Ray</code></a> and return a <code>RBG{Float32}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PathTracer-Tuple{Vector{Shape}, RGB{Float32}, PCG, Int64, Int64, Int64}" href="#Raytracer.PathTracer-Tuple{Vector{Shape}, RGB{Float32}, PCG, Int64, Int64, Int64}"><code>Raytracer.PathTracer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PathTracer(world::World, background_color::RGB{Float32}, rng::PCG, n::Int, max_depth::Int, roulette_depth::Int)</code></pre><p>Constructor for a <a href="#Raytracer.PathTracer"><code>PathTracer</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PathTracer-Tuple{Vector{Shape}}" href="#Raytracer.PathTracer-Tuple{Vector{Shape}}"><code>Raytracer.PathTracer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PathTracer(world::World
           ; background_color::RGB{Float32} = BLACK,
             rng::PCG = PCG(),
             n::Int = 10,
             max_depth::Int = 2,
             roulette_depth::Int = 3)</code></pre><p>Constructor for a <a href="#Raytracer.PathTracer"><code>PathTracer</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PointLightRenderer" href="#Raytracer.PointLightRenderer"><code>Raytracer.PointLightRenderer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointLightRenderer &lt;: Renderer</code></pre><p>Point-light tracing <a href="#Raytracer.Renderer"><code>Renderer</code></a>. This renderer is similar to what POV-Ray provides by default.</p><p><strong>Fields</strong></p><ul><li><code>world::World</code>: the <a href="#Raytracer.World"><code>World</code></a> to render.</li><li><code>lights::Lights</code>: a <a href="#Raytracer.Lights"><code>Lights</code></a> instance that contain a list of lights.</li><li><code>background_color::RGB{Float32}</code>: color if the ray do not collide.</li><li><code>ambient_color::RGB{Float32}</code>: the ambient color of the scene.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L222-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PointLightRenderer-Tuple{Ray}" href="#Raytracer.PointLightRenderer-Tuple{Ray}"><code>Raytracer.PointLightRenderer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(oor::PointLightRenderer)(ray::Ray)</code></pre><p>Render a <a href="#Raytracer.Ray"><code>Ray</code></a> and return a <code>RBG{Float32}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L258-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}, RGB{Float32}, RGB{Float32}}" href="#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}, RGB{Float32}, RGB{Float32}}"><code>Raytracer.PointLightRenderer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PointLightRenderer(world::World, lights::Lights, background_color::RGB{Float32}, ambient_color::RGB{Float32})</code></pre><p>Constructor for a <a href="#Raytracer.PointLightRenderer"><code>PointLightRenderer</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}}" href="#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}}"><code>Raytracer.PointLightRenderer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PointLightRenderer(world::World, lights::Lights
                   ; background_color::RGB{Float32} = BLACK,
                     ambient_color::RGB{Float32} = WHITE * 1f-3)</code></pre><p>Constructor for a <a href="#Raytracer.PointLightRenderer"><code>PointLightRenderer</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L247-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.Renderer" href="#Raytracer.Renderer"><code>Raytracer.Renderer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Renderer</code></pre><p>Abstract type for functors that map <a href="#Raytracer.Ray"><code>Ray</code></a> to <code>RGB{Float32}</code>.</p><p>Each subtype of this type must be a callable like <code>(r::Renderer)(ray::Ray)</code> and must return a <code>RGB{Float32}</code>. Each subtype of this type should have a member of type <a href="#Raytracer.World"><code>World</code></a> to check for intersections of the given <a href="#Raytracer.Ray"><code>Ray</code></a>.</p><p>See also: <a href="#Raytracer.OnOffRenderer"><code>OnOffRenderer</code></a>, <a href="#Raytracer.FlatRenderer"><code>FlatRenderer</code></a>, <a href="#Raytracer.PathTracer"><code>PathTracer</code></a>, <a href="#Raytracer.PointLightRenderer"><code>PointLightRenderer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/renderers.jl#L8-L17">source</a></section></article><h2 id="Image-tracer"><a class="docs-heading-anchor" href="#Image-tracer">Image tracer</a><a id="Image-tracer-1"></a><a class="docs-heading-anchor-permalink" href="#Image-tracer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ImageTracer" href="#Raytracer.ImageTracer"><code>Raytracer.ImageTracer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImageTracer</code></pre><p>Trace an image by shooting light rays through each of its pixels.</p><p>To fill an image store it into <code>ImageTracer</code> along with the desired camera and apply <a href="#Raytracer.fire_all_rays!-Tuple{ImageTracer, Renderer}"><code>fire_all_rays!</code></a> to it. Alternatively apply iteratively <a href="#Raytracer.fire_ray-Tuple{ImageTracer, Int64, Int64}"><code>fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32)</code></a> on the desired ranges.</p><p><strong>Fields</strong></p><ul><li><code>image::HdrImage</code>: a <a href="#Raytracer.HdrImage"><code>HdrImage</code></a> in which save the rendered image.</li><li><code>camera::Camera</code>: a <a href="#Raytracer.Camera"><code>Camera</code></a> holding the observer informations.</li><li><code>samples_per_side::Int</code>: the number of samples per side of a pixel for antialiasing algorithm.</li><li><code>rng::PCG</code>: a <a href="#Raytracer.PCG"><code>PCG</code></a> random number generator for antialiasing algorithm.</li></ul><p>If <code>samples_per_side</code> is larger than zero, antialiasing will be applied to each pixel in the image, using the random number generator <code>rng</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/imagetracer.jl#L8-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ImageTracer-Tuple{HdrImage, Camera, Int64, PCG}" href="#Raytracer.ImageTracer-Tuple{HdrImage, Camera, Int64, PCG}"><code>Raytracer.ImageTracer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ImageTracer(image::HdrImage, camera::Camera, samples_per_side::Int, rng::PCG)</code></pre><p>Constructor for an <a href="#Raytracer.ImageTracer"><code>ImageTracer</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/imagetracer.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.ImageTracer-Tuple{HdrImage, Camera}" href="#Raytracer.ImageTracer-Tuple{HdrImage, Camera}"><code>Raytracer.ImageTracer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ImageTracer(image::HdrImage, camera::Camera
            ; samples_per_side::Int = 0,
              rng::PCG = PCG())</code></pre><p>Construct a <a href="#Raytracer.ImageTracer"><code>ImageTracer</code></a>.</p><p>If <code>samples_per_side</code> is not specified, antialiasing will be disabled and <code>rng</code> is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/imagetracer.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.fire_all_rays!-Tuple{ImageTracer, Renderer}" href="#Raytracer.fire_all_rays!-Tuple{ImageTracer, Renderer}"><code>Raytracer.fire_all_rays!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fire_all_rays!(tracer::ImageTracer, renderer::Renderer
               ; use_threads::Bool = true,
                 enable_progress_bar::Bool = true)</code></pre><p>Render an image with informations stored in an <a href="#Raytracer.ImageTracer"><code>ImageTracer</code></a> using the specified <a href="#Raytracer.Renderer"><code>Renderer</code></a>.</p><p>This function apply iteratively <a href="#Raytracer.fire_ray-Tuple{ImageTracer, Int64, Int64}"><code>fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32)</code></a> for each pixel in the image contained in <code>tracer</code> using its camera, and then render the point using <code>renderer</code>.</p><p>If <code>use_threads</code> is <code>true</code>, the function will use the <code>Threads.@threads</code> macro to parallelize the computation.</p><p>If <code>enable_progress_bar</code> is <code>true</code>, the function will display a progress bar during the computation; this is thread safe.</p><p>See also: <a href="#Raytracer.fire_ray-Tuple{ImageTracer, Int64, Int64}"><code>fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/imagetracer.jl#L100-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Raytracer.fire_ray-Tuple{ImageTracer, Int64, Int64}" href="#Raytracer.fire_ray-Tuple{ImageTracer, Int64, Int64}"><code>Raytracer.fire_ray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fire_ray(tracer::ImageTracer, col::Int, row::Int
         ; u_pixel::Float32 = 0.5f0,
           v_pixel::Float32 = 0.5f0)</code></pre><p>Shoot a <a href="#Raytracer.Ray"><code>Ray</code></a> through the pixel <code>(col, row)</code> of the image contained in an [<code>ImageTracer</code>], using its camera informations.</p><p>The function use the <code>fire_ray</code> function of the associated camera (<a href="#Raytracer.fire_ray-Tuple{OrthogonalCamera, Float32, Float32}"><code>fire_ray(::OrthogonalCamera, ::Float32, ::Float32)</code></a>,     <a href="#Raytracer.fire_ray-Tuple{PerspectiveCamera, Float32, Float32}"><code>fire_ray(::PerspectiveCamera, ::Float32, ::Float32)</code></a>)</p><p>The parameters <code>col</code> and <code>row</code> are measured in the same way as they are in <a href="#Raytracer.HdrImage"><code>HdrImage</code></a>: the bottom left corner is placed at <span>$(0, 0)$</span>. The values of <code>u_pixel</code> and <code>v_pixel</code> are floating-point numbers in the range <span>$[0, 1]$</span>: they specify where the ray should cross the pixel; passing 0.5 to both means that the ray will pass through the pixel&#39;s center.</p><p>See also: <a href="#Raytracer.fire_all_rays!-Tuple{ImageTracer, Renderer}"><code>fire_all_rays!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Paolo97Gll/Raytracer.jl/blob/e0cdcac37dd112da001c09663afb22fc9a50e895/src/imagetracer.jl#L55-L72">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Raytracer.BLACK"><code>Raytracer.BLACK</code></a></li><li><a href="#Raytracer.BLUE"><code>Raytracer.BLUE</code></a></li><li><a href="#Raytracer.CYAN"><code>Raytracer.CYAN</code></a></li><li><a href="#Raytracer.GREEN"><code>Raytracer.GREEN</code></a></li><li><a href="#Raytracer.MAGENTA"><code>Raytracer.MAGENTA</code></a></li><li><a href="#Raytracer.NORMAL_X"><code>Raytracer.NORMAL_X</code></a></li><li><a href="#Raytracer.NORMAL_X_false"><code>Raytracer.NORMAL_X_false</code></a></li><li><a href="#Raytracer.NORMAL_Y"><code>Raytracer.NORMAL_Y</code></a></li><li><a href="#Raytracer.NORMAL_Y_false"><code>Raytracer.NORMAL_Y_false</code></a></li><li><a href="#Raytracer.NORMAL_Z"><code>Raytracer.NORMAL_Z</code></a></li><li><a href="#Raytracer.NORMAL_Z_false"><code>Raytracer.NORMAL_Z_false</code></a></li><li><a href="#Raytracer.ORIGIN"><code>Raytracer.ORIGIN</code></a></li><li><a href="#Raytracer.RED"><code>Raytracer.RED</code></a></li><li><a href="#Raytracer.VEC_X"><code>Raytracer.VEC_X</code></a></li><li><a href="#Raytracer.VEC_Y"><code>Raytracer.VEC_Y</code></a></li><li><a href="#Raytracer.VEC_Z"><code>Raytracer.VEC_Z</code></a></li><li><a href="#Raytracer.WHITE"><code>Raytracer.WHITE</code></a></li><li><a href="#Raytracer.YELLOW"><code>Raytracer.YELLOW</code></a></li><li><a href="#Raytracer.BRDF"><code>Raytracer.BRDF</code></a></li><li><a href="#Raytracer.CSG"><code>Raytracer.CSG</code></a></li><li><a href="#Raytracer.Camera"><code>Raytracer.Camera</code></a></li><li><a href="#Raytracer.CheckeredPigment"><code>Raytracer.CheckeredPigment</code></a></li><li><a href="#Raytracer.CheckeredPigment-Tuple{}"><code>Raytracer.CheckeredPigment</code></a></li><li><a href="#Raytracer.CheckeredPigment-Union{Tuple{}, Tuple{N}} where N"><code>Raytracer.CheckeredPigment</code></a></li><li><a href="#Raytracer.CheckeredPigment-Union{Tuple{RGB{Float32}, RGB{Float32}}, Tuple{N}} where N"><code>Raytracer.CheckeredPigment</code></a></li><li><a href="#Raytracer.Cube-Tuple{}"><code>Raytracer.Cube</code></a></li><li><a href="#Raytracer.Cube-Tuple{Transformation, Material}"><code>Raytracer.Cube</code></a></li><li><a href="#Raytracer.Cube"><code>Raytracer.Cube</code></a></li><li><a href="#Raytracer.Cylinder-Tuple{Transformation, Material}"><code>Raytracer.Cylinder</code></a></li><li><a href="#Raytracer.Cylinder"><code>Raytracer.Cylinder</code></a></li><li><a href="#Raytracer.Cylinder-Tuple{}"><code>Raytracer.Cylinder</code></a></li><li><a href="#Raytracer.DiffCSG"><code>Raytracer.DiffCSG</code></a></li><li><a href="#Raytracer.DiffuseBRDF-Tuple{}"><code>Raytracer.DiffuseBRDF</code></a></li><li><a href="#Raytracer.DiffuseBRDF-Tuple{Pigment, Float32}"><code>Raytracer.DiffuseBRDF</code></a></li><li><a href="#Raytracer.DiffuseBRDF"><code>Raytracer.DiffuseBRDF</code></a></li><li><a href="#Raytracer.FlatRenderer-Tuple{Ray}"><code>Raytracer.FlatRenderer</code></a></li><li><a href="#Raytracer.FlatRenderer"><code>Raytracer.FlatRenderer</code></a></li><li><a href="#Raytracer.FlatRenderer-Tuple{Vector{Shape}}"><code>Raytracer.FlatRenderer</code></a></li><li><a href="#Raytracer.FlatRenderer-Tuple{Vector{Shape}, RGB{Float32}}"><code>Raytracer.FlatRenderer</code></a></li><li><a href="#Raytracer.FusionCSG"><code>Raytracer.FusionCSG</code></a></li><li><a href="#Raytracer.HdrImage"><code>Raytracer.HdrImage</code></a></li><li><a href="#Raytracer.HdrImage-Tuple{AbstractVector{var&quot;#s4&quot;} where var&quot;#s4&quot;, Integer, Integer}"><code>Raytracer.HdrImage</code></a></li><li><a href="#Raytracer.HdrImage-Tuple{Integer, Integer}"><code>Raytracer.HdrImage</code></a></li><li><a href="#Raytracer.HdrImage-Tuple{Matrix{RGB{Float32}}}"><code>Raytracer.HdrImage</code></a></li><li><a href="#Raytracer.HitOrMiss"><code>Raytracer.HitOrMiss</code></a></li><li><a href="#Raytracer.HitRecord"><code>Raytracer.HitRecord</code></a></li><li><a href="#Raytracer.ImagePigment-Tuple{HdrImage}"><code>Raytracer.ImagePigment</code></a></li><li><a href="#Raytracer.ImagePigment"><code>Raytracer.ImagePigment</code></a></li><li><a href="#Raytracer.ImagePigment-Tuple{}"><code>Raytracer.ImagePigment</code></a></li><li><a href="#Raytracer.ImagePigment-Tuple{Float32, Float32}"><code>Raytracer.ImagePigment</code></a></li><li><a href="#Raytracer.ImageTracer-Tuple{HdrImage, Camera, Int64, PCG}"><code>Raytracer.ImageTracer</code></a></li><li><a href="#Raytracer.ImageTracer-Tuple{HdrImage, Camera}"><code>Raytracer.ImageTracer</code></a></li><li><a href="#Raytracer.ImageTracer"><code>Raytracer.ImageTracer</code></a></li><li><a href="#Raytracer.IntersectionCSG"><code>Raytracer.IntersectionCSG</code></a></li><li><a href="#Raytracer.Lights"><code>Raytracer.Lights</code></a></li><li><a href="#Raytracer.Material-Tuple{BRDF, Pigment}"><code>Raytracer.Material</code></a></li><li><a href="#Raytracer.Material"><code>Raytracer.Material</code></a></li><li><a href="#Raytracer.Material-Tuple{}"><code>Raytracer.Material</code></a></li><li><a href="#Raytracer.Normal-Tuple{Any, Any, Any}"><code>Raytracer.Normal</code></a></li><li><a href="#Raytracer.Normal"><code>Raytracer.Normal</code></a></li><li><a href="#Raytracer.Normal-Union{Tuple{Float32, Float32, Float32}, Tuple{V}} where V"><code>Raytracer.Normal</code></a></li><li><a href="#Raytracer.OnOffRenderer-Tuple{Vector{Shape}, RGB{Float32}, RGB{Float32}}"><code>Raytracer.OnOffRenderer</code></a></li><li><a href="#Raytracer.OnOffRenderer"><code>Raytracer.OnOffRenderer</code></a></li><li><a href="#Raytracer.OnOffRenderer-Tuple{Ray}"><code>Raytracer.OnOffRenderer</code></a></li><li><a href="#Raytracer.OnOffRenderer-Tuple{Vector{Shape}}"><code>Raytracer.OnOffRenderer</code></a></li><li><a href="#Raytracer.OrthogonalCamera-Tuple{Float32, Transformation}"><code>Raytracer.OrthogonalCamera</code></a></li><li><a href="#Raytracer.OrthogonalCamera"><code>Raytracer.OrthogonalCamera</code></a></li><li><a href="#Raytracer.OrthogonalCamera-Tuple{}"><code>Raytracer.OrthogonalCamera</code></a></li><li><a href="#Raytracer.PCG-Tuple{UInt64, UInt64}"><code>Raytracer.PCG</code></a></li><li><a href="#Raytracer.PCG"><code>Raytracer.PCG</code></a></li><li><a href="#Raytracer.PathTracer-Tuple{Vector{Shape}, RGB{Float32}, PCG, Int64, Int64, Int64}"><code>Raytracer.PathTracer</code></a></li><li><a href="#Raytracer.PathTracer-Tuple{Ray}"><code>Raytracer.PathTracer</code></a></li><li><a href="#Raytracer.PathTracer"><code>Raytracer.PathTracer</code></a></li><li><a href="#Raytracer.PathTracer-Tuple{Vector{Shape}}"><code>Raytracer.PathTracer</code></a></li><li><a href="#Raytracer.PerspectiveCamera"><code>Raytracer.PerspectiveCamera</code></a></li><li><a href="#Raytracer.PerspectiveCamera-Tuple{}"><code>Raytracer.PerspectiveCamera</code></a></li><li><a href="#Raytracer.PerspectiveCamera-Tuple{Float32, Transformation, Float32}"><code>Raytracer.PerspectiveCamera</code></a></li><li><a href="#Raytracer.Pigment"><code>Raytracer.Pigment</code></a></li><li><a href="#Raytracer.Pigment-Tuple{StaticArrays.SVector{2, Float32}}"><code>Raytracer.Pigment</code></a></li><li><a href="#Raytracer.Plane-Tuple{}"><code>Raytracer.Plane</code></a></li><li><a href="#Raytracer.Plane"><code>Raytracer.Plane</code></a></li><li><a href="#Raytracer.Plane-Tuple{Transformation, Material}"><code>Raytracer.Plane</code></a></li><li><a href="#Raytracer.Point-Tuple{AbstractVector{T} where T}"><code>Raytracer.Point</code></a></li><li><a href="#Raytracer.Point-Tuple{Any, Any, Any}"><code>Raytracer.Point</code></a></li><li><a href="#Raytracer.Point"><code>Raytracer.Point</code></a></li><li><a href="#Raytracer.PointLight-Tuple{}"><code>Raytracer.PointLight</code></a></li><li><a href="#Raytracer.PointLight-Tuple{Point, RGB{Float32}, Float32}"><code>Raytracer.PointLight</code></a></li><li><a href="#Raytracer.PointLight"><code>Raytracer.PointLight</code></a></li><li><a href="#Raytracer.PointLightRenderer-Tuple{Ray}"><code>Raytracer.PointLightRenderer</code></a></li><li><a href="#Raytracer.PointLightRenderer"><code>Raytracer.PointLightRenderer</code></a></li><li><a href="#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}}"><code>Raytracer.PointLightRenderer</code></a></li><li><a href="#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}, RGB{Float32}, RGB{Float32}}"><code>Raytracer.PointLightRenderer</code></a></li><li><a href="#Raytracer.Ray-Tuple{Point, Vec, Float32, Float32, Int64}"><code>Raytracer.Ray</code></a></li><li><a href="#Raytracer.Ray-Tuple{Point, Vec}"><code>Raytracer.Ray</code></a></li><li><a href="#Raytracer.Ray"><code>Raytracer.Ray</code></a></li><li><a href="#Raytracer.Ray-Tuple{Float32}"><code>Raytracer.Ray</code></a></li><li><a href="#Raytracer.Renderer"><code>Raytracer.Renderer</code></a></li><li><a href="#Raytracer.Rule"><code>Raytracer.Rule</code></a></li><li><a href="#Raytracer.Shape"><code>Raytracer.Shape</code></a></li><li><a href="#Raytracer.SpecularBRDF-Tuple{}"><code>Raytracer.SpecularBRDF</code></a></li><li><a href="#Raytracer.SpecularBRDF"><code>Raytracer.SpecularBRDF</code></a></li><li><a href="#Raytracer.SpecularBRDF-Tuple{Pigment, Float32}"><code>Raytracer.SpecularBRDF</code></a></li><li><a href="#Raytracer.Sphere"><code>Raytracer.Sphere</code></a></li><li><a href="#Raytracer.Sphere-Tuple{}"><code>Raytracer.Sphere</code></a></li><li><a href="#Raytracer.Sphere-Tuple{Transformation, Material}"><code>Raytracer.Sphere</code></a></li><li><a href="#Raytracer.Transformation"><code>Raytracer.Transformation</code></a></li><li><a href="#Raytracer.Transformation-Tuple{AbstractMatrix{T} where T}"><code>Raytracer.Transformation</code></a></li><li><a href="#Raytracer.Transformation-Tuple{StaticArrays.SMatrix{4, 4, Float32, L} where L, StaticArrays.SMatrix{4, 4, Float32, L} where L}"><code>Raytracer.Transformation</code></a></li><li><a href="#Raytracer.UniformPigment-Tuple{}"><code>Raytracer.UniformPigment</code></a></li><li><a href="#Raytracer.UniformPigment"><code>Raytracer.UniformPigment</code></a></li><li><a href="#Raytracer.UniformPigment-Tuple{Float32, Float32}"><code>Raytracer.UniformPigment</code></a></li><li><a href="#Raytracer.UniformPigment-Tuple{RGB{Float32}}"><code>Raytracer.UniformPigment</code></a></li><li><a href="#Raytracer.UnionCSG"><code>Raytracer.UnionCSG</code></a></li><li><a href="#Raytracer.Vec-Tuple{Float32, Float32, Float32}"><code>Raytracer.Vec</code></a></li><li><a href="#Raytracer.Vec"><code>Raytracer.Vec</code></a></li><li><a href="#Raytracer.Vec2D"><code>Raytracer.Vec2D</code></a></li><li><a href="#Raytracer.World"><code>Raytracer.World</code></a></li><li><a href="#Raytracer.all_ray_intersections-Union{Tuple{S}, Tuple{Ray, S}} where S&lt;:SimpleShape"><code>Raytracer.all_ray_intersections</code></a></li><li><a href="#Raytracer.all_ray_intersections-Tuple{Ray, Shape}"><code>Raytracer.all_ray_intersections</code></a></li><li><a href="#Raytracer.aperture_deg-Tuple{PerspectiveCamera}"><code>Raytracer.aperture_deg</code></a></li><li><a href="#Raytracer.at-Tuple{SpecularBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}"><code>Raytracer.at</code></a></li><li><a href="#Raytracer.at-Tuple{DiffuseBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}"><code>Raytracer.at</code></a></li><li><a href="#Raytracer.create_onb_from_z-Tuple{Normal}"><code>Raytracer.create_onb_from_z</code></a></li><li><a href="#Raytracer.fire_all_rays!-Tuple{ImageTracer, Renderer}"><code>Raytracer.fire_all_rays!</code></a></li><li><a href="#Raytracer.fire_ray-Tuple{ImageTracer, Int64, Int64}"><code>Raytracer.fire_ray</code></a></li><li><a href="#Raytracer.fire_ray-Tuple{PerspectiveCamera, Float32, Float32}"><code>Raytracer.fire_ray</code></a></li><li><a href="#Raytracer.fire_ray-Tuple{OrthogonalCamera, Float32, Float32}"><code>Raytracer.fire_ray</code></a></li><li><a href="#Raytracer.fuse-Tuple{Shape, Vararg{Shape, N} where N}"><code>Raytracer.fuse</code></a></li><li><a href="#Raytracer.fuse-Tuple{Shape, Shape}"><code>Raytracer.fuse</code></a></li><li><a href="#Raytracer.get_all_ts-Tuple{Shape, Ray}"><code>Raytracer.get_all_ts</code></a></li><li><a href="#Raytracer.get_all_ts-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Ray}"><code>Raytracer.get_all_ts</code></a></li><li><a href="#Raytracer.get_normal-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Point, Ray}"><code>Raytracer.get_normal</code></a></li><li><a href="#Raytracer.get_t-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Ray}"><code>Raytracer.get_t</code></a></li><li><a href="#Raytracer.get_t-Tuple{Ray, Raytracer.AABB}"><code>Raytracer.get_t</code></a></li><li><a href="#Raytracer.get_uv-Tuple{Type{var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:SimpleShape, Point}"><code>Raytracer.get_uv</code></a></li><li><a href="#Raytracer.is_point_visible-Tuple{Vector{Shape}, Point, Point}"><code>Raytracer.is_point_visible</code></a></li><li><a href="#Raytracer.isconsistent-Tuple{Transformation}"><code>Raytracer.isconsistent</code></a></li><li><a href="#Raytracer.luminosity-Tuple{RGB}"><code>Raytracer.luminosity</code></a></li><li><a href="#Raytracer.luminosity-Tuple{HdrImage}"><code>Raytracer.luminosity</code></a></li><li><a href="#Raytracer.norm²-Tuple{Vec}"><code>Raytracer.norm²</code></a></li><li><a href="#Raytracer.norm²-Tuple{Normal{false}}"><code>Raytracer.norm²</code></a></li><li><a href="#Raytracer.quick_ray_intersection-Tuple{Ray, SimpleShape}"><code>Raytracer.quick_ray_intersection</code></a></li><li><a href="#Raytracer.quick_ray_intersection-Tuple{Ray, Shape}"><code>Raytracer.quick_ray_intersection</code></a></li><li><a href="#Raytracer.ray_intersection-Tuple{Ray, Vector{Shape}}"><code>Raytracer.ray_intersection</code></a></li><li><a href="#Raytracer.ray_intersection-Union{Tuple{S}, Tuple{Ray, S}} where S&lt;:SimpleShape"><code>Raytracer.ray_intersection</code></a></li><li><a href="#Raytracer.ray_intersection-Tuple{Ray, Shape}"><code>Raytracer.ray_intersection</code></a></li><li><a href="#Raytracer.rotationX"><code>Raytracer.rotationX</code></a></li><li><a href="#Raytracer.rotationY"><code>Raytracer.rotationY</code></a></li><li><a href="#Raytracer.rotationZ"><code>Raytracer.rotationZ</code></a></li><li><a href="#Raytracer.scaling-Tuple{Real, Real, Real}"><code>Raytracer.scaling</code></a></li><li><a href="#Raytracer.translation-Tuple{AbstractVector{T} where T}"><code>Raytracer.translation</code></a></li><li><a href="#Raytracer.γ_correction-Tuple{HdrImage, Float32}"><code>Raytracer.γ_correction</code></a></li><li><a href="#Raytracer.γ_correction-Union{Tuple{T}, Tuple{RGB{T}, Float32}} where T"><code>Raytracer.γ_correction</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../high-level/">« High-level API</a><a class="docs-footer-nextpage" href="../../extendability/">Extendability »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Tuesday 6 July 2021 16:15">Tuesday 6 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
