var documenterSearchIndex = {"docs":
[{"location":"cli/#cli_tool","page":"CLI tool","title":"CLI tool","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"The CLI tool is named raytracer_cli.jl and is placed in the root of the repository. Thanks to the simple usage and the extended help messages, it makes possible the use of this package's high-level features to those who do not know Julia lang.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"This CLI tool recalls functions already present in the Raytracer.jl module, so is possible to run almost all these commands also from the REPL, by calling the same functions called by the tool.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nFor now, the command demo animation is available only with the CLI tool.","category":"page"},{"location":"cli/#Installation","page":"CLI tool","title":"Installation","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"See CLI tool installation.","category":"page"},{"location":"cli/#Usage","page":"CLI tool","title":"Usage","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nYou must call this tool from the repo main folder! It will not work if called by another folder.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"The CLI tool is based on a series of commands, in a similar way to the git and docker CLI tools. The menu tree is:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"raytracer_cli.jl\ntonemapping\ndemo\nimage\nanimation\ndocs","category":"page"},{"location":"cli/#raytracer_cli","page":"CLI tool","title":"raytracer_cli.jl","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl [--version] [-h] {tonemapping|demo|docs}\n\nRaytracing for the generation of photorealistic images in Julia.\n\ncommands:\n  tonemapping  apply tone mapping to a pfm image and save it to file\n  demo         show a demo of Raytracer.jl\n  docs         show the documentation link\n\noptional arguments:\n  --version    show version information and exit\n  -h, --help   show this help message and exit","category":"page"},{"location":"cli/#raytracer_cli_tonemapping","page":"CLI tool","title":"raytracer_cli.jl tonemapping","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nWe support as output image type all the formats supported by the packages ImageIO, ImageMagick and QuartzImageIO, including: jpg, png, tiff, ppm, bmp, gif, ...","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl tonemapping [-a ALPHA] [-g GAMMA] [--version]\n                        [-h] input_file output_file\n\nApply tone mapping to a pfm image and save it to file.\n\noptional arguments:\n  --version          show version information and exit\n  -h, --help         show this help message and exit\n\ntonemapping settings:\n  -a, --alpha ALPHA  scaling factor for the normalization process\n                     (type: Float32, default: 0.5)\n  -g, --gamma GAMMA  gamma value for the tone mapping process (type:\n                     Float32, default: 1.0)\n\nfiles:\n  input_file         path to input file, it must be a PFM file\n  output_file        output file name","category":"page"},{"location":"cli/#raytracer_cli_demo","page":"CLI tool","title":"raytracer_cli.jl demo","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl demo [--version] [-h] {image|animation}\n\nShow a demo of Raytracer.jl.\n\ncommands:\n  image       render a demo image of Raytracer.jl\n  animation   create a demo animation of Raytracer.jl (require ffmpeg)\n\noptional arguments:\n  --version   show version information and exit\n  -h, --help  show this help message and exit","category":"page"},{"location":"cli/#raytracer_cli_demo_image","page":"CLI tool","title":"raytracer_cli.jl demo image","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nThe options camera_position and camera_orientation represent the camera transformations. The application order is: first the translation, then the rotation.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl demo image [--force] [-t CAMERA_TYPE]\n                        [-p CAMERA_POSITION] [-o CAMERA_ORIENTATION]\n                        [-d SCREEN_DISTANCE] [-r IMAGE_RESOLUTION]\n                        [-R RENDERER] [-A ANTIALIASING] [--pt_n PT_N]\n                        [--pt_max_depth PT_MAX_DEPTH]\n                        [--pt_roulette_depth PT_ROULETTE_DEPTH]\n                        [-a ALPHA] [-g GAMMA] [-O OUTPUT_FILE]\n                        [--version] [-h]\n\nRender a demo image of Raytracer.jl.\n\noptional arguments:\n  --force               force overwrite\n  --version             show version information and exit\n  -h, --help            show this help message and exit\n\ncamera:\n  -t, --camera_type CAMERA_TYPE\n                        choose camera type (\"perspective\" or\n                        \"orthogonal\") (default: \"perspective\")\n  -p, --camera_position CAMERA_POSITION\n                        camera position in the scene as \"X,Y,Z\"\n                        (default: \"-3,0,0\")\n  -o, --camera_orientation CAMERA_ORIENTATION\n                        camera orientation as \"angX,angY,angZ\"\n                        (default: \"0,0,0\")\n  -d, --screen_distance SCREEN_DISTANCE\n                        only for \"perspective\" camera: distance\n                        between camera and screen (type: Float32,\n                        default: 2.0)\n\nrendering:\n  -r, --image_resolution IMAGE_RESOLUTION\n                        resolution of the rendered image (default:\n                        \"540:540\")\n  -R, --renderer RENDERER\n                        type of renderer to use (\"onoff\", \"flat\",\n                        \"path\" or \"pointlight\") (default: \"path\")\n  -A, --antialiasing ANTIALIASING\n                        number of samples per pixel (must be a perfect\n                        square) (type: Int64, default: 0)\n\npath-tracer options (only for \"path\" renderer):\n  --pt_n PT_N           number of rays fired for mc integration (type:\n                        Int64, default: 10)\n  --pt_max_depth PT_MAX_DEPTH\n                        maximum number of reflections for each ray\n                        (type: Int64, default: 2)\n  --pt_roulette_depth PT_ROULETTE_DEPTH\n                        depth of the russian-roulette algorithm (type:\n                        Int64, default: 3)\n\ntonemapping:\n  -a, --alpha ALPHA     scaling factor for the normalization process\n                        (type: Float32, default: 0.75)\n  -g, --gamma GAMMA     gamma value for the tone mapping process\n                        (type: Float32, default: 1.0)\n\nfiles:\n  -O, --output_file OUTPUT_FILE\n                        output LDR file name (the HDR file will have\n                        the same name, but with \"pfm\" extension)\n                        (default: \"demo.jpg\")","category":"page"},{"location":"cli/#raytracer_cli_demo_animation","page":"CLI tool","title":"raytracer_cli.jl demo animation","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"This is an advanced function that requires ffmpeg to be installed on the local machine and to be in the PATH. It generates an H.264 mp4 video containing the animation.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nFor now, the generation of animations is available only with the CLI tool.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"note: Note\nThe parameter camera_orientation is not present since the animation is done by rotating the camera around the Z axis and therefore there isn't a fixed camera orientation.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl demo animation [--force] [-t CAMERA_TYPE]\n                        [-p CAMERA_POSITION] [-d SCREEN_DISTANCE]\n                        [-r IMAGE_RESOLUTION] [-R RENDERER]\n                        [-A ANTIALIASING] [--pt_n PT_N]\n                        [--pt_max_depth PT_MAX_DEPTH]\n                        [--pt_roulette_depth PT_ROULETTE_DEPTH]\n                        [-a ALPHA] [-g GAMMA] [-D DELTA_THETA]\n                        [-f FPS] [-F OUTPUT_DIR] [-O OUTPUT_FILE]\n                        [--version] [-h]\n\nCreate a demo animation of Raytracer.jl, by generating n images with\ndifferent camera orientation and merging them into an mp4 video.\nRequire ffmpeg installed on local machine.\n\noptional arguments:\n  --force               force overwrite\n  --version             show version information and exit\n  -h, --help            show this help message and exit\n\nframe camera:\n  -t, --camera_type CAMERA_TYPE\n                        choose camera type (\"perspective\" or\n                        \"orthogonal\") (default: \"perspective\")\n  -p, --camera_position CAMERA_POSITION\n                        camera position in the scene as \"X,Y,Z\"\n                        (default: \"-3,0,0\")\n  -d, --screen_distance SCREEN_DISTANCE\n                        only for \"perspective\" camera: distance\n                        between camera and screen (type: Float32,\n                        default: 2.0)\n\nframe rendering:\n  -r, --image_resolution IMAGE_RESOLUTION\n                        resolution of the rendered image (default:\n                        \"540:540\")\n  -R, --renderer RENDERER\n                        type of renderer to use (\"onoff\", \"flat\",\n                        \"path\" or \"pointlight\") (default: \"path\")\n  -A, --antialiasing ANTIALIASING\n                        number of samples per pixel (must be a perfect\n                        square) (type: Int64, default: 0)\n\npath-tracer options (only for \"path\" renderer):\n  --pt_n PT_N           number of rays fired for mc integration (type:\n                        Int64, default: 10)\n  --pt_max_depth PT_MAX_DEPTH\n                        maximum number of reflections for each ray\n                        (type: Int64, default: 2)\n  --pt_roulette_depth PT_ROULETTE_DEPTH\n                        depth of the russian-roulette algorithm (type:\n                        Int64, default: 3)\n\nframe tonemapping:\n  -a, --alpha ALPHA     scaling factor for the normalization process\n                        (type: Float32, default: 0.75)\n  -g, --gamma GAMMA     gamma value for the tone mapping process\n                        (type: Float32, default: 1.0)\n\nanimation parameter:\n  -D, --delta_theta DELTA_THETA\n                        Δθ in camera orientation (around z axis)\n                        between each frame; the number of frames\n                        generated is [360/Δθ] (type: Float32, default:\n                        10.0)\n  -f, --fps FPS         FPS (frame-per-second) of the output video\n                        (type: Int64, default: 15)\n\nfiles:\n  -F, --output_dir OUTPUT_DIR\n                        output directory (default: \"demo_animation\")\n  -O, --output_file OUTPUT_FILE\n                        name of output frames and animation without\n                        extension (default: \"demo\")","category":"page"},{"location":"cli/#raytracer_cli_docs","page":"CLI tool","title":"raytracer_cli.jl docs","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"usage: raytracer_cli.jl docs [--version] [-h]\n\nShow the documentation link.\n\noptional arguments:\n  --version   show version information and exit\n  -h, --help  show this help message and exit","category":"page"},{"location":"cli/#Multithreading","page":"CLI tool","title":"Multithreading","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"To enable multithreading, e.g. use 8 threads, add -t num_threads after the julia command:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia -t 8 raytracer_cli.jl demo image","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"Here all examples use only one thread, but you can specify the number of threads you prefer.","category":"page"},{"location":"cli/#Examples","page":"CLI tool","title":"Examples","text":"","category":"section"},{"location":"cli/#Tone-mapping","page":"CLI tool","title":"Tone mapping","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can use the tonemapping ray command to apply the tone mapping process to a pfm image. For example, you can use the following command to convert the image test/memorial.pfm into a jpg image:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl tonemapping test/memorial.pfm memorial.jpg","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"(Image: )","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can also convert to a png image:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl tonemapping test/memorial.pfm memorial.png","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"or any other format supported (see here).","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can also change the default values of alpha and/or gamma to obtain a better tone mapping, according to your source image:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl tonemapping --alpha 0.2 --gamma 1.8 test/memorial.pfm memorial.jpg","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"(Image: )","category":"page"},{"location":"cli/#Generate-a-demo-image","page":"CLI tool","title":"Generate a demo image","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can use the demo image command to render a demo image:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl demo image","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"(Image: )","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"It creates two files: demo.pfm (the HDR image) and demo.jpg (the LDR image).","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can change the output file name, the LDR extension and other rendering parameters using the command options. For example, you can enable antialiasing and see the difference it can make. Here an example with 36 rays/pixel:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"(Image: )","category":"page"},{"location":"cli/#Generate-a-demo-animation","page":"CLI tool","title":"Generate a demo animation","text":"","category":"section"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"To create a demo animation, use the command demo animation:","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"julia raytracer_cli.jl demo animation","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"<video autoplay=\"\" controls=\"\" loop=\"\" width=\"540\" height=\"540\">\n  <source src=\"https://i.imgur.com/2yEoRbA.mp4\">\n</video>","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"It creates a new folder demo_animation with the video demo.mp4 and all the frames in jpeg format.","category":"page"},{"location":"cli/","page":"CLI tool","title":"CLI tool","text":"You can change the output folder and file name and other rendering and animation parameters using the command options.","category":"page"},{"location":"quickstart/cli/#Basic-CLI-tool-usage","page":"Basic CLI usage","title":"Basic CLI tool usage","text":"","category":"section"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"The CLI tool is named raytracer_cli.jl and is placed in the root of the repository.","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"The usage is based on a series of commands, in a similar way to the git and docker CLI tools:","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"julia raytracer_cli.jl {command} [{subcommand}] [options]","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"For example, to apply the tonemapping process you can use:","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"julia raytracer_cli.jl tonemapping [options] input_file.pfm output_file.<LDR_extension>","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"where LDR_extension indicates the desired output format. Most LDR formats are supported (see tonemapping).","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"Related commands are encapsulated, like the demo command: it admits a set of subcommands that specify the type of demo.","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"julia raytracer_cli.jl demo image","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"julia raytracer_cli.jl demo animation","category":"page"},{"location":"quickstart/cli/","page":"Basic CLI usage","title":"Basic CLI usage","text":"More informations here.","category":"page"},{"location":"devs/collab/#Collaboration-instructions","page":"Collaboration instructions","title":"Collaboration instructions","text":"","category":"section"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"To contribute to the package development, clone this repository:","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"git clone https://github.com/Paolo97Gll/Raytracer.jl.git\ncd Raytracer.jl","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"Then open the julia REPL and type the following commands to update your environment:","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"import Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.","category":"page"},{"location":"devs/collab/","page":"Collaboration instructions","title":"Collaboration instructions","text":"Please make sure to update tests as appropriate.","category":"page"},{"location":"api/high-level/#high_level_api","page":"High-level API","title":"High-level API","text":"","category":"section"},{"location":"api/high-level/","page":"High-level API","title":"High-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"user_utils.jl\"]","category":"page"},{"location":"api/high-level/#Raytracer.demo-Tuple{}","page":"High-level API","title":"Raytracer.demo","text":"demo(;output_file::String = \"demo.jpg\",\n      camera_type::Type{<:Camera} = PerspectiveCamera,\n      camera_position::Tuple{Float32, Float32, Float32} = (-3f0, 0f0, 0f0),\n      camera_orientation::Tuple{Float32, Float32, Float32} = (0f0, 0f0, 0f0),\n      screen_distance::Float32 = 2f0,\n      image_resolution::Tuple{Int, Int} = (540,540),\n      samples_per_side::Int = 0,\n      renderer_type::Type{<:Renderer} = PathTracer,\n      pt_n::Int = 10,\n      pt_max_depth::Int = 2,\n      pt_roulette_depth::Int = 3,\n      α::Float32 = 0.75f0,\n      γ::Float32 = 1f0,\n      use_threads::Bool = true,\n      disable_output::Bool = false)\n\nCreate a demo image.\n\nArguments\n\noutput_file: output LDR file name (the HDR file will have the same name, but with \"pfm\" extension).\ncamera_type: choose camera type (\"perspective\" or \"orthogonal\").\ncamera_position: camera position in the scene as \"X,Y,Z\".\ncamera_orientation: camera orientation as \"angX,angY,angZ\".\nscreen_distance: only for \"perspective\" camera: distance between camera and screen.\nimage_resolution: resolution of the rendered image.\nrenderer_type: type of renderer to use (\"onoff\", \"flat\" or \"path\").\nsamples_per_side: number of samples per pixel (must be a perfect square).\npt_n: number of rays fired for mc integration (path-tracer only).\npt_max_depth: maximum number of reflections for each ray (path-tracer only).\npt_roulette_depth: depth of the russian-roulette algorithm (path-tracer only).\nα: scaling factor for the normalization process.\nγ: gamma value for the tone mapping process.\nuse_threads: use macro Threads.@threads.\ndisable_output: if true, no message is printed.\n\n\n\n\n\n","category":"method"},{"location":"api/high-level/#Raytracer.tonemapping-Tuple{String, String, Float32, Float32}","page":"High-level API","title":"Raytracer.tonemapping","text":"tonemapping(input_file::String,\n            output_file::String,\n            α::Float32,\n            γ::Float32\n            ; disable_output::Bool = false)\n\nLoad a pfm hdr image, apply the tone mapping, and save the generated ldr image.\n\ninput_file is the path to a valid PFM image. output_file is the path in which save the generated image + the name of the output file. The output format is deduced by the extension of the output file: if the name is example.jpg, the image will be exported in JPEG format. α is the normalization coefficient. γ is the actor of the γ correction.\n\nIf disable_output is true, no message is printed.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/api/#Basic-API-usage","page":"Basic API usage","title":"Basic API usage","text":"","category":"section"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Using the API, you can interact directly with the renderer.","category":"page"},{"location":"quickstart/api/#Image-generation","page":"Basic API usage","title":"Image generation","text":"","category":"section"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Let's assume we want to render a sphere in the origin using a flat renderer.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"First, import the module:","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"using Raytracer","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"We need to create the scene. All the shapes of the image must be included in a World instance.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"world = World()","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Then, we need to create the shape and add it to world. Here we create a Sphere with radius 2 in the origin, with a DiffuseBRDF. The pigment of the BRDF is a CheckeredPigment with a RED and GREEN pattern.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"sphere = Sphere(\n    transformation = scaling(2),\n    material = Material(\n        brdf = DiffuseBRDF(\n            pigment = CheckeredPigment{8}(\n                color_on = RED,\n                color_off = GREEN\n            )\n        )\n    )\n)\nappend!(world, [sphere])","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Now we can choose the renderer. For this example, we use a FlatRenderer.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"renderer = FlatRenderer(world)","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Now we need to create a Camera, representing an observer. For this example, we use a PerspectiveCamera positioned at the point (-1000) and looking the origin.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"camera = PerspectiveCamera(\n    aspect_ratio = 16//9,\n    screen_distance = 3,\n    transformation = translation(-10,0,0)\n)","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Now we can create the ImageTracer, with the observer informations, an empty FHD (i.e. with resolution of 1920x1080) HdrImage and no antialiasing:","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"image = HdrImage(1920, 1080)\nimage_tracer = ImageTracer(image, camera)","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Now we can render the image, using the function fire_all_rays!:","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"julia> fire_all_rays!(image_tracer, renderer)\nProgress: 100%|███████████████████████████████████████| Time: 0:00:03","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"Finally, we can save the generated HDR image. Remember to use permutedims when saving the image, otherwise you will have an output image reflected along the diagonal!","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"julia> save(\"myimage.pfm\", permutedims(image_tracer.image.pixel_matrix))\n24883218","category":"page"},{"location":"quickstart/api/#Tone-mapping","page":"Basic API usage","title":"Tone mapping","text":"","category":"section"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"We can apply tone mapping to an HDR image to get a LDR image, for example a jpeg or png file.","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"julia> tonemapping(\"myimage.pfm\", \"myimage.jpg\", 0.5f0, 1f0)\n\n-> TONE MAPPING PROCESS\nLoading input file 'myimage.pfm'... done!\nApplying tone mapping...  done!\nSaving final image to 'myimage.jpg'... done!","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"The final image is:","category":"page"},{"location":"quickstart/api/","page":"Basic API usage","title":"Basic API usage","text":"(Image: )","category":"page"},{"location":"quickstart/scenelang/#Basic-SceneLang-usage","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"","category":"section"},{"location":"quickstart/scenelang/","page":"Basic SceneLang usage","title":"Basic SceneLang usage","text":"Coming soon!","category":"page"},{"location":"scenelang/#SceneLang","page":"SceneLang","title":"SceneLang","text":"","category":"section"},{"location":"scenelang/","page":"SceneLang","title":"SceneLang","text":"Coming soon!","category":"page"},{"location":"#Raytracer.jl","page":"Introduction","title":"Raytracer.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Raytracing package for the generation of photorealistic images in Julia.","category":"page"},{"location":"#Brief-description","page":"Introduction","title":"Brief description","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main purpose of this package is to generate photorealistic images given an input scene.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The input scene is composed by a list of shapes (spheres, planes, ...) of various materials (for now diffusive or reflective) with different colors, each one with in a particular position in the 3D space. The observer is represented by a camera, that can do a perspective or an orthogonal projection. The camera will see the scene through a screen, characterized by its aspect ratio, distance from the camera and resolution. The image can be rendered with different backwards ray tracing algorithms: a path tracer (the default renderer), a point-light tracer, a flat renderer and an on-off renderer; this process can be parallelized using multiple threads. Each of these aspects can be managed, tuned and modified using the low-level API of the package (see below).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are two main steps in the image generation. We offer high-level API and a CLI tool for these steps (see below).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The generation of an HDR (high dynamic range) image in the PFM format. In this step, the scene is loaded along with the informations about the observer (position, orientation, type of the camera, ...) and the chosen renderer. Then the image is rendered using the chosen algorithm.\nThe conversion of this image to an LDR (low dynamic range) image, such as jpg or png, using a tone mapping process.","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We provide:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A package with both high-level API and low-level API. It's possible to use the package's features directly from the REPL or in more complex scripts. See Basic API usage.\nA CLI tool. Thanks to the simple usage and the extended help messages, it makes possible the use of this package's high-level features to those who do not know Julia lang. See Basic CLI tool usage.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For example, to generate a demo image, you can use the julia REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Raytracer\n\njulia> demo()\n\n-> RENDERING\nLoading scene... done!\nLoading tracing informations... done!\nRendering image...\nProgress: 100%|█████████████████████████████████████████████████████| Time: 0:00:44\nSaving pfm image... done!\n\n-> TONE MAPPING PROCESS\nLoading input file 'demo.pfm'... done!\nApplying tone mapping...  done!\nSaving final image to 'demo.jpg'... done!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or equivalently the CLI tool:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"~/Raytracer.jl❯ julia raytracer_cli.jl demo image\n  Activating environment at `C:\\Users\\paolo\\source\\repos\\Raytracer.jl\\Project.toml`\n\nraytracer_cli.jl : Raytracer.jl demo image\n\nRenderer: PathTracer\nNumber of threads: 1\n\n-> RENDERING\nLoading scene... done!\nLoading tracing informations... done!\nRendering image...\nProgress: 100%|█████████████████████████████████████████████████████| Time: 0:00:42\nSaving pfm image... done!\n\n-> TONE MAPPING PROCESS\nLoading input file 'demo.pfm'... done!\nApplying tone mapping...  done!\nSaving final image to 'demo.jpg'... done!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The CLI tool has more advanced features, like the generation of animations. But using the package from the REPL gives more flexibility.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#Package","page":"Introduction","title":"Package","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is still under development and is not available in the official registry.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To add this package to your main environment (not recommended), open the julia REPL and type the following commands:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(url=\"https://github.com/Samuele-Colombo/FileIO.jl\")\nPkg.add(url=\"https://github.com/Samuele-Colombo/ImagePFM.jl\")\nPkg.add(url=\"https://github.com/Paolo97Gll/Raytracer.jl\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We use a custom version of FileIO that provides load/save functionalities for pfm files: this integration is done by the package ImagePFM. If FileIO is already present (e.g. the original package), it will be overwritten by this custom version.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can also create a new environment (recommended). First create a new folder and cd into this folder: this will become the home of the new environment. Then open the julia REPL and type the following commands:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.activate(\".\")\nPkg.add(url=\"https://github.com/Samuele-Colombo/FileIO.jl\")\nPkg.add(url=\"https://github.com/Samuele-Colombo/ImagePFM.jl\")\nPkg.add(url=\"https://github.com/Paolo97Gll/Raytracer.jl\")","category":"page"},{"location":"#cli_tool_installation","page":"Introduction","title":"CLI tool","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To use it, clone this repository:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"git clone https://github.com/Paolo97Gll/Raytracer.jl.git\ncd Raytracer.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then, open the julia REPL and type the following commands to instantiate the environment:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"api/low-level/#low_level_api","page":"Low-level API","title":"Low-level API","text":"","category":"section"},{"location":"api/low-level/#Colors-and-images","page":"Low-level API","title":"Colors and images","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"We use the ColorTypes.RGB from ColorTypes.jl. Our package extends the methods of this type, for example by implementing sum and difference between two color instances. We also add iterability and broadcasting.","category":"page"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"colors.jl\", \"hdrimage.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.BLACK","page":"Low-level API","title":"Raytracer.BLACK","text":"BLACK\n\nA RGB{Float32} representing a black color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.BLUE","page":"Low-level API","title":"Raytracer.BLUE","text":"BLUE\n\nA RGB{Float32} representing a blue color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.CYAN","page":"Low-level API","title":"Raytracer.CYAN","text":"CYAN\n\nA RGB{Float32} representing a cyan color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.GREEN","page":"Low-level API","title":"Raytracer.GREEN","text":"GREEN\n\nA RGB{Float32} representing a green color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.MAGENTA","page":"Low-level API","title":"Raytracer.MAGENTA","text":"MAGENTA\n\nA RGB{Float32} representing a magenta color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.RED","page":"Low-level API","title":"Raytracer.RED","text":"RED\n\nA RGB{Float32} representing a red color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.WHITE","page":"Low-level API","title":"Raytracer.WHITE","text":"WHITE\n\nA RGB{Float32} representing a white color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.YELLOW","page":"Low-level API","title":"Raytracer.YELLOW","text":"YELLOW\n\nA RGB{Float32} representing a yellow color.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Base.Math.clamp-Union{Tuple{RGB{T}}, Tuple{T}} where T","page":"Low-level API","title":"Base.Math.clamp","text":"clamp(c::RGB)\n\nReturn a clamped RGB color, with each component x obtained with the formula:\n\nfracx1 + x\n\nExamples\n\njulia> clamp(RGB(1f0, 2f0, 3f0))\nRGB color with eltype Float32\nR: 0.5, G: 0.6666667, B: 0.75\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.luminosity-Tuple{RGB}","page":"Low-level API","title":"Raytracer.luminosity","text":"luminosity(c::RGB)\n\nReturn the mean value between the maximum component and the minumum component of a color:\n\nfracmathrmmax(c) + mathrmmin(c)2\n\nExamples\n\njulia> luminosity(RGB(1f0, 2f0, 3f0))\n2.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.γ_correction-Union{Tuple{T}, Tuple{RGB{T}, Float32}} where T","page":"Low-level API","title":"Raytracer.γ_correction","text":"γ_correction(c::RGB, γ::Float32)\n\nReturn a RGB color, with each component x corrected with the formula:\n\nx^1  gamma\n\nExamples\n\njulia> c = RGB(1f0, 2f0, 3f0);\n\njulia> γ_correction(c, 1f0)\nRGB color with eltype Float32\nR: 1.0, G: 2.0, B: 3.0\n\njulia> γ_correction(c, 0.8f0)\nRGB color with eltype Float32\nR: 1.0, G: 2.3784142, B: 3.948222\n\njulia> γ_correction(c, 2.4f0)\nRGB color with eltype Float32\nR: 1.0, G: 1.3348398, B: 1.580522\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.HdrImage","page":"Low-level API","title":"Raytracer.HdrImage","text":"HdrImage\n\nWrapper of a Matrix of elements of type RGB{Float32}, used to represent an image in hdr format.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.HdrImage-Tuple{AbstractVector{var\"#s4\"} where var\"#s4\", Integer, Integer}","page":"Low-level API","title":"Raytracer.HdrImage","text":"HdrImage(arr::AbstractArray{<:Any, 1}, im_width::Integer, im_height::Integer)\nHdrImage(arr::AbstractArray{<:Any, 1}, shape)\n\nConstruct an HdrImage wrapping a matrix obtained from reshape.\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> HdrImage(arr, 3, 2)\n3x2 HdrImage:\n (1.0 2.0 3.0)  (10.0 11.0 12.0)\n (4.0 5.0 6.0)  (13.0 14.0 15.0)\n (7.0 8.0 9.0)  (16.0 17.0 18.0)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.HdrImage-Tuple{Integer, Integer}","page":"Low-level API","title":"Raytracer.HdrImage","text":"HdrImage(img_width::Integer, img_height::Integer)\n\nConstruct an HdrImage wrapping a zero-initialized matrix of size (img_width, img_height).\n\nExamples\n\njulia> HdrImage(3, 2)\n3x2 HdrImage:\n (0.0 0.0 0.0)  (0.0 0.0 0.0)\n (0.0 0.0 0.0)  (0.0 0.0 0.0)\n (0.0 0.0 0.0)  (0.0 0.0 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.HdrImage-Tuple{Matrix{RGB{Float32}}}","page":"Low-level API","title":"Raytracer.HdrImage","text":"HdrImage(pixel_matrix::Matrix{RGB{Float32}})\n\nConstructor for a HdrImage instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Base.Math.clamp-Tuple{HdrImage}","page":"Low-level API","title":"Base.Math.clamp","text":"clamp(image::HdrImage)\n\nAdjust the color levels of the brightest pixels of a HdrImage, by applying the clamp(::RGB) function to each pixel.\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> clamp(HdrImage(arr, 3, 2))\n3x2 HdrImage:\n (0.5 0.6666667 0.75)        (0.90909094 0.9166667 0.9230769)\n (0.8 0.8333333 0.85714287)  (0.9285714 0.93333334 0.9375)\n (0.875 0.8888889 0.9)       (0.9411765 0.9444444 0.94736844)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#LinearAlgebra.normalize-Tuple{HdrImage, Float32}","page":"Low-level API","title":"LinearAlgebra.normalize","text":"normalize(image::HdrImage, α::Float32\n          ; luminosity::Float32 = average_luminosity(image))\n\nNormalize a HdrImage for a given luminosity.\n\nIf the luminosity parameter is not specified, the image will be normalized according to the result of luminosity(::HdrImage; ::Float32).\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> normalize(HdrImage(arr, 3, 2), 1f0)\n3x2 HdrImage:\n (0.12976472 0.25952944 0.38929415)  (1.2976472 1.4274119 1.5571766)\n (0.5190589 0.6488236 0.7785883)     (1.6869414 1.8167061 1.9464709)\n (0.90835303 1.0381178 1.1678824)    (2.0762355 2.2060003 2.335765)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.luminosity-Tuple{HdrImage}","page":"Low-level API","title":"Raytracer.luminosity","text":"luminosity(image::HdrImage; δ::Float32 = eps(Float32))\n\nReturn the average luminosity an HdrImage as the logaritmic mean of the luminosity(::RGB) l_i of each pixel:\n\nleft l right = 10^fracsum_i log_10(delta + l_i)N\n\nThe parameter δ avoid singularities for l_i = 0 (black pixels).\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> luminosity(HdrImage(arr, 3, 2))\n7.706255f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.γ_correction-Tuple{HdrImage, Float32}","page":"Low-level API","title":"Raytracer.γ_correction","text":"γ_correction(image::HdrImage, γ::Float32)\n\nCompute the γ correction of a HdrImage, by applying the γ_correction(::RGB, ::Float32) function to each pixel.\n\nBefore calling this function, you should apply a tone-mapping algorithm to the image and be sure that the R, G, and B values of the colors in the image are all in the range 0 1. Use normalize(::HdrImage, ::Float32; ::Float32) and clamp(image::HdrImage) to do this.\n\nExamples\n\njulia> arr = [RGB( 1.,  2.,  3.), RGB( 4.,  5.,  6.), RGB( 7.,  8.,  9.),\n              RGB(10., 11., 12.), RGB(13., 14., 15.), RGB(16., 17., 18.)];\n\njulia> image = normalize(HdrImage(arr, 3, 2), 1f0) |> clamp;\n\njulia> γ_correction(image, 1f0)\n3x2 HdrImage:\n (0.11485995 0.20605269 0.28021002)  (0.5647722 0.58803856 0.6089437)\n (0.34169766 0.393507 0.43775633)    (0.6278296 0.64497536 0.660611)\n (0.47598794 0.5093512 0.53872037)   (0.67492735 0.6880849 0.7002187)\n\njulia> γ_correction(image, 0.8f0)\n3x2 HdrImage:\n (0.06686684 0.13882665 0.20387058)  (0.48960024 0.51494074 0.53792465)\n (0.26124772 0.31166682 0.35607424)  (0.558859 0.57800144 0.5955692)\n (0.39536202 0.43030033 0.4615346)   (0.6117462 0.6266897 0.64053386)\n\njulia> γ_correction(image, 2.4f0)\n3x2 HdrImage:\n (0.40588558 0.5177947 0.58855206)  (0.7881591 0.8015287 0.8132807)\n (0.63926977 0.6780008 0.7087834)   (0.82369685 0.83299613 0.8413514)\n (0.73394746 0.7549599 0.77280176)  (0.8489011 0.8557578 0.86201346)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Geometry","page":"Low-level API","title":"Geometry","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"geometry.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.NORMAL_X","page":"Low-level API","title":"Raytracer.NORMAL_X","text":"NORMAL_X\n\nA unitary and normalized Normal{true} along the x-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_X_false","page":"Low-level API","title":"Raytracer.NORMAL_X_false","text":"NORMAL_X_false\n\nA unitary and non-normalized Normal{false} along the x-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_Y","page":"Low-level API","title":"Raytracer.NORMAL_Y","text":"NORMAL_Y\n\nA unitary and normalized Normal{true} along the y-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_Y_false","page":"Low-level API","title":"Raytracer.NORMAL_Y_false","text":"NORMAL_Y_false\n\nA unitary and non-normalized Normal{false} along the y-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_Z","page":"Low-level API","title":"Raytracer.NORMAL_Z","text":"NORMAL_Z\n\nA unitary and normalized Normal{true} along the z-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.NORMAL_Z_false","page":"Low-level API","title":"Raytracer.NORMAL_Z_false","text":"NORMAL_Z_false\n\nA unitary and non-normalized Normal{false} along the z-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.ORIGIN","page":"Low-level API","title":"Raytracer.ORIGIN","text":"ORIGIN\n\nA Point representing the origin of the frame of reference.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.VEC_X","page":"Low-level API","title":"Raytracer.VEC_X","text":"VEC_X\n\nA unitary Vec along the x-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.VEC_Y","page":"Low-level API","title":"Raytracer.VEC_Y","text":"VEC_Y\n\nA unitary Vec along the y-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.VEC_Z","page":"Low-level API","title":"Raytracer.VEC_Z","text":"VEC_Z\n\nA unitary Vec along the z-axis.\n\n\n\n\n\n","category":"constant"},{"location":"api/low-level/#Raytracer.Normal","page":"Low-level API","title":"Raytracer.Normal","text":"Normal{V} <: StaticArrays.FieldVector{3, Float32}\n\nA pseudo-vector in 3D space with 3 fields x, y, and z of type Float32. The parameter V tells if the normal is normalized or not.\n\nFor inherited properties and constructors see StaticArrays.FieldVector.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Normal-Tuple{Any, Any, Any}","page":"Low-level API","title":"Raytracer.Normal","text":"Normal(x, y, z)\n\nConstruct a non-normalized Normal{false} with given coordinates. All values are converted in Float32.\n\nExamples\n\njulia> Normal(1.2, 3.3, 5)\nNormal with eltype Float32, not normalized\nx = 1.2, y = 3.3, z = 5.0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Normal-Union{Tuple{Float32, Float32, Float32}, Tuple{V}} where V","page":"Low-level API","title":"Raytracer.Normal","text":"Normal{V}(x::Float32, y::Float32, z::Float32)\n\nConstructor for a Normal instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Point","page":"Low-level API","title":"Raytracer.Point","text":"Point\n\nA point in a 3D space. Implemented as a wrapper struct around a SVector{3, Float32}.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Point-Tuple{AbstractVector{T} where T}","page":"Low-level API","title":"Raytracer.Point","text":"Point(p::AbstractVector)\n\nConstructor for a Point instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Point-Tuple{Any, Any, Any}","page":"Low-level API","title":"Raytracer.Point","text":"Point(x, y, z)\n\nConstruct a Point with given coordinates. All values are converted in Float32.\n\nExamples\n\njulia> Point(1.2, 3.3, 5)\nPoint with eltype Float32\nx = 1.2, y = 3.3, z = 5.0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Vec","page":"Low-level API","title":"Raytracer.Vec","text":"Vec <: StaticArrays.FieldVector{3, Float32}\n\nA vector in 3D space with 3 fields x, y, and z of type Float32.\n\nFor inherited properties and constructors see StaticArrays.FieldVector.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Vec-Tuple{Float32, Float32, Float32}","page":"Low-level API","title":"Raytracer.Vec","text":"Vec(x::Float32, y::Float32, z::Float32)\n\nConstructor for a Vec instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Vec2D","page":"Low-level API","title":"Raytracer.Vec2D","text":"Vec2D\n\nAlias to SVector{2, Float32}, used for uv mapping on shapes.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Base.convert-Tuple{Type{Vec}, Point}","page":"Low-level API","title":"Base.convert","text":"convert(::Type{Vec}, p::Point)\nconvert(::Type{Normal}, p::Point)\n\nConvert a Point into the specified type (Vec or Normal{false}).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#LinearAlgebra.norm-Tuple{Normal{true}}","page":"Low-level API","title":"LinearAlgebra.norm","text":"norm(n::Normal{true})\n\nCompute the squared norm of a Normal{true}. Since n is already normalized, 1f0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#LinearAlgebra.normalize-Tuple{Normal{false}}","page":"Low-level API","title":"LinearAlgebra.normalize","text":"normalize(n::Normal)\n\nNormalize n and return a Normal{true}. If n is already a Normal{true} instance, no normalization is computed and n is returned.\n\nExamples\n\njulia> n = normalize(Normal(1,2,4))\nNormal with eltype Float32, normalized\nx = 0.21821788, y = 0.43643576, z = 0.8728715\n\njulia> normalize(n)\nNormal with eltype Float32, normalized\nx = 0.21821788, y = 0.43643576, z = 0.8728715\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.create_onb_from_z-Tuple{Normal}","page":"Low-level API","title":"Raytracer.create_onb_from_z","text":"create_onb_from_z(input_normal::Normal)\n\nCreate an orthonormal base from a input Normal representing the z-axis using the Duff et al. 2017 algorithm.\n\nExamples\n\njulia> n = Normal(0,0,5);\n\njulia> nn = normalize(Normal(0,0,5));\n\njulia> create_onb_from_z(n)\n(Vec(1.0, -0.0, -0.0), Vec(-0.0, 1.0, -0.0), Vec(0.0, 0.0, 1.0))\n\njulia> create_onb_from_z(nn)\n(Vec(1.0, -0.0, -0.0), Vec(-0.0, 1.0, -0.0), Vec(0.0, 0.0, 1.0))\n\nNote that create_onb_from_z(n) and create_onb_from_z(nn) give the same result.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.norm²-Tuple{Normal{false}}","page":"Low-level API","title":"Raytracer.norm²","text":"norm²(n::Normal)\n\nCompute the squared norm of a Normal. If n is a Normal{true} instance then 1f0 is returned.\n\nExamples\n\njulia> n = Normal(1, 2, 3);\n\njulia> norm²(n)\n14.0f0\n\njulia> norm²(normalize(n))\n1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.norm²-Tuple{Vec}","page":"Low-level API","title":"Raytracer.norm²","text":"norm²(v::Vec)\n\nCompute the squared norm of a Vec.\n\nExamples\n\njulia> norm²(Vec(1, 2, 3))\n14.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Transformations","page":"Low-level API","title":"Transformations","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"transformations.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.Transformation","page":"Low-level API","title":"Raytracer.Transformation","text":"Transformation\n\nA wrapper around two 4x4 matrices representing a transformation for Vec, Normal, and Point instances.\n\nA 4x4 matrix is needed to use the properties of homogeneous coordinates in 3D space. Storing the inverse of the transformation significantly increases performance at the cost of memory space.\n\nMembers\n\nm::SMatrix{4, 4, Float32}: the homogeneous matrix representation of the transformation.\ninvm::SMatrix{4, 4, Float32}: the homogeneous matrix representation of the inverse transformation.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Transformation-Tuple{AbstractMatrix{T} where T}","page":"Low-level API","title":"Raytracer.Transformation","text":"Transformation(m::AbstractMatrix)\nTransformation(m::AbstractMatrix, invm::AbstractMatrix)\n\nConstruct a Transformation instance from m and invm. The elements of the matrix will be casted to Float32.\n\nIf any argument is an AbstractMatrix, it will be implicitly casted to a StaticArrays.SMatrix to increase performance.\n\nExamples\n\njulia> Transformation(StaticArrays.SMatrix{4,4}([1 0 0 0; 0 2 0 0; 0 0 4 0; 0 0 0 1]))\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  4.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0   0.0f0\n 0.0f0  0.5f0  0.0f0   0.0f0\n 0.0f0  0.0f0  0.25f0  0.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\njulia> Transformation([1 0 0 0; 0 2 0 0; 0 0 4 0; 0 0 0 1])\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  4.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0   0.0f0\n 0.0f0  0.5f0  0.0f0   0.0f0\n 0.0f0  0.0f0  0.25f0  0.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\njulia> Transformation(LinearAlgebra.Diagonal([1,2,4,1]))\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  4.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0   0.0f0\n 0.0f0  0.5f0  0.0f0   0.0f0\n 0.0f0  0.0f0  0.25f0  0.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Transformation-Tuple{StaticArrays.SMatrix{4, 4, Float32, L} where L, StaticArrays.SMatrix{4, 4, Float32, L} where L}","page":"Low-level API","title":"Raytracer.Transformation","text":"Transformation(m::SMatrix{4, 4, Float32} = SMatrix{4, 4, Float32}(I(4)),\n               invm::SMatrix{4, 4, Float32} = inv(m))\n\nConstructor for a Transformation instance.\n\nIf no parameter is specified, then an identity transformation is returned. If only the direct matrix is specified, then the inverse matrix is automatically computed.\n\nExamples\n\njulia> Transformation()\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  1.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  1.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  1.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  1.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.isconsistent-Tuple{Transformation}","page":"Low-level API","title":"Raytracer.isconsistent","text":"isconsistent(t::Transformation)\n\nReturn true if t.m * t.invm is similar to the identity matrix and so the Transformation is consistent.\n\nMainly used for testing and to verify matrices haven't been mutated.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.rotationX","page":"Low-level API","title":"Raytracer.rotationX","text":"rotationX(θ::Real)\n\nReturn a Transformation that rotates a 3D vector field of the given angle in radians around the X-axis.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> rotationX(π/4)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0          0.0f0         0.0f0\n 0.0f0  0.70710677f0  -0.70710677f0  0.0f0\n 0.0f0  0.70710677f0   0.70710677f0  0.0f0\n 0.0f0  0.0f0          0.0f0         1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0   0.0f0         0.0f0         0.0f0\n 0.0f0   0.70710677f0  0.70710677f0  0.0f0\n 0.0f0  -0.70710677f0  0.70710677f0  0.0f0\n 0.0f0   0.0f0         0.0f0         1.0f0\n\n\n\n\n\n","category":"function"},{"location":"api/low-level/#Raytracer.rotationY","page":"Low-level API","title":"Raytracer.rotationY","text":"rotationY(θ::Real)\n\nReturn a Transformation that rotates a 3D vector field of the given angle in radians around the Y-axis.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> rotationY(π/4)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n  0.70710677f0  0.0f0  0.70710677f0  0.0f0\n  0.0f0         1.0f0  0.0f0         0.0f0\n -0.70710677f0  0.0f0  0.70710677f0  0.0f0\n  0.0f0         0.0f0  0.0f0         1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 0.70710677f0  0.0f0  -0.70710677f0  0.0f0\n 0.0f0         1.0f0   0.0f0         0.0f0\n 0.70710677f0  0.0f0   0.70710677f0  0.0f0\n 0.0f0         0.0f0   0.0f0         1.0f0\n\n\n\n\n\n","category":"function"},{"location":"api/low-level/#Raytracer.rotationZ","page":"Low-level API","title":"Raytracer.rotationZ","text":"rotationZ(θ::Real)\n\nReturn a Transformation that rotates a 3D vector field of the given angle in radians around the Z-axis.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> rotationZ(π/4)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 0.70710677f0  -0.70710677f0  0.0f0  0.0f0\n 0.70710677f0   0.70710677f0  0.0f0  0.0f0\n 0.0f0          0.0f0         1.0f0  0.0f0\n 0.0f0          0.0f0         0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n  0.70710677f0  0.70710677f0  0.0f0  0.0f0\n -0.70710677f0  0.70710677f0  0.0f0  0.0f0\n  0.0f0         0.0f0         1.0f0  0.0f0\n  0.0f0         0.0f0         0.0f0  1.0f0\n\n\n\n\n\n","category":"function"},{"location":"api/low-level/#Raytracer.scaling-Tuple{Real, Real, Real}","page":"Low-level API","title":"Raytracer.scaling","text":"scaling(x::Real, y::Real, z::Real)\nscaling(s::Real)\nscaling(v::AbstractVector)\n\nReturn a Transformation that scales a 3D vector field of a given factor for each axis.\n\nIf a single Real is provided as argument then the scaling is considered uniform. If an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> scaling(1, 2, 3)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  3.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0         0.0f0\n 0.0f0  0.5f0  0.0f0         0.0f0\n 0.0f0  0.0f0  0.33333334f0  0.0f0\n 0.0f0  0.0f0  0.0f0         1.0f0\n\njulia> scaling(2)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 2.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  2.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 0.5f0  0.0f0  0.0f0  0.0f0\n 0.0f0  0.5f0  0.0f0  0.0f0\n 0.0f0  0.0f0  0.5f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\n\njulia> scaling([1, 2, 3])\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  0.0f0\n 0.0f0  2.0f0  0.0f0  0.0f0\n 0.0f0  0.0f0  3.0f0  0.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0         0.0f0\n 0.0f0  0.5f0  0.0f0         0.0f0\n 0.0f0  0.0f0  0.33333334f0  0.0f0\n 0.0f0  0.0f0  0.0f0         1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.translation-Tuple{AbstractVector{T} where T}","page":"Low-level API","title":"Raytracer.translation","text":"translation(v::AbstractVector)\ntranslation(x::Real, y::Real, z::Real)\n\nReturn a Transformation that translates a 3D vector field of the given coordinates.\n\nIf an AbstractVector is provided as argument it must have a size = (3,).\n\nExamples\n\njulia> translation(1, 2, 3)\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  1.0f0\n 0.0f0  1.0f0  0.0f0  2.0f0\n 0.0f0  0.0f0  1.0f0  3.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  -1.0f0\n 0.0f0  1.0f0  0.0f0  -2.0f0\n 0.0f0  0.0f0  1.0f0  -3.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\njulia> translation([1, 2, 3])\n4x4 Transformation:\nMatrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  1.0f0\n 0.0f0  1.0f0  0.0f0  2.0f0\n 0.0f0  0.0f0  1.0f0  3.0f0\n 0.0f0  0.0f0  0.0f0  1.0f0\nInverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:\n 1.0f0  0.0f0  0.0f0  -1.0f0\n 0.0f0  1.0f0  0.0f0  -2.0f0\n 0.0f0  0.0f0  1.0f0  -3.0f0\n 0.0f0  0.0f0  0.0f0   1.0f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Ray","page":"Low-level API","title":"Ray","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"ray.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.Ray","page":"Low-level API","title":"Raytracer.Ray","text":"Ray\n\nA ray of light propagating in space.\n\nMembers\n\norigin::Point: the (Point) where the ray originated.\ndir::Vec: a (Vec) representing the direction along which this ray propagates.\ntmin::Float32: the minimum distance travelled by the ray is this number times dir.\ntmax::Float32: the maximum distance travelled by the ray is this number times dir.\ndepth::Int: number of times this ray was reflected/refracted.\n\nSee also: Ray(::Float32)\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Ray-Tuple{Float32}","page":"Low-level API","title":"Raytracer.Ray","text":"(r::Ray)(t::Float32)\n\nReturn a Point lying on the given Ray at t.\n\nAn instance of Ray can be called as a function returning a Point given the position parameter t:\n\nmathrmray_origin + mathrmray_direction cdot t\n\nArgument t must be included between r.tmin and r.tmax or be equal to 0. If t is zero, then the returned point is the origin of r.\n\nExamples\n\njulia> ray = Ray(ORIGIN, VEC_X)\nRay\n ↳ origin = Point(0.0, 0.0, 0.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\njulia> ray(5f0)\nPoint with eltype Float32\nx = 5.0, y = 0.0, z = 0.0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Ray-Tuple{Point, Vec, Float32, Float32, Int64}","page":"Low-level API","title":"Raytracer.Ray","text":"Ray(origin::Point, dir::Vec, tmin::Float32, tmax::Float32, depth::Int)\n\nConstructor for a Ray instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Ray-Tuple{Point, Vec}","page":"Low-level API","title":"Raytracer.Ray","text":"Ray(origin::Point, dir::Vec\n    ; tmin::Float32 = 1f-5,\n      tmax::Float32 = Inf32,\n      depth::Int = 0)\n\nConstructor for a Ray instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Cameras","page":"Low-level API","title":"Cameras","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"cameras.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.Camera","page":"Low-level API","title":"Raytracer.Camera","text":"Camera\n\nAn abstract type representing an observer.\n\nSee also: OrthogonalCamera, PerspectiveCamera\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.OrthogonalCamera","page":"Low-level API","title":"Raytracer.OrthogonalCamera","text":"OrthogonalCamera <: Camera\n\nA Camera implementing an orthogonal 3D → 2D projection.\n\nMembers\n\naspect_ratio::Float32: defines how larger than the height is the image (16/9, 4/3, ...).\ntransformation::Transformation: define the Transformation applied to the rays generated by the camera.\n\nSee also: fire_ray(::OrthogonalCamera, ::Float32, ::Float32)\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.OrthogonalCamera-Tuple{Float32, Transformation}","page":"Low-level API","title":"Raytracer.OrthogonalCamera","text":"OrthogonalCamera(aspect_ratio::Float32, transformation::Transformation)\n\nConstructor for an OrthogonalCamera instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.OrthogonalCamera-Tuple{}","page":"Low-level API","title":"Raytracer.OrthogonalCamera","text":"OrthogonalCamera(; aspect_ratio::Float32 = 1f0,\n                   transformation::Transformation = Transformation())\n\nKeyword-based constructor for an OrthogonalCamera instance.\n\nIf no parameter is specified, it return a camera with square aspect ratio and an identity transformation.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PerspectiveCamera","page":"Low-level API","title":"Raytracer.PerspectiveCamera","text":"PerspectiveCamera <: Camera\n\nA Camera implementing a perspective 3D → 2D projection.\n\nMembers\n\naspect_ratio::Float32: defines how larger than the height is the image (16/9, 4/3, ...).\ntransformation::Transformation: define the Transformation applied to the rays generated by the camera.\nscreen_distance::Float32: tells how much far from the eye of the observer is the screen and it influences the FOV (field-of-view).\n\nSee also: fire_ray(::PerspectiveCamera, ::Float32, ::Float32), aperture_deg\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PerspectiveCamera-Tuple{Float32, Transformation, Float32}","page":"Low-level API","title":"Raytracer.PerspectiveCamera","text":"PerspectiveCamera(aspect_ratio::Float32, transformation::Transformation, screen_distance::Float32)\n\nConstructor for an PerspectiveCamera instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PerspectiveCamera-Tuple{}","page":"Low-level API","title":"Raytracer.PerspectiveCamera","text":"PerspectiveCamera(; aspect_ratio::Float32 = 1f0,\n                    transformation::Transformation = Transformation(),\n                    screen_distance::Float32 = 1f0)\n\nKeyword-based constructor for a PerspectiveCamera instance.\n\nIf no parameter is specified, it return a camera with square aspect ratio, an identity transformation, and a screen distance of 1, giving a FOV of 90°.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.aperture_deg-Tuple{PerspectiveCamera}","page":"Low-level API","title":"Raytracer.aperture_deg","text":"aperture_deg(camera::PerspectiveCamera)\n\nCompute the FOV of the camera in degrees for a PerspectiveCamera.\n\nExamples\n\nFOV for a camera with screen distance of 1 and aspect ratio of 1:\n\njulia> aperture_deg(PerspectiveCamera())\n90.0f0\n\nFOV for a camera with screen distance of 1 and aspect ratio of 16/9:\n\njulia> aperture_deg(PerspectiveCamera(aspect_ratio = 16//9))\n58.715508f0\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.fire_ray-Tuple{OrthogonalCamera, Float32, Float32}","page":"Low-level API","title":"Raytracer.fire_ray","text":"fire_ray(camera::OrthogonalCamera, u::Float32, v::Float32)\n\nFire a Ray through an OrthogonalCamera at a position (u v) on the screen, using an orthogonal projection.\n\nParameters u and v are bound between 0 and 1:\n\n(0, 1)                            (1, 1)\n    +------------------------------+\n    |                              |\n    |                              |\n    |                              |\n    +------------------------------+\n(0, 0)                            (1, 0)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.fire_ray-Tuple{PerspectiveCamera, Float32, Float32}","page":"Low-level API","title":"Raytracer.fire_ray","text":"fire_ray(camera::PerspectiveCamera, u::Float32, v::Float32)\n\nFire a Ray through a PerspectiveCamera at a position (u v) on the screen, using a perspective projection.\n\nParameters u and v are bound between 0 and 1:\n\n(0, 1)                            (1, 1)\n    +------------------------------+\n    |                              |\n    |                              |\n    |                              |\n    +------------------------------+\n(0, 0)                            (1, 0)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Materials,-BRDF-and-pigments","page":"Low-level API","title":"Materials, BRDF and pigments","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"materials.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.BRDF","page":"Low-level API","title":"Raytracer.BRDF","text":"BRDF\n\nAn abstract type representing a Bidirectional Reflectance Distribution Function.\n\nSee also: DiffuseBRDF, SpecularBRDF,\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.CheckeredPigment","page":"Low-level API","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment{N} <: Pigment\n\nA checkered Pigment. The number of rows/columns in the checkered pattern is tunable with N, but you cannot have a different number of repetitions along the u/v directions.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.CheckeredPigment-2","page":"Low-level API","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment(color_on::RGB{Float32} = WHITE, color_off::RGB{Float32} = BLACK)\n\nConstructor for a CheckeredPigment{2} instance.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.CheckeredPigment-Union{Tuple{RGB{Float32}, RGB{Float32}}, Tuple{N}} where N","page":"Low-level API","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment{N}(color_on::RGB{Float32}, color_off::RGB{Float32}) where {N}\n\nConstructor for a CheckeredPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.CheckeredPigment-Union{Tuple{}, Tuple{N}} where N","page":"Low-level API","title":"Raytracer.CheckeredPigment","text":"CheckeredPigment{N}(; color_on::RGB{Float32} = WHITE,\n                  color_off::RGB{Float32} = BLACK) where {N}\n\nConstructor for a CheckeredPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.DiffuseBRDF","page":"Low-level API","title":"Raytracer.DiffuseBRDF","text":"DiffuseBRDF <: BRDF\n\nA class representing an ideal diffuse BRDF (also called \"Lambertian\").\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.DiffuseBRDF-Tuple{Pigment, Float32}","page":"Low-level API","title":"Raytracer.DiffuseBRDF","text":"DiffuseBRDF(pigment::Pigment, reflectance::Float32)\n\nConstructor for a DiffuseBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.DiffuseBRDF-Tuple{}","page":"Low-level API","title":"Raytracer.DiffuseBRDF","text":"DiffuseBRDF(; pigment::Pigment = UniformPigment(),\n              reflectance::Float32 = 1f0)\n\nConstructor for a DiffuseBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ImagePigment","page":"Low-level API","title":"Raytracer.ImagePigment","text":"ImagePigment <: Pigment\n\nA textured Pigment. The texture is given through a PFM image.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.ImagePigment-Tuple{Float32, Float32}","page":"Low-level API","title":"Raytracer.ImagePigment","text":"(ip::ImagePigment)(u::Float32, v::Float32)\n\nReturn the color of the surface in the given point (uv).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ImagePigment-Tuple{HdrImage}","page":"Low-level API","title":"Raytracer.ImagePigment","text":"ImagePigment(image::HdrImage)\n\nConstructor for a ImagePigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Material","page":"Low-level API","title":"Raytracer.Material","text":"Material\n\nA material with a brdf::BRDF (BRDF) and and emitted_radiance::Pigment (Pigment).\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Material-Tuple{BRDF, Pigment}","page":"Low-level API","title":"Raytracer.Material","text":"Material(brdf::BRDF, emitted_radiance::Pigment)\n\nConstructor for a Material instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Material-Tuple{}","page":"Low-level API","title":"Raytracer.Material","text":"Material(; brdf::BRDF = DiffuseBRDF(), emitted_radiance::Pigment = UniformPigment(BLACK))\n\nConstructor for a Material instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Pigment","page":"Low-level API","title":"Raytracer.Pigment","text":"Pigment\n\nThis abstract type represents a pigment, i.e., a function that associates a color with each point on a parametric surface (uv).\n\nEach subtype of this type must be a callable like (p::Pigment)(uv::Vec2D) and must return the color of the surface as a RGB{Float32} in a given Vec2D point.\n\nSee also: UniformPigment, CheckeredPigment, ImagePigment\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Pigment-Tuple{StaticArrays.SVector{2, Float32}}","page":"Low-level API","title":"Raytracer.Pigment","text":"(p::Pigment)(uv::Vec2D)\n\nReturn the color of the surface in the given point Vec2D.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.SpecularBRDF","page":"Low-level API","title":"Raytracer.SpecularBRDF","text":"SpecularBRDF <: BRDF\n\nA class representing an ideal mirror BRDF.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.SpecularBRDF-Tuple{Pigment, Float32}","page":"Low-level API","title":"Raytracer.SpecularBRDF","text":"SpecularBRDF(pigment::Pigment, threshold_angle_rad::Float32)\n\nConstructor for a SpecularBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.SpecularBRDF-Tuple{}","page":"Low-level API","title":"Raytracer.SpecularBRDF","text":"SpecularBRDF(; pigment::Pigment = UniformPigment(),\n               threshold_angle_rad::Float32 = π / 1800f0)\n\nConstructor for a SpecularBRDF instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.UniformPigment","page":"Low-level API","title":"Raytracer.UniformPigment","text":"UniformPigment <: Pigment\n\nA uniform Pigment over the whole surface.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.UniformPigment-Tuple{Float32, Float32}","page":"Low-level API","title":"Raytracer.UniformPigment","text":"(up::UniformPigment)(u::Float32, v::Float32)\n\nReturn the color of the surface in the given point (uv).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.UniformPigment-Tuple{RGB{Float32}}","page":"Low-level API","title":"Raytracer.UniformPigment","text":"UniformPigment(color::RGB{Float32})\n\nConstructor for a UniformPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.UniformPigment-Tuple{}","page":"Low-level API","title":"Raytracer.UniformPigment","text":"UniformPigment(; color::RGB{Float32} = WHITE)\n\nConstructor for a UniformPigment instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.at-Tuple{DiffuseBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}","page":"Low-level API","title":"Raytracer.at","text":"at(brdf::DiffuseBRDF, normal::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D)\n\nGet the radiance, given a point uv (Vec2D) on the surface with a DiffuseBRDF., an incoming direction in_dir and outcoming direction (Vec), a normal of the surface point (Normal).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.at-Tuple{SpecularBRDF, Normal, Vec, Vec, StaticArrays.SVector{2, Float32}}","page":"Low-level API","title":"Raytracer.at","text":"at(brdf::SpecularBRDF, normal::Normal, in_dir::Vec, out_dir::Vec, uv::Vec2D)\n\nGet the radiance, given a point uv (Vec2D) on the surface with a SpecularBRDF., an incoming direction in_dir and outcoming direction (Vec), a normal of the surface point (Normal).\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Shapes","page":"Low-level API","title":"Shapes","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"hitrecord.jl\", \"shapes.jl\", \"world.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.HitRecord","page":"Low-level API","title":"Raytracer.HitRecord","text":"HitRecord\n\nA struct representing the result of an intersection between a Ray and a Shape.\n\nMembers\n\nworld_point::Point: a Point representing the world coordinates of the hit point.\nnormal::Normal: a Normal representing the orientation of the normal to the surface where the hit happened.\nsurface_point::Vec2D: a Vec2D representing the position of the hit point on the surface of the object.\nt::Float32: distance from the origin of the ray where the hit happened.\nray::Ray: a Ray representing the the ray that hit the surface.\nmaterial::Material: a Material representing the material of the point where the hit happened.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Plane","page":"Low-level API","title":"Raytracer.Plane","text":"Plane <: Shape\n\nA Shape representing an infinite plane.\n\nMembers\n\ntransformation::Transformation: the Transformation associated with the plane.\nmaterial::Material: the Material of the spere.\n\nSee also: ray_intersection(::Ray, ::Plane)\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Plane-Tuple{Transformation, Material}","page":"Low-level API","title":"Raytracer.Plane","text":"Plane(transformation::Transformation, material::Material)\n\nConstructor for a Plane instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Plane-Tuple{}","page":"Low-level API","title":"Raytracer.Plane","text":"Plane(transformation::Transformation = Transformation(),\n       material::Material = Material())\n\nConstructor for a Plane instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Shape","page":"Low-level API","title":"Raytracer.Shape","text":"Shape\n\nAn abstract type representing a shape.\n\nSee also: Sphere, Plane\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Sphere","page":"Low-level API","title":"Raytracer.Sphere","text":"Sphere <: Shape\n\nA Shape representing a sphere.\n\nThis is a unitary sphere centered in the origin. A generic sphere can be specified by applying a Transformation.\n\nMembers\n\ntransformation::Transformation: the Transformation associated with the sphere.\nmaterial::Material: the Material of the spere.\n\nSee also: ray_intersection(::Ray, ::Sphere)\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.Sphere-Tuple{Transformation, Material}","page":"Low-level API","title":"Raytracer.Sphere","text":"Sphere(transformation::Transformation, material::Material)\n\nConstructor for a Sphere instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Sphere-Tuple{}","page":"Low-level API","title":"Raytracer.Sphere","text":"Sphere(transformation::Transformation = Transformation(),\n       material::Material = Material())\n\nConstructor for a Sphere instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.quick_ray_intersection-Tuple{Ray, Plane}","page":"Low-level API","title":"Raytracer.quick_ray_intersection","text":"quick_ray_intersection(ray::Ray, s::Plane)\n\nTells if a Ray intersect a Plane or not.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.quick_ray_intersection-Tuple{Ray, Sphere}","page":"Low-level API","title":"Raytracer.quick_ray_intersection","text":"quick_ray_intersection(ray::Ray, s::Sphere)\n\nTells if a Ray intersect a Sphere or not.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ray_intersection-Tuple{Ray, Plane}","page":"Low-level API","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, s::Plane)\n\nReturn an HitRecord of the nearest ray intersection with the given Plane.\n\nIf none exists, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ray_intersection-Tuple{Ray, Raytracer.AABB}","page":"Low-level API","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, aabb::AABB)\n\nReturn the parameter t at which Ray first hits the AABB. If no hit exists, return Inf32.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ray_intersection-Tuple{Ray, Sphere}","page":"Low-level API","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, s::Sphere)\n\nReturn an HitRecord of the nearest ray intersection with the given Sphere.\n\nIf none exists, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.World","page":"Low-level API","title":"Raytracer.World","text":"World\n\nAlias of Vector{Shape}, to store a list of Shape.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.is_point_visible-Tuple{Vector{Shape}, Point, Point}","page":"Low-level API","title":"Raytracer.is_point_visible","text":"is_point_visible(world::World, point::Point, observer_pos::Point)\n\nTells if a particular Point in a World filled with Shape is visible from the observer position.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ray_intersection-Tuple{Ray, Vector{Shape}}","page":"Low-level API","title":"Raytracer.ray_intersection","text":"ray_intersection(ray::Ray, world::World)\n\nIntersect a Ray with each Shape in World and return the nearest hit point.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Lights","page":"Low-level API","title":"Lights","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"lights.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.Lights","page":"Low-level API","title":"Raytracer.Lights","text":"Lights\n\nAlias of Vector{PointLight}, to store a list of PointLight sources.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PointLight","page":"Low-level API","title":"Raytracer.PointLight","text":"PointLight\n\nA point light (used by PointLightRenderer).\n\nThis type holds information about a point light.\n\nMembers\n\nposition::Point: a Point object holding the position of the point light in 3D space.\ncolor::RGB{Float32}: the color of the point light.\nlinear_radius::Float32: radius of the source, used to compute solid angle subtended by the light.\n\nIf linear_radius is non-zero, it is used to compute the solid angle subtended by the light at a given distance d through the formula:\n\nleft(fracmathrmlinear_radiusdright)^2\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PointLight-Tuple{Point, RGB{Float32}, Float32}","page":"Low-level API","title":"Raytracer.PointLight","text":"PointLight(position::Point, color::RGB{Float32}, linear_radius::Float32)\n\nConstructor for a PointLight instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PointLight-Tuple{}","page":"Low-level API","title":"Raytracer.PointLight","text":"PointLight(; position::Point = ORIGIN,\n             color::RGB{Float32} = WHITE,\n             linear_radius::Float32 = 0f0)\n\nConstructor for a PointLight instance.\n\nIf no parameter is specified, it return a white point light in the origin with no radius.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#PCG-random-number-generator","page":"Low-level API","title":"PCG random number generator","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"pcg.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.PCG","page":"Low-level API","title":"Raytracer.PCG","text":"mutable struct PCG <: AbstractRNG\n\nRandom number generator that implement the Permuted Congruential Generator, a simple fast space-efficient statistically good algorithms for random number generation. See O'Neill (2014).\n\nMembers\n\nstate::UInt64: the state of the generator.\ninc::UInt64: sequence identifier.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PCG-Tuple{UInt64, UInt64}","page":"Low-level API","title":"Raytracer.PCG","text":"PCG(state::UInt64 = UInt64(42), inc::UInt64 = UInt64(54))\n\nConstructor for a PCG instance.\n\nIf no parameter is specified, the generated instance will have a state of 42 and a sequence identifier of 54.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Renderer","page":"Low-level API","title":"Renderer","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"renderers.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.FlatRenderer","page":"Low-level API","title":"Raytracer.FlatRenderer","text":"FlatRenderer <: Renderer\n\nA basic Renderer that returns the color of the Shape first hit by a given Ray.\n\nThis renderer returns the color stored in the material field of the Shape first hit by the given Ray at the hit point. To this renderer there is no difference between radiated light and reflected color. There are no shades, diffusions or reflections. If there are no hits this renderer returns the value of its field background_color.\n\nMembers\n\nworld::World: the World to render.\nbackground_color::RGB{Float32}: color if the ray do not collide.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.FlatRenderer-Tuple{Ray}","page":"Low-level API","title":"Raytracer.FlatRenderer","text":"(oor::FlatRenderer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.FlatRenderer-Tuple{Vector{Shape}, RGB{Float32}}","page":"Low-level API","title":"Raytracer.FlatRenderer","text":"FlatRenderer(world::World, background_color::RGB{Float32})\n\nConstructor for a FlatRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.FlatRenderer-Tuple{Vector{Shape}}","page":"Low-level API","title":"Raytracer.FlatRenderer","text":"FlatRenderer(world::World; background_color::RGB{Float32} = BLACK)\n\nConstructor for a FlatRenderer instance.\n\nIf no color is specified, it will default on BLACK.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.OnOffRenderer","page":"Low-level API","title":"Raytracer.OnOffRenderer","text":"OnOffRenderer <: Renderer\n\nA basic bichrome Renderer that checks whether a Ray has collided or not.\n\nThis renderer returns its field off_color when the given Ray is nothing, else it returns its field on_color.\n\nMembers\n\nworld::World: the World to render.\non_color::RGB{Float32}: color if the ray collide.\noff_color::RGB{Float32}: color if the ray do not collide.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.OnOffRenderer-Tuple{Ray}","page":"Low-level API","title":"Raytracer.OnOffRenderer","text":"(oor::OnOffRenderer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.OnOffRenderer-Tuple{Vector{Shape}, RGB{Float32}, RGB{Float32}}","page":"Low-level API","title":"Raytracer.OnOffRenderer","text":"OnOffRenderer(world::World, on_color::RGB{Float32}, off_color::RGB{Float32})\n\nConstructor for a OnOffRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.OnOffRenderer-Tuple{Vector{Shape}}","page":"Low-level API","title":"Raytracer.OnOffRenderer","text":"OnOffRenderer(world::World\n              ; on_color::RGB{Float32} = WHITE,\n                off_color::RGB{Float32} = BLACK)\n\nConstructor for a OnOffRenderer instance.\n\nIf no color is specified, it will default on WHITE and BLACK.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PathTracer","page":"Low-level API","title":"Raytracer.PathTracer","text":"PathTracer <: Renderer\n\nA path-tracing Renderer that considers the optical path of a Ray from the observer to a light source.\n\nMembers\n\nworld::World: the World to render.\nbackground_color::RGB{Float32}: color if the ray do not collide.\nrng::PCG: a PCG random number generator to appropriately scatter rays.\nn::Int: how many scattered rays should be generated for the mc integration.\nmax_depth::Int: the maximum number of scatters a ray should be subjected to before stopping.\nroulette_depth::Int: the depth at which the russian roulette algorithm should start (if > 'max_depth` then it will never start).\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PathTracer-Tuple{Ray}","page":"Low-level API","title":"Raytracer.PathTracer","text":"(oor::PathTracer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PathTracer-Tuple{Vector{Shape}, RGB{Float32}, PCG, Int64, Int64, Int64}","page":"Low-level API","title":"Raytracer.PathTracer","text":"PathTracer(world::World, background_color::RGB{Float32}, rng::PCG, n::Int, max_depth::Int, roulette_depth::Int)\n\nConstructor for a PathTracer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PathTracer-Tuple{Vector{Shape}}","page":"Low-level API","title":"Raytracer.PathTracer","text":"PathTracer(world::World\n           ; background_color::RGB{Float32} = BLACK,\n             rng::PCG = PCG(),\n             n::Int = 10,\n             max_depth::Int = 2,\n             roulette_depth::Int = 3)\n\nConstructor for a PathTracer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PointLightRenderer","page":"Low-level API","title":"Raytracer.PointLightRenderer","text":"PointLightRenderer <: Renderer\n\nPoint-light tracing Renderer. This renderer is similar to what POV-Ray provides by default.\n\nMembers\n\nworld::World: the World to render.\nlights::Lights: a Lights instance that contain a list of lights.\nbackground_color::RGB{Float32}: color if the ray do not collide.\nambient_color::RGB{Float32}: the ambient color of the scene.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.PointLightRenderer-Tuple{Ray}","page":"Low-level API","title":"Raytracer.PointLightRenderer","text":"(oor::PointLightRenderer)(ray::Ray)\n\nRender a Ray and return a RBG{Float32}.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}, RGB{Float32}, RGB{Float32}}","page":"Low-level API","title":"Raytracer.PointLightRenderer","text":"PointLightRenderer(world::World, lights::Lights, background_color::RGB{Float32}, ambient_color::RGB{Float32})\n\nConstructor for a PointLightRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.PointLightRenderer-Tuple{Vector{Shape}, Vector{PointLight}}","page":"Low-level API","title":"Raytracer.PointLightRenderer","text":"PointLightRenderer(world::World, lights::Lights\n                   ; background_color::RGB{Float32} = BLACK,\n                     ambient_color::RGB{Float32} = WHITE * 1f-3)\n\nConstructor for a PointLightRenderer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.Renderer","page":"Low-level API","title":"Raytracer.Renderer","text":"Renderer\n\nAbstract type for functors that map Ray to RGB{Float32}.\n\nEach subtype of this type must be a callable like (r::Renderer)(ray::Ray) and must return a RGB{Float32}. Each subtype of this type sould have a member of type World to check for intersections of the given Ray.\n\nSee also: OnOffRenderer, FlatRenderer, PathTracer, PointLightRenderer\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Image-tracer","page":"Low-level API","title":"Image tracer","text":"","category":"section"},{"location":"api/low-level/","page":"Low-level API","title":"Low-level API","text":"Modules = [Raytracer]\nPrivate = false\nPages   = [\"imagetracer.jl\"]","category":"page"},{"location":"api/low-level/#Raytracer.ImageTracer","page":"Low-level API","title":"Raytracer.ImageTracer","text":"ImageTracer\n\nTrace an image by shooting light rays through each of its pixels.\n\nTo fill an image store it into ImageTracer along with the desired camera and apply fire_all_rays! to it. Alternatively apply iteratively fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32) on the desired ranges.\n\nMembers\n\nimage::HdrImage: a HdrImage in which save the rendered image.\ncamera::Camera: a Camera holding the observer informations.\nsamples_per_side::Int: the number of samples per side of a pixel for antialiasing algorithm.\nrng::PCG: a PCG random number generator for antialiasing algorithm.\n\nIf samples_per_side is larger than zero, antialiasing will be applied to each pixel in the image, using the random number generator rng.\n\n\n\n\n\n","category":"type"},{"location":"api/low-level/#Raytracer.ImageTracer-Tuple{HdrImage, Camera, Int64, PCG}","page":"Low-level API","title":"Raytracer.ImageTracer","text":"ImageTracer(image::HdrImage, camera::Camera, samples_per_side::Int, rng::PCG)\n\nConstructor for an ImageTracer instance.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.ImageTracer-Tuple{HdrImage, Camera}","page":"Low-level API","title":"Raytracer.ImageTracer","text":"ImageTracer(image::HdrImage, camera::Camera\n            ; samples_per_side::Int = 0,\n              rng::PCG = PCG())\n\nConstruct a ImageTracer.\n\nIf samples_per_side is not specified, antialiasing will be disabled and rng is ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.fire_all_rays!-Tuple{ImageTracer, Renderer}","page":"Low-level API","title":"Raytracer.fire_all_rays!","text":"fire_all_rays!(tracer::ImageTracer, renderer::Renderer\n               ; use_threads::Bool = true,\n                 enable_progress_bar::Bool = true)\n\nRender an image with informations stored in an ImageTracer using the specified Renderer.\n\nThis function apply iteratively fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32) for each pixel in the image contained in tracer using its camera, and then render the point using renderer.\n\nIf use_threads is true, the function will use the Threads.@threads macro to parallelize the computation.\n\nIf enable_progress_bar is true, the function will display a progress bar during the computation; this is thread safe.\n\nSee also: fire_ray(::ImageTracer, ::Int, ::Int; ::Float32, ::Float32)\n\n\n\n\n\n","category":"method"},{"location":"api/low-level/#Raytracer.fire_ray-Tuple{ImageTracer, Int64, Int64}","page":"Low-level API","title":"Raytracer.fire_ray","text":"fire_ray(tracer::ImageTracer, col::Int, row::Int\n         ; u_pixel::Float32 = 0.5f0,\n           v_pixel::Float32 = 0.5f0)\n\nShoot a Ray through the pixel (col, row) of the image contained in an [ImageTracer], using its camera informations.\n\nThe function use the fire_ray function of the associated camera (fire_ray(::OrthogonalCamera, ::Float32, ::Float32),     fire_ray(::PerspectiveCamera, ::Float32, ::Float32))\n\nThe parameters col and row are measured in the same way as they are in HdrImage: the bottom left corner is placed at (0 0). The values of u_pixel and v_pixel are floating-point numbers in the range 0 1: they specify where the ray should cross the pixel; passing 0.5 to both means that the ray will pass through the pixel's center.\n\nSee also: fire_all_rays!\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Private-documentation","page":"Private documentation","title":"Private documentation","text":"","category":"section"},{"location":"devs/private-docs/","page":"Private documentation","title":"Private documentation","text":"Documentation of all the code not explicitly exported.","category":"page"},{"location":"devs/private-docs/","page":"Private documentation","title":"Private documentation","text":"Modules = [Raytracer]\nPublic = false","category":"page"},{"location":"devs/private-docs/#Raytracer.AABB","page":"Private documentation","title":"Raytracer.AABB","text":"AABB\n\nA type representing an Axis-Aligned Bounding Box\n\n\n\n\n\n","category":"type"},{"location":"devs/private-docs/#Base.:*-Tuple{Point, Vararg{Any, N} where N}","page":"Private documentation","title":"Base.:*","text":"*(p::Point, s...)\n\nMultiplication operator. x * y * z * ...calls this function with all arguments, i.e.*(x, y, z, ...)`.\n\nReturn a Point.\n\nExamples\n\njulia> Point(1, 2, 3) * 2 * 3\nPoint with eltype Float32\nx = 6.0, y = 12.0, z = 18.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:*-Tuple{RGB, RGB}","page":"Private documentation","title":"Base.:*","text":"*(c1::RGB, c2::RGB)\n\nReturn the elementwise product of two colors.\n\nExamples\n\njulia> RGB(1f0, 2f0, 3f0) * RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 4.0, G: 10.0, B: 18.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:*-Tuple{Transformation, Ray}","page":"Private documentation","title":"Base.:*","text":"*(t::Transformation, r::Ray)\n\nTransform a Ray with the given Transformation.\n\nExamples\n\njulia> ray = Ray(ORIGIN, VEC_X)\nRay\n ↳ origin = Point(0.0, 0.0, 0.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\njulia> Transformation() * ray\nRay\n ↳ origin = Point(0.0, 0.0, 0.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\njulia> translation(2,4,-6) * ray\nRay\n ↳ origin = Point(2.0, 4.0, -6.0)\n ↳ dir    = Vec(1.0, 0.0, 0.0)\n ↳ tmin   = 1.0e-5\n ↳ tmax   = Inf\n ↳ depth  = 0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:*-Union{Tuple{T}, Tuple{Number, RGB{T}}} where T","page":"Private documentation","title":"Base.:*","text":"*(scalar::Number, c::RGB)\n*(c::RGB, scalar::Number)\n\nReturn a RGB color with each component multiplied by scalar.\n\nExamples\n\njulia> c = 2.0 * RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 8.0, G: 10.0, B: 12.0\n\njulia> RGB(4f0, 5f0, 6f0) * 2.0 == c\ntrue\n\njulia> c = 2.0 * RGB(4.0, 5.0, 6.0)\nRGB color with eltype Float64\nR: 8.0, G: 10.0, B: 12.0\n\njulia> RGB(4.0, 5.0, 6.0) * 2.0 == c\ntrue\n\nNote that the eltype of RGB is mantained.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:+-Tuple{Point, Vec}","page":"Private documentation","title":"Base.:+","text":"+(p::Point, v::Vec)\n\nReturn the elementwise sum between a Point and a Vec as an instance of Point.\n\nExamples\n\njulia> Point(1, 2, 3) + Vec(4, 5, 6)\nPoint with eltype Float32\nx = 5.0, y = 7.0, z = 9.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:+-Tuple{RGB, RGB}","page":"Private documentation","title":"Base.:+","text":"+(c1::RGB, c2::RGB)\n\nReturn the elementwise sum of two colors.\n\nExamples\n\njulia> RGB(1f0, 2f0, 3f0) + RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 5.0, G: 7.0, B: 9.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:--Tuple{Point, Point}","page":"Private documentation","title":"Base.:-","text":"-(p1::Point, p2::Point)\n\nReturn the elementwise difference of two Point as an instance of Vec.\n\nExamples\n\njulia> Point(1, 2, 3) - Point(4, 5, 6)\nVec with eltype Float32\nx = -3.0, y = -3.0, z = -3.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:--Tuple{Point, Vec}","page":"Private documentation","title":"Base.:-","text":"-(p::Point, v::Vec)\n\nReturn the elementwise difference between a Point and a Vec as an instance of Point.\n\nExamples\n\njulia> Point(1, 2, 3) - Vec(4, 5, 6)\nPoint with eltype Float32\nx = -3.0, y = -3.0, z = -3.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:--Tuple{RGB, RGB}","page":"Private documentation","title":"Base.:-","text":"-(c1::RGB, c2::RGB)\n\nReturn the elementwise difference of two colors.\n\nExamples\n\njulia> RGB(1f0, 2f0, 3f0) - RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: -3.0, G: -3.0, B: -3.0\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:≈-Tuple{HitRecord, HitRecord}","page":"Private documentation","title":"Base.:≈","text":"≈(hr1::HitRecord, hr2::HitRecord)\n\nCheck if two HitRecord represent the same hit event or not.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:≈-Tuple{Point, Point}","page":"Private documentation","title":"Base.:≈","text":"≈(p1::Point, p2::Point)\n\nCheck if two points are close.\n\nExamples\n\njulia> p = Point(1, 2, 3);\n\njulia> p ≈ Point(1, 2, 3)\ntrue\n\njulia> p ≈ Point(0, 0, 0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:≈-Tuple{RGB, RGB}","page":"Private documentation","title":"Base.:≈","text":"≈(c1::RGB, c2::RGB)\n\nCheck if two colors are close.\n\nExamples\n\njulia> c = RGB(1f0, 2f0, 3f0) * RGB(4f0, 5f0, 6f0)\nRGB color with eltype Float32\nR: 4.0, G: 10.0, B: 18.0\n\njulia> c ≈ RGB(4f0, 10f0, 18f0)\ntrue\n\njulia> c ≈ RGB(0f0, 0f0, 0f0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.:≈-Tuple{Ray, Ray}","page":"Private documentation","title":"Base.:≈","text":"≈(r1::Ray, r2::Ray)\n\nCheck if two Ray represent the same ray of light or not.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.Filesystem.cp-Union{Tuple{Float32, Float32}, Tuple{N}} where N","page":"Private documentation","title":"Base.Filesystem.cp","text":"(cp::CheckeredPigment{N})(u::Float32, v::Float32) where {N}\n\nReturn the color of the surface in the given point (uv).\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Base.inv-Tuple{Transformation}","page":"Private documentation","title":"Base.inv","text":"inv(t::Transformation)\n\nReturn the inverse Transformation.\n\nReturns a Transformation which has the m and invm fields swapped.\n\nExamples\n\n```jldoctest; setup = :(using LinearAlgebra: Diagonal) julia> t = Transformation(Diagonal([1, 2, 3, 1])) 4x4 Transformation: Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0  0.0f0  0.0f0  2.0f0  0.0f0  0.0f0  0.0f0  0.0f0  3.0f0  0.0f0  0.0f0  0.0f0  0.0f0  1.0f0 Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0         0.0f0  0.0f0  0.5f0  0.0f0         0.0f0  0.0f0  0.0f0  0.33333334f0  0.0f0  0.0f0  0.0f0  0.0f0         1.0f0\n\njulia> inv(t) 4x4 Transformation: Matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0         0.0f0  0.0f0  0.5f0  0.0f0         0.0f0  0.0f0  0.0f0  0.33333334f0  0.0f0  0.0f0  0.0f0  0.0f0         1.0f0 Inverse matrix of type StaticArrays.SMatrix{4, 4, Float32, 16}:  1.0f0  0.0f0  0.0f0  0.0f0  0.0f0  2.0f0  0.0f0  0.0f0  0.0f0  0.0f0  3.0f0  0.0f0  0.0f0  0.0f0  0.0f0  1.0f0  ```\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Raytracer.demo_load_scene-Tuple{Type{var\"#s39\"} where var\"#s39\"<:Renderer, Int64, Int64, Int64}","page":"Private documentation","title":"Raytracer.demo_load_scene","text":"demo_load_scene(renderer_type::Type{<:Renderer},\n                pt_n::Int,\n                pt_max_depth::Int,\n                pt_roulette_depth::Int)\n\nPrivate function to create a renderer for the demo function.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Raytracer.demo_load_tracer-Tuple{Tuple{Int64, Int64}, Type{var\"#s4\"} where var\"#s4\"<:Camera, Tuple{Float32, Float32, Float32}, Tuple{Float32, Float32, Float32}, Float32, Int64}","page":"Private documentation","title":"Raytracer.demo_load_tracer","text":"demo_load_tracer(image_resolution::Tuple{Int, Int},\n                 camera_type::Type{<:Camera},\n                 camera_position::Tuple{Float32, Float32, Float32},\n                 camera_orientation::Tuple{Float32, Float32, Float32},\n                 screen_distance::Float32,\n                 samples_per_side::Int\n                 ; disable_output::Bool = false)\n\nPrivate function to create a tracer for the demo function.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Raytracer.normalized_dot-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"Private documentation","title":"Raytracer.normalized_dot","text":"normalized_dot(v1::AbstractVector, v2::AbstractVector)\n\nNormalize v1 and v2 and then compute the dot product.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Raytracer.scatter_ray-Tuple{DiffuseBRDF, PCG, Vec, Point, Normal, Int64}","page":"Private documentation","title":"Raytracer.scatter_ray","text":"scatter_ray(::DiffuseBRDF, pcg::PCG, incoming_dir::Vec, interaction_point::Point, normal::Normal, depth::Int)\n\nScatter a ray on the surface.\n\n\n\n\n\n","category":"method"},{"location":"devs/private-docs/#Raytracer.scatter_ray-Tuple{SpecularBRDF, PCG, Vec, Point, Normal, Int64}","page":"Private documentation","title":"Raytracer.scatter_ray","text":"scatter_ray(::SpecularBRDF, pcg::PCG, incoming_dir::Vec, interaction_point::Point, normal::Normal, depth::Int)\n\nScatter a ray on the surface.\n\n\n\n\n\n","category":"method"}]
}
